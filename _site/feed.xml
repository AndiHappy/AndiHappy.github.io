<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 22 May 2020 16:50:45 +0800</pubDate>
    <lastBuildDate>Fri, 22 May 2020 16:50:45 +0800</lastBuildDate>
    <generator>Jekyll v4.0.1</generator>
    
      <item>
        <title>我们能够再次出发了，为了2020的第二个小目标</title>
        <description>&lt;p&gt;迎接2020年第二个小目标&lt;/p&gt;
</description>
        <pubDate>Wed, 20 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/20/hello-world-again/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/20/hello-world-again/</guid>
        
        
        <category>心情</category>
        
      </item>
    
      <item>
        <title>zookeeper的DataTree的落盘</title>
        <description>&lt;p&gt;我们的征途是星图大海！首先就是zookeeper的单实例的启动。首先我们确定进程zookeeper的启动类呢？到进程的名称中查找。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -ef| grep zoo&lt;/code&gt;来过滤出来zookeeper的进程。
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/zk/zk1.jpg&quot; alt=&quot;进程的展示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中的红圈中的就是进程的启动的JAVA类名和配置文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //示例0:单实例ZK的启动过程 2
    public static void main(String[] args) {
    	  args = new String[1];
    	  args[0] = &quot;conf/zoo.cfg&quot;;
        QuorumPeerMain main = new QuorumPeerMain();
        try {
            main.initializeAndRun(args);
        } catch (IllegalArgumentException e) {
        }
        LOG.info(&quot;Exiting normally&quot;);
        System.exit(ExitCode.EXECUTION_FINISHED.getValue());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们的启动类是：&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.zookeeper.server.quorum.QuorumPeerMain&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;无论是单例还是集群。&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/03/zoo2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/03/zoo2/</guid>
        
        <category>zookeeper</category>
        
        
      </item>
    
      <item>
        <title>zookeeper单实例的启动</title>
        <description>&lt;p&gt;我们的征途是星图大海！首先就是zookeeper的单实例的启动。首先我们确定进程zookeeper的启动类呢？到进程的名称中查找。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -ef| grep zoo&lt;/code&gt;来过滤出来zookeeper的进程。
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/zk/zk1.jpg&quot; alt=&quot;进程的展示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中的红圈中的就是进程的启动的JAVA类名和配置文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //示例0:单实例ZK的启动过程 2
    public static void main(String[] args) {
    	  args = new String[1];
    	  args[0] = &quot;conf/zoo.cfg&quot;;
        QuorumPeerMain main = new QuorumPeerMain();
        try {
            main.initializeAndRun(args);
        } catch (IllegalArgumentException e) {
        }
        LOG.info(&quot;Exiting normally&quot;);
        System.exit(ExitCode.EXECUTION_FINISHED.getValue());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们的启动类是：&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.zookeeper.server.quorum.QuorumPeerMain&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;无论是单例还是集群。&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/02/zoo/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/02/zoo/</guid>
        
        <category>zookeeper</category>
        
        
      </item>
    
      <item>
        <title>zookeeper代码片段学习</title>
        <description>&lt;p&gt;一般的开源工程，都会有一个配置型文件，这个文件是如何加载的？
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/01/zooCode1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/01/zooCode1/</guid>
        
        <category>zookeeper</category>
        
        
      </item>
    
      <item>
        <title>Binary Indexed Trees 的介绍和学习</title>
        <description>&lt;p&gt;binary indexed tree  一般翻译为树状数组，非常的好奇树状的数组是一个什么样式的？
&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;介绍&quot;&gt;介绍&lt;/h4&gt;

&lt;p&gt;我们常常使用一些数据结构使我们的算法更加的快，binary index tree 就是这样的一个数据结构。发明人为：Peter M. Fenwick 。该数据结构最早主要用于数据的压缩，在算法中，它通常用于&lt;strong&gt;存储频率和操纵累积频率表&lt;/strong&gt;。 我们将通过实例来说明该数据结构。&lt;/p&gt;

&lt;h4 id=&quot;数据结构使用的场景&quot;&gt;数据结构使用的场景&lt;/h4&gt;

&lt;p&gt;考虑一个数组a：【1，4，5，3，7，6，9，8，0，2】我们需要如下的两个操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;修改数组i的值，例如设置a[1] = 10, 表示为：modify(int i,int value)&lt;/li&gt;
  &lt;li&gt;计算数组下标i到j的总和，例如计算a[2]+a[3]+a[4]+a[5] 的值，表示为：sum(int i,int j) 或者直接是sum(j) 表示从0到j&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们的目标就是实现这两个功能。&lt;/p&gt;

&lt;p&gt;一般的操作来说，对于1，我们可以轻松的实现O(1)的时间复杂度，因为数组支持随机访问。 对于2，我们可以使用遍历的方法实现O(n)的时间复杂度。如果我们做了m次操作，最坏的情况下，都是操作2，那么时间复杂度就是O(m&lt;em&gt;n),但是利用一些数据结构，我们可以把最坏的情况，优化到O(m&lt;/em&gt;log(n))。&lt;/p&gt;

&lt;p&gt;Note：针对上面的情况下，我们也能临时申请一个数组b，存储的是b[i] = (a[1]+a[2]+…+a[i]),这样的话，操作2的时间复杂度就会变为O(1),但是我们在修改a[1]的值后，对应的修改数组b的值的变动就会变为O（n）。所以我们需要一个折中的数据结构！&lt;/p&gt;

&lt;p&gt;例如：RMQ 或者 BIT，其中BIT更加的容易实现，并且要求的空间会比RMQ要小，所以我们首先说明binary index tree。后面如果有机会，我们会学习RMQ数据结构。&lt;/p&gt;

&lt;h4 id=&quot;符号解释&quot;&gt;符号解释&lt;/h4&gt;

&lt;p&gt;再开始说明这个数据结构之前，我们首先说明一下约定的符合。&lt;/p&gt;

&lt;p&gt;BIT：Binary indexed Tree&lt;/p&gt;

&lt;p&gt;MaxIdx:源数组，也就是给定数组最大的下标值,等于数组的长度&lt;/p&gt;

&lt;p&gt;f[i] : 源数组&lt;/p&gt;

&lt;p&gt;c[i] : 简单的Sum，中间数组，c[i]=f[1] + f[2] + … + f[i]，把f数组中的树加起来。&lt;/p&gt;

&lt;p&gt;tree[i] : 就是BIT数组中的i对应的值，标识一些数据的和。这个就是折中的数据结构。&lt;/p&gt;

&lt;p&gt;num` : 标识num的反码（每一个二进制取反（1变为0，0变为1）的正数）&lt;/p&gt;

&lt;p&gt;NOTE: We set f[0] = 0, c[0] = 0, tree[0] = 0, so sometimes we will ignore index 0.&lt;/p&gt;

&lt;h4 id=&quot;基本思想&quot;&gt;基本思想&lt;/h4&gt;

&lt;p&gt;每一个整数都可以标识为二进制，也就是说n可以标识为2的0次方+2的1次方+….+2的k次方的样式，实际上就是使用2进制进行表示。这就意味着：累积频率可以表示为子频率集的总和。也就是说n，可以用2的{0,1,….k}频次来进行表示。在我们的例子中，我们的集合中的元素，使用的是一些连续的非重叠的元素构成的。具体的解释如下：&lt;/p&gt;

&lt;p&gt;令idx为BIT的索引。
令r为二进制表示法中最后一个非零数字在idx中的位置，即r为idx的最低有效非零位的位置。 tree [idx]就是索引（idx-2 ^ r +1）到idx（包括端值）的源数组f对应的数组的总和。&lt;/p&gt;

&lt;p&gt;详细的描述为：
&lt;img src=&quot;https://t9qtdg.ch.files.1drv.com/y4mf4IVU339kjC2khbuY3ucoknZ_BkOTbLAIKcM6y0AJFVLzWIn5ZNpQm62GcqeeJlkDtx0eA6k8wXP5AS6KBixolvB2kayeqHk1jIFvcDL9SfeA6KeoxCadIbf9qIIkwyMYimDkyHKUpBNv5xY5-D0kiUqS3z1_QuteCZmBAYCg_hCAIhQ7ZV9_d5h8Y2hotm-N4xUVmzoc43fCjeOGB3dZw?width=1716&amp;amp;height=246&amp;amp;cropmode=none&quot; width=&quot;1716&quot; height=&quot;246&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中f 和 c 不需要做过多的描述，需要说明一下，tree的生成。tree的生成主要依靠的是f的下标，例如:
f下标开始是1：tree[1] = f[1],
然后2进制累计：f[1]+f[2] = tree[2],
再然后就是： f[1]+f[2]+f[4] = tree[4]
再然后就是：f[1]+f[2]+f[4]+f[8] = tree[8]
……
最后：f[1]+f[2]+f[4]+f[8]+f[16] = tree[16]&lt;/p&gt;

&lt;p&gt;这样的话，tree中还没有填充完毕，对应的源数组的数据也没有使用完，那就是再来一轮，但是这轮中有一个特点就是要求连续，源数组中使用过的元素把这一轮截成一段一顿的，具体的标识为：&lt;/p&gt;

&lt;p&gt;f[1],f[2]已经使用过了，从f[3]开始：tree[3]=f[3],接着应该f[3]+f[4],但是f[4] 已经使用过了，那么这段就结束了。&lt;/p&gt;

&lt;p&gt;再从f[5] 重新开始，tree[5]=f[5],接着应该f[5]+f[6]= tree[6],在接着应该是f[5]+f[6]+f[8] 也就是 f[4+2的0次方]+f[4+2的1次方]+f[4+2的2次方] 但是f[8] 已经使用过了，就停止该轮。&lt;/p&gt;

&lt;p&gt;再次重新开始，从f[7]开始,tree[7]=f[7]，然后f[8] 已经使用过了，就停止该轮。
再次开始，从f[9]开始，tree[9]=f[9]，然后就是f[8+2的0次方]+ f[8+2的1次方] = f[9]+f[10]=tree[10],在接着，就是：f[8+2的0次方]+ f[8+2的1次方] + f[8+2的2次方] = f[9]+f[10]+f[12]=tree[12],,在接着，就是：f[8+2的0次方]+ f[8+2的1次方] + f[8+2的2次方]+f[8+2的3次方] = f[9]+f[10]+f[12]+f[16] 但是f[16] 已经使用过了，停止该轮。&lt;/p&gt;

&lt;p&gt;再次开始，从f[11]开始,tree[11]=f[11]，然后f[12] 已经使用过了，就停止该轮。&lt;/p&gt;

&lt;p&gt;再次开始，从f[13]开始,tree[13]=f[13]，然后f[14] 已经使用过了，就停止该轮。&lt;/p&gt;

&lt;p&gt;再次开始，从f[15]开始,tree[15]=f[15]，然后f[16] 已经使用过了，就停止该轮。
至此，f中的数据全部的使用完毕，tree中的数据也全部的设置完毕，具体的对应关系如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t9ou6w.ch.files.1drv.com/y4mg-aI9zx2Z17S-NYrAhs0c57JJrnNqvN2f5rNVIrkczYS1e9DEk8yZXSeU3SldApIZkwedJMkhiRtRnpxa6rNTO07IpLOj8aS-oVJkAVBggMSjGGCmyH-48tWkBx78ObplenunDl5lFwkuuhbUApt5DqFe69T0c00BAb-_G7Dp-2Bi6Bu1tCHpi5bYrdLQqbjKByumSx7U9D4-5pbs8Rfzg?width=1972&amp;amp;height=140&amp;amp;cropmode=none&quot; width=&quot;1972&quot; height=&quot;140&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用柱状图进行表达：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://idhbva.ch.files.1drv.com/y4m7yioge8YIhUwIVfjKT9B3UXBgdNMzCv-K1uxA5EacKIyiXIMgaek_oIwg9iMbyT9Nfio0KWQrgCpAk8joq_8l9B4UVozeW5ktzot7ekU43jWLCKMF6B5FlY92ZlGYc2mdpiNjMCTuPeFNJyyiXHYvQwBYachqk0Xi0nU2aTGQS1vTlR4shzBhFUECUiYOfqAlWqoQeT40HgWooWhKQ5wqw?width=684&amp;amp;height=1244&amp;amp;cropmode=none&quot; width=&quot;684&quot; height=&quot;1244&quot; /&gt;&lt;/p&gt;

&lt;p&gt;括号里面为源数组对应的数值，对应的数字为下标值，柱子代表和的相加项。&lt;/p&gt;

&lt;p&gt;有了BIT的数组以后，如果我们需要操作2，得到下标为13的和，也就是求取1到13的和。表述为：sum(13),在二级制表达中，13=1101，有趣的是sum(13) = tree(1101)+tree(1100)+tree(1000) 括号内都是二进制表达。我们将在以后更详细地揭示这种联系&lt;/p&gt;

&lt;h4 id=&quot;隔离最后一位&quot;&gt;隔离最后一位&lt;/h4&gt;

&lt;p&gt;Note：为了简洁起见，我们将使用“最后一位”来指代相应整数二进制表达的时候，最后一个1. 例如100 的二进制表述为：110 0100，相对应的最后一位为：110 0&lt;strong&gt;1&lt;/strong&gt;00&lt;/p&gt;

&lt;p&gt;BIT的算法要求数字的最后一位，所以我们需要一种更加高效的方法找到最后一位。例如，n为一个int数字，我们可以使用a1b来表示它的二进制，其中a标识二进制中最后一位1前面的数字，b标识二进制中最后一位1后面的0。 所以int数字n可以表述为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
n = a1b = a0b+1

//负数的在计算机中，使用补码进行表示 `表示反码的操作
-n = (a1b)` + 1 = a`0b` + 1 // b为全0的序列
   =  a`0(0...0)` +1
   =  a`0(1...1) +1
   =  a`1b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据我们的推到，就可以使用JAVA中的&amp;amp;运算取出最后一位了，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       a1b       // 这个就是n
&amp;amp;     a`1b       // 这个就是n的补码表示：反码+1，也就是-n
——————–—————–
= (0…0)1(0…0)

这也即是 n &amp;amp; -n 就能够得到最后一位1的二进制表述了。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;获取累计和sumint-j&quot;&gt;获取累计和：Sum(int j)&lt;/h4&gt;

&lt;p&gt;为了计算出来sum(idx)对应的值，我们需要以下的步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;初始化sum为0&lt;/li&gt;
  &lt;li&gt;sum = sum+ tree[idx]&lt;/li&gt;
  &lt;li&gt;从自身中减去idx的最后一位（即，将idx的最低有效非零位设置为零）;
并在idx大于零时重复步骤2到3。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用JAVA代码表述为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int read(int idx){
    int sum = 0;
    while (idx &amp;gt; 0){
        sum += tree[idx];
        idx -= (idx &amp;amp; -idx);
    }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以13位例子，操作的数据，如图所示：
&lt;img src=&quot;https://idj2ma.ch.files.1drv.com/y4mwOH0dAkjm6T2v7GJd1LJ_BoMB-P7__RcfQq7QTQmBHFZ29rNeW6LYUlCZqZZt3bhfaMT5ox5xIqpbSqoe7g3rt68TwUU3uhwYSTVVns54uc0s1zAP9KSO4-eaDn4WZjkxIUxXVWcJD7wYAdqd728yStrJs_wm55089b1Wk-pcXUCyX2p40_snpV11oVSWDh1l44NqdJiOXGG6b79DM50mA?width=926&amp;amp;height=292&amp;amp;cropmode=none&quot; width=&quot;926&quot; height=&quot;292&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以，我们可以看到，&lt;strong&gt;获取累计和的操作的时间复杂度为O(log MaxIdx),代码的长度也只需要不到10行&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;修改源数组某一个值的更新操作modifyint-iint-value&quot;&gt;修改源数组某一个值的更新操作：modify(int i,int value)&lt;/h4&gt;

&lt;p&gt;假设，我们修改了idx对应的值,相应的想法有两种：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;根据生成的规则，我们只需要修改idx，idx+2的0次方，idx+2的1次方，…, 直到超出Maidx或者遇到已经使用的idx就停下来。这种方法实现起来比较的复杂。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们换一个思路，&lt;strong&gt;我们在求解某一个idx的sum值的时候，可以确定这个idx关联的个序列，所以我们在更新的idx值，影响的也是那个序列，只需要更新相关联的那个序列即可。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对应的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void update(int idx, int val){
    while (idx &amp;lt;= MaxIdx){
        tree[idx] += val;
        idx += (idx &amp;amp; -idx);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们很容易得到，修改的时间复杂度为：O(log MaxIdx) 实现起来也非常的简单。&lt;/p&gt;

&lt;h4 id=&quot;获得某一个位置的确定值&quot;&gt;获得某一个位置的确定值&lt;/h4&gt;

&lt;p&gt;如果我们想获得源数组的某一个位置的值，我们不能直接的返回tree(idx).&lt;/p&gt;

&lt;p&gt;一种的方法，就是我们保留着源数组，在生成tree数组的时候，从新的申请空间，这样的话，获得某一个位置的确定值就是O(1), 当然时间复杂度也就是线性的。&lt;/p&gt;

&lt;p&gt;第二种方法，是不申请额外的空间，我们可以使用 read[idx]-read[idx-1]=f[idx] ,通过两次的获取操作（idx和idx-1）来计算f[idx] ，时间复杂度为2*log(MaxIdx).&lt;/p&gt;

&lt;p&gt;第三种种方法是，运行时间复杂度比调用读取两次（降低一个恒定因子）要低。
该方法背后的主要思想是基于以下观察:假设我们要计算两个索引之间的总和,sum(i,j), 对于两个索引中的每一个，请考虑从索引到根的路径。 这两个路径在某个索引处相遇（最晚在索引0处），此后它们重叠。 然后，我们可以计算沿这两个路径中的每个路径的相加之和，直到它们相遇并减去这两个和。 这样，我们就可以得出两个索引之间的频率之和。&lt;/p&gt;

&lt;p&gt;sum[i] = tree[i]+tree[m]+tree[n]+…+tree[0]
sum[j] = tree[j]+tree[k]+tree[p]+tree[n]…+tree[0]&lt;/p&gt;

&lt;p&gt;我们将此观察结果转换为以下算法。&lt;/p&gt;

&lt;p&gt;令x为索引，y = x-1。 
我们可以将y表示为a0b（用二进制表示），其中b包含所有1。 
那么，x是a1b（注意b由所有零组成）。 
现在，考虑应用于x的算法的第一次迭代。 
在第一次迭代中，该算法删除了x的最后一位，因此将x替换为z = a0b。&lt;/p&gt;

&lt;p&gt;现在，让我们考虑函数读取的活动索引idx如何在输入y的每次迭代之间变化。
读取的函数将idx的最后一位一一删除。
经过几个步骤，活动索引idx变为a0b（提醒一下，最初idx等于y = a0b），与z相同。在这一点上，我们停止了两条路径相遇，一条路径来自x，另一条路径来自y。现在，我们可以编写类似于此讨论的算法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int readSingle(int idx) {
	int sum = tree[idx]; // this sum will be decreased
	if (idx &amp;gt; 0) { // the special case
		int z = idx - (idx &amp;amp; -idx);
		idx--; // idx is not important anymore, so instead y, you can use idx
		while (idx != z) { // at some iteration idx (y) will become z
			sum -= tree[idx];
			// substruct tree frequency which is between y and &quot;the same path&quot;
			idx -= (idx &amp;amp; -idx);
		}
	}
	return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/01/BinaryIndexedTrees/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/01/BinaryIndexedTrees/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>快速排序和相关联的问题总结</title>
        <description>&lt;p&gt;主要是借助这道题目来总结一下快速排序相关联的内容。
&lt;!--more--&gt;
题目的描述为：Given an unsorted array nums, reorder it such that nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]….&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example 1:

Input: nums = [1, 5, 1, 1, 6, 4]
Output: One possible answer is [1, 4, 1, 5, 1, 6].
Example 2:

Input: nums = [1, 3, 2, 2, 3, 1]
Output: One possible answer is [2, 3, 1, 3, 1, 2].
Note:
You may assume all input has valid answer.

Follow Up:
Can you do it in O(n) time and/or in-place with O(1) extra space?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本题目主要依据是：&lt;a href=&quot;https://leetcode.com/problems/wiggle-sort-ii/discuss/77684/Summary-of-the-various-solutions-to-Wiggle-Sort-for-your-reference&quot;&gt;https://leetcode.com/problems/wiggle-sort-ii/discuss/77684/Summary-of-the-various-solutions-to-Wiggle-Sort-for-your-reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本的思路：&lt;/p&gt;

&lt;p&gt;如果数组已经是排好序的了，就是按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]....&lt;/code&gt; 那么我们能够把元素划分为两个组里面：
奇数组：  奇数的下标组成的数组，1，3，5 之类的
欧数组： 偶数的下标组成的数组，0，2，4，6之类的&lt;/p&gt;

&lt;p&gt;从题目要求来看，奇数组的元素要比它的相邻的元素大，也仅仅是这个要求了，我们不能推断出其他的元素之间的大小的关系，仅仅是相邻的本地的关系。&lt;/p&gt;

&lt;p&gt;就是因为这种关系，导致我们不能够从头开始去排列数组中的元素。但是从全局的角度出发，我们能够得到，对于wiggly-sort的队列，它是可以转化为 奇数组的每一个元素不小于欧树组的元素。 下面为证明的过程：&lt;/p&gt;

&lt;p&gt;例如在奇数组的一个元素a，a小于偶数组的某一个元素b，也就是：
&lt;code class=&quot;highlighter-rouge&quot;&gt;a &amp;lt; b&lt;/code&gt;
c 和 d 为a的相邻的元素，e和f 为b的相邻的元素，根据wiggly-sort的特点，那么我们知道
&lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;a ,d &amp;lt;a  和  b &amp;lt; e  , b &amp;lt; f&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在我们交换a和b，那么我们知道:
&lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt; b, d &amp;lt; b 和 a &amp;lt; e, a &amp;lt; f&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么我么就会发现，这并不影响wiggly-sort的属性，我们可以进行替换。也就是说我们可以把偶数组的大的元素替换为奇数组里面较小的元素，这样替换的结果就是：奇数组的元素不小于偶数组的元素。&lt;/p&gt;

&lt;p&gt;有了这个特性之后，我们才能够更好的处理给出的数组，有了一个全局的特性，我们分为两步来做：&lt;/p&gt;

&lt;p&gt;分区（Partition）：我们把给出的元素数组，分成两组，分别称之为S和L，相对来说，S组有m个元素，m为（n+1）/2 个元素，L拥有的是剩下的元素，并且L中的元素不小于S中的元素，也就是说L为奇数组，S为偶数组，相对来说L数组的数量不大于S数组的数量。&lt;/p&gt;

&lt;p&gt;放置（Placement）：如果L中的元素全部的大于S中的元素，我们可以直接的放置L的元素在偶数的位置，S的元素在技术中的索引的位置，trick case 就是两个数组中拥有相同元素的时候的处理。&lt;/p&gt;

&lt;p&gt;首先，我们需要确认相等元素的数量：不会比S数组元素中的数量m多。还是采用反正法：假设我们拥有了不小于m个的相等的元素，那么在wiggly-sort后，这些元素必须占据所有的奇数位或者偶数位，因为它们是相等的，所以不能够相邻。我们拥有了不小于m个元素的，就不能够保证了wiggly-sort的属性。也就是说相等的元素的最多的数量为：m个 (计算方式为(n+1)/2) 样式如下所示：
&lt;code class=&quot;highlighter-rouge&quot;&gt;3 &amp;lt;5 &amp;gt; 3 &amp;lt; 5 &amp;gt;3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后，我们将证明：如果我们把相等的元素，如果相等的元素出现在S数组中，我们把它们安排在尽可能小的偶数组中，如果出现在L数组中，我们把它们安排在尽可能大的奇数组中，这样它们就不会相邻。我们假设 k1 和 k2 为S 和 L 中相等的元素，k为k1和k2之和。首先假设n为偶数，我们可以得到m为n/2,放置完成以后，S组中最后的可以放置的位置为：2&lt;em&gt;（k1-1），L 最后可以放置的位置为：（n-1）- 2&lt;/em&gt;(k2-1) ,因为L是从最大的位置开始放置的。如果两个位置必须相隔1，这样再能够保证不相邻，那么就是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 * (k1 - 1) + 1 &amp;lt; (n - 1) - 2 * (k2 - 1)
也就是：
k1 + k2 &amp;lt; [n/2] + 1：
我们假设n为偶数，所以很容易得到：
k1 + k2 = k &amp;lt;= n/2 = [n/2] &amp;lt; [n/2] + 1.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后在假设n为奇数，可以同样的分析。这种放置的方法是成立的。&lt;/p&gt;

&lt;p&gt;得到了这个放置方式以后，我们可以开始着手设计我们的解决方案。&lt;/p&gt;

&lt;p&gt;第一种解决方案：排序，时间复杂度是：O(nlogn) 空间复杂度是：O(n)&lt;/p&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void wiggleSort(int[] nums) {
  int n = nums.length, m = (n + 1) &amp;gt;&amp;gt; 1;
  int[] copy = Arrays.copyOf(nums, n);
  Arrays.sort(copy);
  // 首先是从中间位置开始，然后开始设置
  for (int i = m - 1, j = 0; i &amp;gt;= 0; i--, j += 2) nums[j] = copy[i];
  // 从后面开始，然后开始设置，
  for (int i = n - 1, j = 1; i &amp;gt;= m; i--, j += 2) nums[j] = copy[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二种的解决的方案在第一种的基础之上，我们只需要知道分区和中间位置即可，借助了快排的思想演化出来的快速确认中间位置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void wiggleSort(int[] nums) {
    // 来源于：https://leetcode.com/problems/kth-largest-element-in-an-array/submissions/
    //划定好分区以后
    int median=findKthLargest(nums,(nums.length+1)/2);

    int odd=1;
    int even=nums.length%2==0?nums.length-2:nums.length-1;
    // 申请了O(n)的空间，放置数据
    int[] tmpArr=new int[nums.length];
    // 把大于中间值的数量全部放在了奇数位，把小于中间值的全部放在了偶数位。
    for(int i=0;i&amp;lt;nums.length;i++){
        if(nums[i]&amp;gt;median){
            tmpArr[odd]=nums[i];
            odd+=2;
            continue;
        }
        if(nums[i]&amp;lt;median){
            tmpArr[even]=nums[i];
            even-=2;
            continue;
        }
    }
// 然后在放置中间值
    while(odd&amp;lt;nums.length){
        tmpArr[odd]=median;
        odd+=2;
    }
    while(even&amp;gt;=0){
        tmpArr[even]=median;
        even-=2;
    }
    for(int i=0;i&amp;lt;nums.length;i++){
        nums[i]=tmpArr[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了便于理解，我把一个运行的数组放在了下面：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n为偶数10,odd=1,even=8
输入的数组：
3,2,1,5,6,4,11,7,0,5
分区之后的数据：
3,2,1,0,4,5,5,6,11,7]
4 6 0 11 1 7 2   3

设置中间值：
4 6 0 11 1 7 2 5 3 5

n为奇数11，odd=1，even=10
输入的数组：
3,2,1,5,6,4,11,7,0,5,13
分区之后的数据：
3,2,1,0, 4, 5, 5, 6, 7, 13, 11
  6 4 7  0  13 1 11  2       3

设置中间值：
5 6 4 7  0  13 1 11  2  5   3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此题目的关于，一个在于：O(n)的时间内确定findKthLargest的值，一个在于分析出wiggly排序的规则，都比较的困难，其中O(n)的时间内确定findKthLargest的值是基于快排的思想，具体的算法名称是：quickselect&lt;/p&gt;

&lt;p&gt;其中的伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// pseudocode
 function partition(list, left, right, pivotIndex)
     pivotValue := list[pivotIndex]
     swap list[pivotIndex] and list[right]  // Move pivot to end
     storeIndex := left
     for i from left to right-1
         if list[i] &amp;lt; pivotValue
             swap list[storeIndex] and list[i]
             increment storeIndex
     swap list[right] and list[storeIndex]  // Move pivot to its final place
     return storeIndex
  // Returns the k-th smallest element of list within left..right inclusive
  // (i.e. left &amp;lt;= k &amp;lt;= right).
  function select(list, left, right, k)
     if left = right        // If the list contains only one element,
         return list[left]  // return that element
     pivotIndex  := ...     // select a pivotIndex between left and right,
                            // e.g., left + floor(rand() % (right - left + 1))
     pivotIndex  := partition(list, left, right, pivotIndex)
     // The pivot is in its final sorted position
     if k = pivotIndex
         return list[k]
     else if k &amp;lt; pivotIndex
         return select(list, left, pivotIndex - 1, k)
     else
         return select(list, pivotIndex + 1, right, k - pivotIndex)  //The part of the list after pivotIndex has pivotIndex less elements
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外说到了快排，还会联想到Arrays.sort()的多路快排，以及普通的快排算法。
首先是普通的快速排序算法,其伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;algorithm quicksort(A, lo, hi) is
    if lo &amp;lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1)
        quicksort(A, p + 1, hi)

//轴放在了最后一位
algorithm partition(A, lo, hi) is
    pivot := A[hi]
    i := lo
    for j := lo to hi do
        if A[j] &amp;lt; pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多路快排的算法实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/******************************************************************************
 *  Compilation:  javac QuickDualPivot.java
 *  Execution:    java QuickDualPivot &amp;lt; input.txt
 *  Dependencies: StdOut.java StdIn.java
 *  Data files:   https://algs4.cs.princeton.edu/23quicksort/tiny.txt
 *                https://algs4.cs.princeton.edu/23quicksort/words3.txt
 *   
 *  Sorts a sequence of strings from standard input using dual-pivot
 *  quicksort.
 *
 *  [Warning: not thoroughly tested.]
 *   
 *  % more tiny.txt
 *  S O R T E X A M P L E
 *
 *  % java QuickDualPivot &amp;lt; tiny.txt
 *  A E E L M O P R S T X                 [ one string per line ]
 *    
 *  % more words3.txt
 *  bed bug dad yes zoo ... all bad yet
 *  
 *  % java QuickDualPivot &amp;lt; words3.txt
 *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
 *
 ******************************************************************************/

public class QuickDualPivot {

    // quicksort the array a[] using dual-pivot quicksort
    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
        assert isSorted(a);
    }

    // quicksort the subarray a[lo .. hi] using dual-pivot quicksort
    private static void sort(Comparable[] a, int lo, int hi) { 
        if (hi &amp;lt;= lo) return;

        // make sure a[lo] &amp;lt;= a[hi]
        if (less(a[hi], a[lo])) exch(a, lo, hi);

        int lt = lo + 1, gt = hi - 1;
        int i = lo + 1;
        while (i &amp;lt;= gt) {
            if       (less(a[i], a[lo])) exch(a, lt++, i++);
            else if  (less(a[hi], a[i])) exch(a, i, gt--);
            else                         i++;
        }
        exch(a, lo, --lt);
        exch(a, hi, ++gt);

        // recursively sort three subarrays
        sort(a, lo, lt-1);
        if (less(a[lt], a[gt])) sort(a, lt+1, gt-1);
        sort(a, gt+1, hi);

        assert isSorted(a, lo, hi);
    }



   /***************************************************************************
    *  Helper sorting functions.
    ***************************************************************************/
    
    // is v &amp;lt; w ?
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) &amp;lt; 0;
    }

    // exchange a[i] and a[j]
    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

   /***************************************************************************
    *  Check if array is sorted - useful for debugging.
    ***************************************************************************/
    private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }

    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i &amp;lt;= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }



    // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i &amp;lt; a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    // Read strings from standard input, sort them, and print.
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        QuickDualPivot.sort(a);
        show(a);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看看人家的示例写的，以后我们的算法，必须按照这个模板来进行书写，不然不能够体现出专业的水准啊。&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/29/L324/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/29/L324/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>打乱数组，洗牌算法</title>
        <description>&lt;p&gt;题目描述：Shuffle a set of numbers without duplicates.
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example:

// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就是一个洗牌的算法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class L384ShuffleanArray {



 private int[] nums;
 private Random random;

 public L384ShuffleanArray(int[] nums) {
  this.nums = nums;
  random = new Random();
 }

 /** Resets the array to its original configuration and return it. */
 public int[] reset() {
  return nums;
 }

 /** Returns a random shuffling of the array. */
 public int[] shuffle() {
  if (nums == null)
   return null;
  int[] a = nums.clone();
  for (int i = a.length; i &amp;gt;1; i--) {
   swap(a, i-1, random.nextInt(i));
  }
  return a;
 }

 private void swap(int[] a, int i, int j) {
  int t = a[i];
  a[i] = a[j];
  a[j] = t;
 }

 public static void main(String[] args) {
  L384ShuffleanArray test = new L384ShuffleanArray(new int[] {1,2,3,4,5,6});
  System.out.println(Arrays.toString(test.shuffle()));
  System.out.println(Arrays.toString(test.reset()));

 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 28 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/28/L384/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/28/L384/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>L378 有序矩阵中第K小的元素</title>
        <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.&lt;/p&gt;

&lt;p&gt;Note that it is the kth smallest element in the sorted order, not the kth distinct element.
&lt;!--more--&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;return 13.
Note:
You may assume k is always valid, 1 ≤ k ≤ n2.&lt;/p&gt;

&lt;p&gt;分析思路：&lt;/p&gt;

&lt;p&gt;有序的矩阵，查找第K个小的元素，这种问题归类到已有的查找问题，和上一种小白的问题不同，这类我们可以称之为有踪迹或者可以归类的问题，类似于已有问题的扩展。就称之为基础问题吧。&lt;/p&gt;

&lt;p&gt;这类我们需要一个对照的模型，这个题目那，就是二分查找。为什么是二分查找尼？因为和二分查找很类似，如果不是矩阵的模式，而是一个数组的样式，那么就二分查找的问题。&lt;/p&gt;

&lt;p&gt;然后我们就去分析这道题目为什么不能直接的使用二分查找，二分查找有一个中间值和中间值的索引：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;from  to  和 mid = from+ （to-from）/2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对应到这个题目就是：
&lt;code class=&quot;highlighter-rouge&quot;&gt;[0][0] 和 [n][n]  mid = [0+(n-0)/2][0+(n-0)/2]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;再然后就是判断第K的跳转，是 from 到 mid 还是 mid 到 from，这个就和第K小的判断有关了，需要判断 mid 在数组中是第几小，然后和K进行比较。&lt;/p&gt;

&lt;p&gt;具体的代码实现为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int kthSmallest(int[][] matrix,int k){
    int n = matrix.length;
    int from = matrix[0][0];int to = matrix[n-1][n-1];

    while(from &amp;lt; to){
        int mid = from + (to -from)/2;
        int count = 0;// 计算mid为第几小的临时变量
        int j = matrix[0].length-1;
        // 计算mid为第几小
        for(int i = 0;i &amp;lt; matrix.length;i++){
            while(j &amp;gt;0 &amp;amp;&amp;amp; matrix[i][j]&amp;gt;mid) j--;
            count += (j+1);
        }
        if(count &amp;lt;k ){
             from=mid+1;    
        }else{
            to = mid;
        }

    }
    return from;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再然后就是优化一部分的逻辑，或者说归纳统一的逻辑，例如确定mid是第几小，可以归纳为一个方法里面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int lo = matrix[0][0], hi = matrix[n-1][n-1];
        while(lo &amp;lt; hi){
            int mid = lo + (hi - lo) / 2;
            int count = countLessOrEquals(mid, matrix);
            if(count &amp;lt; k)
                lo = mid+1;
            else
                hi = mid;
        }
        return lo;
    }
    
    public int countLessOrEquals(int target, int[][] matrix){
        int i = matrix.length-1, j = 0;
        int count = 0;
        while(i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; matrix[0].length){
            if(target &amp;lt; matrix[i][j]){
                i--;
            }else{
                count += i+1;
                j++;
            }
        }
        return count;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 28 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/28/L378/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/28/L378/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>对Leetcode问题的思索</title>
        <description>&lt;p&gt;突然想起来LeetCode的每一道题，最终要的是对思维能力的锻炼，解决方案的提取，不能一味的去刷题，那样太没有趣味和底下了。&lt;/p&gt;

&lt;p&gt;问题的描述为：
Given a list of daily temperatures T, return a list such that, for each day in the input, 
 tells you how many days you would have to wait until a warmer temperature.
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  
 If there is no future day for which this is possible, put 0 instead.
For example, given the list of temperatures 
T = [73, 74, 75, 71, 69, 72, 76, 73], 
your output should be [1, 1, 4, 2, 1, 1, 0, 0].

Note: The length of temperatures will be in the range [1, 30000]. 
Each temperature will be an integer in the range [30, 100].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一步是弄懂具体的问题，输入是什么？输出什么？
第二步是确定输入和输出之间的关系，这一步是最关键的。
大概的逻辑关系，就是数据的怎么得到的逻辑关系，应该还是能够分析出来的。
第三步：按照梳理出来的逻辑关系，来映射成为代码,这一步是最难的，但是我们因为知道它最难，我们采用我们学过的东西，对它进行分解，分类，拆成小步，一点一点的来解决。&lt;/p&gt;

&lt;p&gt;我们就按照这个逻辑来分析，这个题目：&lt;/p&gt;

&lt;p&gt;首先是输入的数组：&lt;code class=&quot;highlighter-rouge&quot;&gt;[73, 74, 75, 71, 69, 72, 76, 73]&lt;/code&gt;
输出的数组是：&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 1, 4, 2, 1, 1, 0, 0]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后就是输入和输出之间的关系，此类题目的关系，可以直接的观察到，我们称之为：小白型（给不懂计算机的人员，讲解的时候，我能够比较轻松的说明这个输出数据的）：如果距离比今天温度还高的日子，还差几天。&lt;/p&gt;

&lt;p&gt;第三步，就是映射成代码，针对小白型的题目，映射为代码，只需要梳理她的逻辑即可。&lt;/p&gt;

&lt;p&gt;第3.1步：针对小白型的题目，关键在于梳理输出得到的过程。&lt;/p&gt;

&lt;p&gt;首先肯定的需要对输入的数据进行遍历，不然找不到当前值，后须值的比对机会。&lt;/p&gt;

&lt;p&gt;有了遍历的基本的框架，我们就有了当前值，当前值的索引，后须值，后须值的索引。如果后续的这个值大于当前值，那么结果值直接就能够得到，为1，如果后须值小于当前值，这个就需要临时的变量来进行存储，存储什么东西尼，这块可能就是算法的核心点了。&lt;/p&gt;

&lt;p&gt;第3.2步：针对算法的核心点，我们才用梳理一直的量，和未知的量来探索这个点&lt;/p&gt;

&lt;p&gt;当前值，当前值的索引，后须值，后须值的索引，我们只需要把那一小的值和索引存储起来，当遇到比当前值大的之后，再去更新即可。这个更新，就是找到了比当前值的索引减去 当前值的索引就好。或者没有找到比当前置大的值，但是已经遍历结束了，那么直接的设置为0即可。&lt;/p&gt;

&lt;p&gt;这样的话，我们的关键点就在于，当时数组处于下降趋势的时候，存储下降趋势的索引值。&lt;/p&gt;

&lt;p&gt;第3.3步：梳理整理的算法，合并可以合并标识的东西，我们如果声明一个临时的变量组，【当前值的索引，其实就是下标】，然后是结果值，我们就能够很大程度的优化代码的表述。我们需要保存下降趋势的下标，其实这是一个点，保存下标的方式有很多种，包括链表，数组，栈能够保存下标，但是哪一种合适尼？在分析下，我们使用这些下标干什么？在有大的值的时候，需要减去前面的下标，然后就没有用了，这个就有点栈的味道了，然后再把栈这个数据结构，套上去，看看能不能实现。&lt;/p&gt;

&lt;p&gt;其实应该有3.4步，伪代码实现，然后再去编程。&lt;/p&gt;

&lt;p&gt;栈实现的解决办法：&lt;/p&gt;

&lt;p&gt;public int[] dailyTemperatures(int[] temperatures) {
  Stack&lt;Integer&gt; stack = new Stack&amp;lt;&amp;gt;();
  int[] ret = new int[temperatures.length];
  for(int i = 0; i &amp;lt; temperatures.length; i++) {
      while(!stack.isEmpty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[stack.peek()]) {
          int idx = stack.pop();
          ret[idx] = i - idx;
      }
      stack.push(i);
  }
  return ret;
}&lt;/Integer&gt;&lt;/p&gt;

&lt;p&gt;实现了之后，还有3.5 步，去优化，去实验其他的想法。&lt;/p&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int[] dailyTemperatures(int[] temperatures) {
  int[] stack = new int[temperatures.length];
  int top = -1;
  int[] ret = new int[temperatures.length];
  for(int i = 0; i &amp;lt; temperatures.length; i++) {
      while(top &amp;gt; -1 &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[stack[top]]) {
          int idx = stack[top--];
          ret[idx] = i - idx;
      }
      stack[++top] = i;
  }
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 27 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/27/%E6%80%9D%E7%B4%A2%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/27/%E6%80%9D%E7%B4%A2%E9%97%AE%E9%A2%98/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:49. Group Anagrams</title>
        <description>&lt;p&gt;问题的描述为：
Given an array of strings, group anagrams together.
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;All inputs will be in lowercase.
The order of your output does not matter.&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关键在于，有相同字符确定的不同字符串怎么的确定？
如果把hashcode变成字母的和，是不是直接的判断hashcode的值就行了？

转念在一想不行，例如：duh, ill 值是相同的，
所以我们可以采用26个特殊的值，它们相加的时候，和自己的有关，
这个设计到质数的概念，计算出26个质数，这个比较的困难！

确定一中唯一的比对规则很重要。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
  if (strs == null || strs.length == 0) {
   return null;
  }

  Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; judge = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
  for (String key : strs) {
   char[] value = key.toCharArray();
   Arrays.sort(value);
   String tmp1 = new String(value);
   if (!judge.containsKey(tmp1)) judge.put(tmp1, new ArrayList&amp;lt;String&amp;gt;());
   judge.get(tmp1).add(key);
  }

  return new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(judge.values());

 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/26/leetcode49/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/26/leetcode49/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
  </channel>
</rss>
