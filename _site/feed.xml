<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 30 Aug 2019 20:56:06 +0800</pubDate>
    <lastBuildDate>Fri, 30 Aug 2019 20:56:06 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>编码编不下去了怎么办？</title>
        <description>&lt;p&gt;How to program when you don’t feel like it
  不想干的时候怎么办？
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;I recently well and truly “hit the wall” when it came to coding.
Every time I sat down to code, I felt stuck, like I wasn’t making any progress at all.
I was tired, de-motivated and dealing with headaches.
我很累，没有动力去处理头痛问题。
Any will to code I had previously had seemed completely gone and
when I finally got around to programming I only did the bare minimum.最低限度。&lt;/p&gt;

&lt;p&gt;Here I was on day 52 of my 100 days of code and I didn’t want to break my streak,
but there was nothing but frustration every time I sat down to program.
After a few days of this, I decided it wasn’t a sustainable solution, it was costing me more than than I was gaining.
Something had to change.
Here are some things that helped get me back on track.&lt;/p&gt;

&lt;p&gt;If you find yourself completely and utterly stuck on whatever you’re working with, don’t try to force it.
You’re more likely to produce a mess that you will dread having to work with next time and
you end up in a self reinforcing loop of shitty days.&lt;/p&gt;

&lt;p&gt;Maybe you’ve been putting off this cool tutorial or
there’s a few easy challenges on websites such as hackerrank, codewars or kattis that you can do.
It doesn’t really matter what you do, but it needs to be easy and quick.
It will boost your confidence in your programming skills and give you some much needed wins.
它将增强您对编程技巧的信心，并为您提供一些急需的胜利。&lt;/p&gt;

&lt;p&gt;You can also go back to the documentation or
see if you can find some tutorials on your problem.
Sometimes you need to go back to basic and maybe do a few exercises on the concepts involved in your project.
回头查看教程或者基础的内容&lt;/p&gt;

&lt;p&gt;Stay here until you feel comfortable cracking on with the thing that was causing you trouble.
If you find yourself easily distracted, try using the pomodoro technique.
It’s basically 25 min of focused work and a 5 minute break you repeat until you have reached your goal .
可以尝试番茄工作法&lt;/p&gt;

&lt;p&gt;The most important thing is progress, especially if it is for something like 100DaysOfCode,
but just learning in general.
Not every day is going to be equally good, but you decide how bad a bad day is.
So on bad days, stick to small achievable goals.
Gain that confidence and motivation back.
重要的是保持confidence和motivation&lt;/p&gt;

&lt;p&gt;It took me a few days of solving progressively more difficult problems in the programming language I know best,
before I felt like going back to my project. It took me 15 minutes to find and fix something that had caused me trouble for 3 days. 😅&lt;/p&gt;

&lt;p&gt;Hope some of these tips were helpful. Feel free to reach out on Twitter or comment with feedback, it’s much appreciated.
Thank you for reading ❤️&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/07/netty/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/07/netty/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（五）红黑树的删除</title>
        <description>&lt;p&gt;红黑树的删除逻辑和HashMap中的删除逻辑，是有不同的，因为在HashMap中需要维护next的属性，以便于在tree转为linkedlist的时候，比较的方便。&lt;/p&gt;

&lt;p&gt;所以我们先从普通的红黑树的删除逻辑说起。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;红黑树的删除操作&quot;&gt;红黑树的删除操作&lt;/h3&gt;

&lt;p&gt;删除操作首先需要做的也是BST（二叉搜索树）的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置（当前节点右子树的最左节点）。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。&lt;/p&gt;

&lt;p&gt;删除修复操作在遇到被删除的节点是红色节点（从2-3树的逻辑上面来看，红色节点直接删除即可，剩下的部分直接的补到红色节点相连的黑色节点即可）或者到达root节点时，修复操作完毕。&lt;/p&gt;

&lt;p&gt;删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条（经过的黑色节点是一致的约束）。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。&lt;/p&gt;

&lt;p&gt;删除操作的总体思想是从&lt;strong&gt;兄弟节点借调黑色节点&lt;/strong&gt;使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。&lt;/p&gt;

&lt;p&gt;删除修复操作分为四种情况(删除黑节点后)：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;待删除的节点的兄弟节点是红色的节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;情况1&quot;&gt;情况1&lt;/h4&gt;

&lt;p&gt;case1 由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。&lt;/p&gt;

&lt;p&gt;case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。&lt;/p&gt;

&lt;p&gt;之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p1.jpg)&quot; alt=&quot;图1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况2&quot;&gt;情况2&lt;/h4&gt;

&lt;p&gt;case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。&lt;/p&gt;

&lt;p&gt;case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p2.jpg)&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况3&quot;&gt;情况3&lt;/h4&gt;

&lt;p&gt;case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。&lt;/p&gt;

&lt;p&gt;之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p3.jpg)&quot; alt=&quot;图3&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况4&quot;&gt;情况4&lt;/h4&gt;

&lt;p&gt;Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。&lt;/p&gt;

&lt;p&gt;Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p4.jpg)&quot; alt=&quot;图4&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;删除操作的总结&quot;&gt;删除操作的总结&lt;/h4&gt;

&lt;p&gt;红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。&lt;/p&gt;

&lt;p&gt;对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。&lt;/p&gt;

&lt;p&gt;对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。&lt;/p&gt;

&lt;p&gt;具体的代码为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** From CLR */
	private void fixAfterDeletion(Node x) {
		while (x != root &amp;amp;&amp;amp; colorOf(x) == BLACK) {
			if (x == leftOf(parentOf(x))) {
				Node uncle = rightOf(parentOf(x));

				if (colorOf(uncle) == RED) {
					setColor(uncle, BLACK);
					setColor(parentOf(x), RED);
					rotateLeft(parentOf(x));
					uncle = rightOf(parentOf(x));
				}

				if (colorOf(leftOf(uncle)) == BLACK &amp;amp;&amp;amp; colorOf(rightOf(uncle)) == BLACK) {
					setColor(uncle, RED);
					x = parentOf(x);
				} else {
					if (colorOf(rightOf(uncle)) == BLACK) {
						setColor(leftOf(uncle), BLACK);
						setColor(uncle, RED);
						rotateRight(uncle);
						uncle = rightOf(parentOf(x));
					}
					setColor(uncle, colorOf(parentOf(x)));
					setColor(parentOf(x), BLACK);
					setColor(rightOf(uncle), BLACK);
					rotateLeft(parentOf(x));
					x = root;
				}
			} else { // symmetric
				assert x == rightOf((parentOf(x)));
				Node brother = leftOf(parentOf(x));

				if (colorOf(brother) == RED) {
					setColor(brother, BLACK);
					setColor(parentOf(x), RED);
					rotateRight(parentOf(x));
					brother = leftOf(parentOf(x));
				}

				if (colorOf(rightOf(brother)) == BLACK &amp;amp;&amp;amp; colorOf(leftOf(brother)) == BLACK) {
					setColor(brother, RED);
					x = parentOf(x);
				} else {
					if (colorOf(leftOf(brother)) == BLACK) {
						setColor(rightOf(brother), BLACK);
						setColor(brother, RED);
						rotateLeft(brother);
						brother = leftOf(parentOf(x));
					}
					setColor(brother, colorOf(parentOf(x)));
					setColor(parentOf(x), BLACK);
					setColor(leftOf(brother), BLACK);
					rotateRight(parentOf(x));
					x = root;
				}
			}
		}

		setColor(x, BLACK);
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 06 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/06/hashmap/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/06/hashmap/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（四）红黑树的插入</title>
        <description>&lt;p&gt;理解了2-3树和红黑树的对应的关系，再去梳理红黑树的插入和删除操作，就会更加的容易理解和记忆一点。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;红黑树的插入操作&quot;&gt;红黑树的插入操作&lt;/h3&gt;

&lt;h4 id=&quot;情况1&quot;&gt;情况1&lt;/h4&gt;

&lt;p&gt;当为Null树的时候，插入第一个节点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;节点设置为根节点，设置为黑色，如下图所示：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt1.jpg&quot; alt=&quot;图1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况2&quot;&gt;情况2&lt;/h4&gt;
&lt;p&gt;存在父节点的情况下，插入节点，分为两种情况：2-3树上面就是有2节点形成3节点的过程。
  2.1 插入的是左节点，也就是比父节点要小，直接的插入即可,但是需要考虑着色的问题。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt2.jpg&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.2 如果插入的节点比父节点大，就需要变换顺序，外加改变颜色了，如下图：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt3.jpg&quot; alt=&quot;图3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中的坐旋转，使用文字描述为：&lt;/p&gt;

&lt;p&gt;左旋： 右节点（right）和其父节点（right-parent）进行交换，交换的过程中，right-parent 的右分支被强制的叉开，所以把right的左孩子（right-left）放到了right-parent 的右分支，然后把right-parent 放到了right的左孩子上。&lt;/p&gt;

&lt;p&gt;图片的描述为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt4.jpg&quot; alt=&quot;图4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码描述为：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** From CLR
 *  旋转节点：为 p.right
 *  方法的输入的参数为 旋转子树的根节点，可以理解为图中的node节点
 * */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rotateLeft&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// p的右节点即是旋转上升的节点，然后旋转上升后，该节点的左节点为P，原来的左节点，这是为p的右节点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 设置循转节点的父节点，以及P原来父节点的指向的设置&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//旋转节点为右节点，原来的左孩子设置为P&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;情况3&quot;&gt;情况3&lt;/h4&gt;
&lt;p&gt;在父节点存在的情况下，如果左孩子的左孩子一直插入的情况下，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt5.jpg&quot; alt=&quot;图5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候就是右旋的操作，具体的文字描述为：&lt;/p&gt;

&lt;p&gt;右旋： 左节点（left）和其父节点（left-parent）进行交换，交换的过程中，left-parent 的左分支被强制的叉开，所以把left的右孩子（left-right）放到了left-parent 的左分支，然后把left-parent 放到了left的左孩子上。&lt;/p&gt;

&lt;p&gt;具体的图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt6.jpg&quot; alt=&quot;图6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的代码示例为：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** From CLR
	 * 该方法的参数，并不是被旋转的节点，而是调整子树的根节点，可以理解为图中的node节点
	 * */&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rotateRight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// p的左节点设置为 原来左节点的右子树&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;c1&quot;&gt;// 旋转过程中父节点的设置，上升节点的父节点以及原来父节点的指向的设置&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;c1&quot;&gt;// 最后右节点和p旋转后父节点的设置&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;情况4&quot;&gt;情况4：&lt;/h4&gt;
&lt;p&gt;特殊的情况下，如：红色的右节点下插入左孩子，或者红色的左节点下，插入右孩子。
具体的情况的一种如下图所示：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt7.jpg&quot; alt=&quot;图7&quot; /&gt;
针对这种情况，第一步我们可以通过一次左旋转，变成我们熟悉的情况3.具体的操作如下图所示：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt8.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入的情况总结&quot;&gt;插入的情况总结&lt;/h3&gt;

&lt;p&gt;具体的操作分为三种：左旋，右旋，变色
具体的情况如下图所示：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt9.jpg&quot; alt=&quot;图9&quot; /&gt;
具体的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int put(K key) {
		Node t = root;
		if (t == null) {
			root = new Node(key, null);
			size = 1;
			modCount++;
			return 1;
		}

		Node parent = findParent(key);
		if (parent != null) {
			int cmp = this.comparator != null ? this.comparator.compare(key, parent.key)
					: ((Comparable&amp;lt;? super K&amp;gt;) key).compareTo(parent.key);
			Node e = new Node(key, parent);
			if (cmp &amp;lt; 0)
				parent.left = e;
			else
				parent.right = e;
			fixAfterInsertion(e);
			size++;
			modCount++;
			return 1;
		} else {
			return -1;
		}
	}

  private void fixAfterInsertion(Node x) {
		x.color = RED;
		// x 为null，x为root的第一个节点，直接的跳走
		/**
		 * 如果x parent 节点为黑，那么x 为红，直接的跳过即可。
		 * */
		while (x != null &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color == RED) {
			if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
				Node uncle = rightOf(parentOf(parentOf(x)));
				if (colorOf(uncle) == RED) {
					// 图三
					setColor(parentOf(x), BLACK);
					setColor(uncle, BLACK);
					setColor(parentOf(parentOf(x)), RED);
					x = parentOf(parentOf(x));
				} else {
					// uncle 节点为黑或者uncle 节点为null
					if (x == rightOf(parentOf(x))) {
						x = parentOf(x);
						/**
						 * 这个操作，非常的有意思，按照左旋方法的定义，参数应该是旋转子树的根节点，但是这个传入的是旋转节点
						 * 然后，就变成了：x右节点和x交换位置，并且在交换位置的过程中，x有右节点变为了左节点。
						 * 图②
						 * */
						rotateLeft(x);
					}
					// 调整颜色，当前节点为红色节点，是定死的。所以把父节点设为黑，爷节节点设置为红
					setColor(parentOf(x), BLACK);
					setColor(parentOf(parentOf(x)), RED);
					// x 为left节点，进行右旋
					// 图①
					rotateRight(parentOf(parentOf(x)));
				}
			} else {
				Node uncle = leftOf(parentOf(parentOf(x)));
				if (colorOf(uncle) == RED) {
					setColor(parentOf(x), BLACK);
					setColor(uncle, BLACK);
					setColor(parentOf(parentOf(x)), RED);
					x = parentOf(parentOf(x));
				} else {
					if (x == leftOf(parentOf(x))) {
						x = parentOf(x);
						rotateRight(x);
					}
					setColor(parentOf(x), BLACK);
					setColor(parentOf(parentOf(x)), RED);
					rotateLeft(parentOf(parentOf(x)));
				}
			}
		}
		root.color = BLACK;
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/05/hashmap/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/05/hashmap/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（三）学习红黑树</title>
        <description>&lt;p&gt;HashMap的源码在JDK 1.8后引入了红黑树，但是看到红黑树的定义：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个节点或者是红色，或者是黑色&lt;/li&gt;
  &lt;li&gt;根节点是黑色&lt;/li&gt;
  &lt;li&gt;每一个叶子节点(最后的空节点)是黑色的&lt;/li&gt;
  &lt;li&gt;如果一个节点是红色的，那么它的孩子节点都是黑色的&lt;/li&gt;
  &lt;li&gt;从任意一个节点到叶子节点，经过的黑色节点是一样的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完全的不清楚为什么这么定义，以及这么定义的原因是什么。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;先导&quot;&gt;先导&lt;/h3&gt;

&lt;p&gt;先说红黑树的由来，是为了查找的平衡，从二叉查找树说起。&lt;/p&gt;

&lt;p&gt;二叉查找树：从根节点开始，左节点的值小于根节点，右节点的值大于右节点。并且每一颗子树都满足这个条件，所以便于查找：查找的时候，只需要比对就能够瞬速的找到所在子树，继而找到对应的节点。但是二叉查找树有一个缺点就是：容易偏向一侧，我们向往的二叉查找树是图一，结果却有很多图二的情况。
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t1.jpg&quot; alt=&quot;图1&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t2.jpg&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;平衡树2-3树&quot;&gt;平衡树：2-3树&lt;/h3&gt;
&lt;p&gt;在这种需求下，平衡树的概念就应运而生了。红黑树就是一种平衡树，它可以保证二叉树基本符合我们预料的那种平衡的结构，但是理解红黑树之前，必须先了解另一种树，叫2-3树，红黑树背后的逻辑就是它。&lt;/p&gt;

&lt;p&gt;2-3树：2-3树满足二分搜索树的性质。不同的是在2-3树中，存在两种节点。一种是有两个叶子节点的，我们称作“2节点” 如图3；另一种是有三个叶子节点的，我们称作“3节点”，如图4，图5展示的是一个完整的2-3 树，满足从根节点到任意一个叶子节点的高度都是相同的。
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t3.jpg&quot; alt=&quot;图3&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t4.jpg&quot; alt=&quot;图4&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t5.jpg&quot; alt=&quot;图5&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-3树如何保持平衡&quot;&gt;2-3树如何保持平衡&lt;/h3&gt;

&lt;p&gt;2-3树平衡的保持，主要依赖两个操作：拆分和合并。其中拆分主要发生在3节点插入时候，如下图6，图7完整的展示可一个查分的过程：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t6.jpg&quot; alt=&quot;图6&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t7.jpg&quot; alt=&quot;图7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拆分的过程主要是形成了一个4节点（类似于2节点，3节点的概念），(4 7 9) 这个节点，然后通过4节点的中间状态查分为三个2节点. &lt;br /&gt;
但是在图7的第二步，拆分过后的2-3树已经不满足：从根节点到任意的叶子节点的高度是完全一致的平衡性，所以我们需要合并的操作，如图7中的第三步。&lt;/p&gt;

&lt;p&gt;如果合并过程中，出现了四节点，那么我们再次的查分，这两个操作可以混合使用，如图8.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t8.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-3树和红黑树的关系&quot;&gt;2-3树和红黑树的关系&lt;/h3&gt;

&lt;p&gt;对于2-3树中的“2节点”，对应于红黑树中的“黑节点”，即相当于普通二分搜索树中的一个节点。&lt;/p&gt;

&lt;p&gt;对于2-3树中的“3节点”，相当于普通二分搜索树中的两个节点融合在一起，我们如何来描述这种融合在一起的两个节点之间的关系呢？&lt;/p&gt;

&lt;p&gt;其实很简单，如果我们将连接这两个节点的边涂成红色，就可以表示这两个节点是融合的关系，即2-3树中的一个“3节点”。&lt;/p&gt;

&lt;p&gt;对于树这种数据结构，我们在定义的时候通常都是针对节点进行定义，并没有对节点之间的边进行定义，我们如何来表示这条被涂成红色的边呢？&lt;/p&gt;

&lt;p&gt;大家都知道，对于树中的任意一个节点，都是只有一个父亲节点，所以与其父节点相连接的边可以用该节点进行表示。那么我们就可以将这两个节点中较小的节点（作为左子树的节点）涂成红色，就可以很好地表示这两个节点融合的关系了。&lt;/p&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t9.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后一颗2-3树的就可以转化为一颗红黑树了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t10.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;再次的分析红黑树的性质&quot;&gt;再次的分析红黑树的性质&lt;/h3&gt;

&lt;p&gt;讨论了2-3树与红黑树之间的关系，我们再回过头来看一下红黑树的5条定义和性质，会发现很好理解了。&lt;/p&gt;

&lt;p&gt;1.每个节点或者是红色，或者是黑色
这条定义很好理解，在此不做解释。&lt;/p&gt;

&lt;p&gt;2.根节点是黑色&lt;/p&gt;

&lt;p&gt;根据之前说过的，红色的节点对应于2-3树中“3节点”中较小的那个节点，拆成两个“2节点”的话则是一个左子树的节点，即&lt;strong&gt;红色的节点总是可以和其父节点进行融合&lt;/strong&gt;，所以红色节点一定有父节点，显然根节点不能是红色，所以根节点是黑色。&lt;/p&gt;

&lt;p&gt;3.每一个叶子节点(最后的空节点)是黑色的&lt;/p&gt;

&lt;p&gt;这条性质和第2条是对应的。对于叶子节点（最后的空节点），一颗空树的根节点也为黑色，所以与其说第三条是一条性质，不如说也是一个定义。&lt;/p&gt;

&lt;p&gt;4.如果一个节点是红色的，那么它的孩子节点都是黑色的&lt;/p&gt;

&lt;p&gt;根据上面2-3树与红黑树两种节点的对比图，我们很容易看到，红色节点的两个子树，对应2-3树中的话，要么是一个“2节点”，要么是一个“3节点”，而不管是“2节点”还是“3节点”，相连的第一个节点都是黑色的，所以说红色节点的孩子节点都是黑色的。&lt;/p&gt;

&lt;p&gt;5.从任意一个节点到叶子节点，经过的黑色节点是一样的&lt;/p&gt;

&lt;p&gt;根据2-3树与红黑树的关系对比图，可以发现，红黑树中一个黑色节点对应2-3树中一整个节点（“2节点”或“3节点”），而2-3树是完全平衡的树，从根节点到任意路径的叶子节点，经过的节点个数都是相同的，对应红黑树中，即从任意节点到叶子节点，经过的黑色节点是一样的。&lt;/p&gt;

&lt;p&gt;对比2-3树总结起来，其实也就两条。其中一条是关于着色的：每个节点都有颜色，非红即黑。根节点，叶子节点为黑色。红色节点的孩子节点为黑色。另外一条是关于2-3树的平衡性的。即是到每一个叶子节点是平衡的，对应的红黑树，也就是经过的黑色节点是一样的。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/04/hashmap0/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/04/hashmap0/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（二）</title>
        <description>&lt;p&gt;HashMap的源码在JDK 1.8 的Put和Remove操作。&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cm&quot;&gt;/**
   * Implements Map.put and related methods.
   * put逻辑：
   * 	1. 检查hashmap中的table是否需要扩容
   * 	2.1 确定放入的值的位置：(n - 1) &amp;amp; hash，hash的计算方式：(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)
   * 	2.2 如果该位置没有值，直接的新建Node，设置key，value值，放入table
   * 	2.3 如果该位置有Node值，判断key值有否相同
   * 		2.3.1  相同则是替换value值
   *     2.3.2  不相同则是判断Node值的类型
   *     		2.3.2.1 如果Node值的类性是：TreeNode，标识为一颗红黑树的类型，调用putTreeVal
   */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* n 代表的是原始的hashmap中 table 的 length值*/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;//扩容&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// &amp;amp; 值的运算：得到的值只可能比n-1小,如果table[i]为null,直接的赋值即可。&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//①&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// p=table[i]; hash值相同，k值和p的key值一样，直接的替换&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//②&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;//替换value值&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//③&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// 如果有值，并且Node的类型是TreeNode类型，调用TreeNode的putTreeVal&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// TODO 暂时的放弃这个分支的分析&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putTreeVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// ④&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果不是TreeNode，那就是一个链表的类型&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                      &lt;span class=&quot;c1&quot;&gt;// 如果达到了7个，开始变换数据结构&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TREEIFY_THRESHOLD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -1 for 1st&lt;/span&gt;
                          &lt;span class=&quot;c1&quot;&gt;//传入的参数竟然是table和hash值&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;treeifyBin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;c1&quot;&gt;//4.2&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// existing mapping for key&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//               afterNodeAccess(e);&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;afterNodeInsertion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里面最重要的就是③ 和 ④ 两种情况，其中4种的 &lt;strong&gt;treeifyBin(tab, hash)&lt;/strong&gt;  会首先被触发，在链表元素为七的时候，也就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k0 -&amp;gt; k1 -&amp;gt; k2 -&amp;gt; k3 -&amp;gt; k4 -&amp;gt; k5 -&amp;gt; k6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在k6 加入的时候，节点到达了7个的时候，触发：treeifyBin&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
  	 	this.table = tab;
       int n, index; Node&amp;lt;K,V&amp;gt; e;
//       if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
       if (tab == null || (n = tab.length) &amp;lt; 1)
           resize();
       else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
           TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
           // 先把Node节点全部的转化为TreeNode节点
           do {
               TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, null);
               if (tl == null)
                   hd = p;
               else {
                   p.prev = tl;
                   tl.next = p;
               }
               tl = p;
           } while ((e = e.next) != null);

           // 此时的hd为0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;...-&amp;gt;end 为链表的数据结构
           if ((tab[index] = hd) != null)
          	 	 // 链状的TreeNode节点转为为树状
               hd.treeify(tab);
       }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法最主要的一点是通过一个 do while 循环把Node节点转化为TreeNode节点，然后进行红黑树转化，调用：treeify。&lt;/p&gt;

&lt;p&gt;从这里我们可以得到③的类型判断的逻辑了，如果节点是TreeNode节点的类型，那么数组内存储的就是一个红黑树了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (p instanceof TreeNode)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;直接的调用，红黑树的插入操作了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于红黑树的逻辑，我们下篇接着说，这篇我们主要集中在Map的数据结构。&lt;/p&gt;

&lt;p&gt;最后还有一个推测：从这里我们可以推测remove的逻辑，当TreeNode的节点少于8个，也就是7个的时候，调用链表话的操作，再次转化数据结构吗？&lt;/p&gt;

&lt;h3 id=&quot;remove操作&quot;&gt;REMOVE操作&lt;/h3&gt;

&lt;p&gt;直接上代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public V remove(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hash 算法为同一个算法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;

    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp; (p = tab[index = (n - 1) &amp;amp; hash]) != null) {

        Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
        // finde node value
        if (p.hash == hash &amp;amp;&amp;amp;((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;amp;&amp;amp;((k = e.key) == key ||(key != null &amp;amp;&amp;amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }

        // !matchValue || (v = node.value) == value
        // node为key值对应的节点，p为key的前一个节点
        if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||(value != null &amp;amp;&amp;amp; value.equals(v)))) {
            if (node instanceof TreeNode)
               // node 为当前的节点
                ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;

            ++modCount;
            --size;
//               afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;像比较PUT的逻辑来说，Remove操作，首先要找到删除的节点，然后根据删除节点所在的数组中存储节点的类型，来进行确定，是进行链表的删除操作，还是红黑树的节点删除操作。&lt;/p&gt;

&lt;p&gt;节点的转化，肯定在红黑的删除操作中，由于红黑树的删除的操作比较的复杂，所以我们直接看我们关心的逻辑即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; final void removeTreeNode(MyMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab,boolean movable) {

   。。。。。。。。
   if (root == null || (movable&amp;amp;&amp;amp; (root.right == null|| (rl = root.left) == null || rl.left == null))) {
           	 	 // 由树转化为链表的数据结构
                tab[index] = first.untreeify(map);  // too small
                return;
            }
   。。。。。。。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;判断也比较有意思&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final Node&amp;lt;K,V&amp;gt; untreeify(MyMap&amp;lt;K,V&amp;gt; map) {
    Node&amp;lt;K,V&amp;gt; hd = null, tl = null;
    for (Node&amp;lt;K,V&amp;gt; q = this; q != null; q = q.next) {
        Node&amp;lt;K,V&amp;gt; p = map.replacementNode(q, null);
        if (tl == null)
            hd = p;
        else
            tl.next = p;//⑤
        tl = p;
    }
    return hd;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从代码中可以看到，确实和我们预料的情况一样。在一定的条件下，树直接退化为链表数据结构。&lt;/p&gt;

&lt;p&gt;关于红黑树的操作，HashMap的操作，也和普通的红黑树不一样，准确的说，是比普通的红黑树复杂，因为涉及到树节点集成的next， 和自己定义的pre指向的保持，不然也不会有 树直接退化为链表 的方法untreeify 的操作⑤标注的next操作。具体是如何的维持，我们下篇再说。&lt;/p&gt;
</description>
        <pubDate>Sat, 03 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/03/hashmap/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/03/hashmap/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码</title>
        <description>&lt;p&gt;HashMap的源码在JDK 1.7 的时候，还算是可以看的比较的明白，1.8后引入了红黑树，就变得看的费劲了。
所以这次尽可能详细的注释源码，也为这块做一个总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;粗略的印象&quot;&gt;粗略的印象&lt;/h3&gt;

&lt;p&gt;首先是最初的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/hashmap1.jpg&quot; alt=&quot;Map原来的数据结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个是我们以前常见的map的数据结构：桶，也可以称之为链表数组。但是1.8以后，在某些特殊的情况下，链表会和红黑树相互的转化，变成下面的这种数据结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/hashmap2.jpg&quot; alt=&quot;Map原来的数据结构2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;但是具体是如何转化的，如何实现的，我们需要跟踪代码，进行详细的跟踪。
为了调试和注释的方便，我重写了hash的算法：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
   * 3288498===&amp;gt; 3288448
   *
   * 1100100010110110110010
   * 0000000000000000110010
   * 1100100010110110000000
   *
   * 高中低位的字符全部的参与进来，把key的hash值打散
   */&lt;/span&gt;
	 &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//     int h;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/span&gt;

     &lt;span class=&quot;cm&quot;&gt;/**
		  * 为了测试，hash值一律的返回0
		  * */&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样的话，全部的元素都会添加到桶的第一个位置上，把数据的变化表现的更加详尽。&lt;/p&gt;

&lt;h3 id=&quot;测试代码&quot;&gt;测试代码&lt;/h3&gt;

&lt;p&gt;暂时先看Map最主要的两个操作，PUT和REMOVE，因为这两个操作针对的都是元素的增加和减少，在这个过程中能够看到数据结构的变化。&lt;/p&gt;

&lt;p&gt;测试的代码如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//正经的测试&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;MyMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mymap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;k&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;v&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;k5&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;k&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据结构的准备工作&quot;&gt;数据结构的准备工作：&lt;/h3&gt;

&lt;p&gt;从小到大的来说，首先是 Key 和 Value 组成键值对的表示 Node节点，Node节点表示为链表的节点，所以就有了next的属性。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 包含一个hash值&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 指向下一个节点&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后就是红黑树节点的表示，具有left，right，red之类的标志性属性，不过在HashMap中，红黑树的节点是Node的子类，主要是为了转换的方便，后面的代码中可以看到。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkedHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// red-black tree links&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// needed to unlink next upon deletion&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从这个我们还可以看到，不仅有right ，left，red，还有parent，pre属性。&lt;/p&gt;

&lt;p&gt;最后就是存储节点的数组的数据结构：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 非序列化&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TreeNode继承自Node，在数组的表述中直接的声明Node节点即可。&lt;/p&gt;

&lt;h3 id=&quot;put操作&quot;&gt;PUT操作&lt;/h3&gt;

&lt;p&gt;代码的注释已经非常的详细，我会在代码的操作的过程中添加对应的图示，以便于更加明白的说明：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;期中的 &lt;em&gt;hash(key)&lt;/em&gt; 经过了改写，全部的返回0，这样数据结构变化的会更加的明显，但是在原始的HashMap肯定不是这样的，如hash方法中的注释一样，原始的hash注重散列的均匀度。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cm&quot;&gt;/**
   * Implements Map.put and related methods.
   * put逻辑：
   * 	1. 检查hashmap中的table是否需要扩容
   * 	2.1 确定放入的值的位置：(n - 1) &amp;amp; hash，hash的计算方式：(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)
   * 	2.2 如果该位置没有值，直接的新建Node，设置key，value值，放入table
   * 	2.3 如果该位置有Node值，判断key值有否相同
   * 		2.3.1  相同则是替换value值
   *     2.3.2  不相同则是判断Node值的类型
   *     		2.3.2.1 如果Node值的类性是：TreeNode，标识为一颗红黑树的类型，调用putTreeVal
   */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* n 代表的是原始的hashmap中 table 的 length值*/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;//扩容&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// &amp;amp; 值的运算：得到的值只可能比n-1小,如果table[i]为null,直接的赋值即可。&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//①&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// p=table[i]; hash值相同，k值和p的key值一样，直接的替换&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//②&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;//替换value值&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//③&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// 如果有值，并且Node的类型是TreeNode类型，调用TreeNode的putTreeVal&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// TODO 暂时的放弃这个分支的分析&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putTreeVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// ④&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果不是TreeNode，那就是一个链表的类型&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                      &lt;span class=&quot;c1&quot;&gt;// 如果达到了7个，开始变换数据结构&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TREEIFY_THRESHOLD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -1 for 1st&lt;/span&gt;
                          &lt;span class=&quot;c1&quot;&gt;//传入的参数竟然是table和hash值&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;treeifyBin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;c1&quot;&gt;//4.2&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// existing mapping for key&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//               afterNodeAccess(e);&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;afterNodeInsertion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/02/hashmap/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/02/hashmap/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>怎么读书</title>
        <description>&lt;p&gt;It’s not about how many books you read, it’s about how much you retain from what you read. &lt;br /&gt;
&lt;!--more--&gt;
Most people I talk to don’t have a reading strategy. They just pick up something and start reading. I used to be like that. But now, that’s unthinkable to me. Sure, you might read a novel for entertainment.&lt;/p&gt;

&lt;p&gt;But think about it; why do you even read a non-fiction(虚构的) book in the first place?
 Exactly, you want to get something out of it.
You want to learn things that you can apply in your life to grow.
That’s the whole point.
I’m often asked: “How do you remember information you read in books?”
In this post, I’ll explain my system.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Have A Purpose
Before I even think about which books I’m going to read, I think about what I’m trying to achieve.
 I strongly believe that the content of books should align（） with what’s going on in your life.
I’ll give you an example.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But back in 2011, that kind of stuff wasn’t on my mind.
I had just finished my degree and started a business.
I was hustling（忙碌） like a moron（笨蛋）（我像个白痴一样忙碌着） and only thinking about growing our business.
That’s why you need a purpose to read.&lt;/p&gt;

&lt;p&gt;Only read books that teach you how to overcome your current challenges.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;See Yourself As A Teacher
Knowledge is only good if you apply it, right? But here’s one thing a lot of people don’t consider:
 Sharing knowledge is a great application. （分享知识是一个很好的应用）
You might not be a teacher, but if you act like one, you’re already applying knowledge.
All it takes is a mindset shift.（心态的转变）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Don’t just ‘read’ a book. No, devour （如饥似渴）a book and talk about it with others.&lt;/p&gt;

&lt;p&gt;Say to yourself: “I must focus on the book at hand because I’m going to share everything I learned with others. I better know my shit.”&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Highlight &amp;amp; Make Mental Connections&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The more connections you make between pieces of information in your brain, the better you remember it.&lt;/p&gt;

&lt;p&gt;I do that by making a lot of notes.&lt;/p&gt;

&lt;p&gt;If you think books are sacred（神圣的） and shouldn’t be highlighted and written on,
you will never retain a lot from books. Making notes, folding pages, and highlighting text is simple and practical.&lt;/p&gt;

&lt;p&gt;That’s why I always keep a highlighter and pen with me.
If you read digitally, you only need your finger
— just don’t forget to highlight interesting passages.&lt;/p&gt;

&lt;p&gt;Here are some other tips that help me to make better connections between information:&lt;/p&gt;

&lt;p&gt;I have a separate “Book Notes” folder in my note-taking app.
When I highlight something very important, I take a picture of that page and upload it to my Book Notes.
Then, I immediately write WHY it’s important and how I can use it.&lt;/p&gt;

&lt;p&gt;I use this process because I often highlight things, and when I look back, I think: “Why did I highlight this?”&lt;/p&gt;

&lt;p&gt;如何安排会看，是非常重要的：具体可行的建议&lt;/p&gt;

&lt;p&gt;So always write down why you highlighted something. You don’t have to do it for every highlight. Just do it for sections that you immediately have an application for. I often write down how I can use a piece of advice in my business. And when I get an idea for an article, I think of a title and attach a picture of the text that I highlighted.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Visualize &amp;amp; Imagine&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another great way to make connections in your mind is by visualizing（使形象化） what you’re learning.
We’re visual learners, and our memories are also visual.&lt;/p&gt;

&lt;p&gt;What I like to do when I read is to have imaginary conversations about the stuff that I’m reading. I imagine myself sitting together with a friend and talking about the subject. Or, when I read a piece of useful advice, I visualize myself actually doing that thing.&lt;/p&gt;

&lt;p&gt;I remember vividly when I read How To Win Friends And Influence Peopleby Dale Carnegie for the first time. One of the pieces of advice Carnegie gives, is to become genuinely（真诚的） interested in people.&lt;/p&gt;

&lt;p&gt;So I visualized myself having a conversation with a stranger and being genuinely interested in what that person had to say. When you visualize something, it’s almost like the real thing.&lt;/p&gt;

&lt;p&gt;Visualization is also a common self-improvement tool that’s been used many top-performers. Recently retired NBA-player Paul Pierce once explained how he uses it before a game:&lt;/p&gt;

&lt;p&gt;“I probably visualize myself, the shots I’m going to get in the game, how I’m going to play defense, what we have to do to stop the other team’s best player, what it’s going to take out of me, the whole aspect of the game.”&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Immediately Apply One Piece Of New Knowledge&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Look at your life. Ask yourself: How can I grow? That can be personally, financially 经济上的 or spiritually 精神上的.&lt;/p&gt;

&lt;p&gt;Understand that growth doesn’t happen by itself. Learning new skills, earning more money, having a great relationship — it all takes hard work.
But you can make that growth a lot easier if you apply the things you learn in books.&lt;/p&gt;

&lt;p&gt;Remember: Knowledge alone is completely useless.&lt;/p&gt;

&lt;p&gt;There’s nothing sadder 可悲的 than a well-read person who holds himself captive by the four walls of his room.&lt;/p&gt;

&lt;p&gt;You must go out there and apply things you learn.
Once you do that, you will grow.
No doubt about it. So always ask yourself this after you finish a book:&lt;/p&gt;

&lt;p&gt;“What’s the one thing I’m going to apply after reading this book?”&lt;/p&gt;

&lt;p&gt;You see, it’s about what you do with your knowledge, not about how much you have.&lt;/p&gt;

&lt;p&gt;Don’t read more. Read smarter.
Also, apply this strategy to everything you read. Even something little like this article.
So let’s do a little exercise to close this off:&lt;/p&gt;

&lt;p&gt;What’s the one thing you’re going to apply after reading this article?
Answer (and visualize) that, and I’ll bet you’ll retain more from this article than any other thing you’ve read today.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;带有目的的去读书，把自己当做老师&lt;/li&gt;
  &lt;li&gt;读书笔记，怎么样去做读书笔记，以自我为中心&lt;/li&gt;
  &lt;li&gt;视觉化知识，记录。功利化的读书，作用于自身&lt;/li&gt;
  &lt;li&gt;立刻的去实践，只存储在自己脑子里面的知识是没有用处的。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/01/readingbook/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/01/readingbook/</guid>
        
        
      </item>
    
      <item>
        <title>远程工作language的选择</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://blog.usejournal.com/what-technologies-to-learn-to-land-a-remote-job-in-2018-7dff03e17982&quot;&gt;文章地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What technologies to learn to land a remote job in 2018&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;At this point in my career, I’m quite invested in the whole remote working, digital nomad shtick. My family, friends, and even strangers online now recognize me as the “guy who works in his pajamas from home”. So, perhaps I’m the man for the job when it comes to recommending technologies that will help propel you into this lifestyle.
Note: I focus primarily on software development, so if you’re a videographer or something, this post won’t provide as much value.&lt;/p&gt;

&lt;p&gt;Before I just go off（进行） ranting about the technologies I believe will assist（帮助） you in getting a remote gig（演奏，临时工作）; there are a few attributes that may be beneficial, or in some cases required. For example, you’ll have a much better chance if you’re personable, have past experience working from home, or have existing clientele（委托人，顾客）. For now, though, let’s omit（to fail to include or do something） anything that falls under a similar category, I want to focus primarily on the tech.
Firstly, let’s focus on programming languages. I searched every popular language on several remote job sites that fit my criteria（a principle or standard by which something may be judged or decided.） (i.e. exclusively remote jobs to avoid on-site positions slipping through the cracks). One downside was most of these sites had 0 jobs available for certain languages. So, I resorted to StackOverflow for another metric, as it had remote jobs available for more obscure languages like Perl and R. StackOverflow jobs provided a solid baseline for remote jobs, and even did a superb job of filtering all on-site positions out.
The results
Obviously, these results are subject to change over the course of this year, so keep that in mind.&lt;/p&gt;

&lt;p&gt;Results for 8 commonly used programming languages
Personally, I didn’t find this very surprising. Javascript has been growing exponentially for the past few years with the emergence of node.js and various front-end frameworks. Java, on the other hand is a tad bit interesting, because nearly all the jobs are senior positions. Python had a healthy mixture of web, machine learning, and data science jobs. Ruby is a little misleading because ALL of the jobs involved Ruby on Rails — the web framework (more on frameworks later). C++ and Go were very close, but I’d be willing to bet Go overtakes the former shortly.
One thing to note regarding Javascript is the over abundance of frameworks that have been hitting the scene for the past few years. I mention React quite a bit in my articles surrounding the remote job landscape. (Mostly because I contribute my first remote job to my capabilities using the framework.) Job searchers should still be seeing a consistent flow of React positions popping up. At the time of writing it was ahead of the race in terms of front-end frameworks, with angular close behind, and vue quickly picking up steam. With the rise of React Native in the mobile space, experience working in React has become even more beneficial. Not surprisingly, express is still far ahead of the other backend frameworks.
I would like to take a minute to talk about Ruby in a little more detail. I wrote above about all the positions being Ruby on Rails (the popular web framework), but interestingly I also spotted a lot of senior-level positions for the language. I presume the age of the language and framework has something a lot to do with this. As the language becomes less popular — not saying it’s “dying” by any stretch — the roles become a tad more demanding; at least that’s what I’ve come to find. So if you’re new to web development I’d avoid putting your eggs in the Ruby basket as it would be difficult to land a junior-level role.
Another language to zoom in on would be PHP. Frameworks like Laravel and Symfony are all the buzz right now, but we can’t dismiss WordPress. Admittedly, I did less research into the 8th ranked language on the list, but I found a majority of the positions to be WordPress. Furthermore, positions such as these were quite a bit less technical. After reading the requirements for a few postings, it was clear that they fell more into the creative/design side of things — UI, UX, PSD-to-HTML, all were common themes.
I’ll wrap up with a few words from my personal experience working and researching in this field. If you consider yourself “language agnostic” or a “T-shaped developer” you’ll have a much better chance of landing a remote job. I would consider myself very focused on React development, but I try to stay up to date on other technologies. A lot of co-workers ask how I know so much about something like Django, but spend no professional time working with the framework. The answer is quite simple, I love python and web development so I spend a lot of time reading about Django and building side-projects with the technology. I also dip my feet into WordPress every now and then because of freelance work that comes my way. It’s easy to excel in one particular language and maintain competency in another if the other interests you. A friend of mine works all day with node.js, but seems to be a master of 4–6 other tech stacks. She’s developed small games, created several bots, even dipped into machine learning. It’s her passion.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So, my suggestion is to focus on a language that will bring you monetary and lifestyle results, but also pursue your passions and interests. I know it feels like you’re just wasting time if you play around with unpopular technologies, but you’re having fun, and that prevents burnout.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;996投入的是自己的passions and interests.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/15/remotework/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/15/remotework/</guid>
        
        
      </item>
    
      <item>
        <title>为什么RethinkDB失败了？</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.defmacro.org/2017/01/18/why-rethinkdb-failed.html&quot;&gt;文章地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In hindsight, two things went wrong – we picked a terrible market and optimized the product for the wrong metrics of goodness.Each mistake likely cut RethinkDB’s valuation by one to two orders of magnitude（数量级）. So if we got either of these right, RethinkDB would have been the size of MongoDB, and if we got both of them right, we eventually could have been the size of Red Hat[1].&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;两个原因：&lt;/p&gt;

&lt;p&gt;市场的选择：
		设想中的数据库市场非常的大，但是大家把你当做是开源软件。需求很大，但很多都是伪需求。伪需求的前提下面，真正的订单获取非常的困难。
		Developers love building developer tools, often for free. So while there is massive demand, the supply vastly outstrips it. This drives the number of alternatives up, and the prices down to zero.
For us, it meant an intractable customer acquisition funnel. This has disastrous domino effects. It demoralizes the team, and makes it very challenging to attract investment and hire top talent. In turn, that constrains your resources so you can’t make sufficient investment in product and distribution. Startups live and die by momentum, and early distribution challenges almost always doom you to eventual death.&lt;/p&gt;

&lt;p&gt;产品的方向：&lt;/p&gt;

&lt;p&gt;一开始的产品的方向: elegant, robust, and beautiful product&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Correctness. We made very strict guarantees, and fulfilled them religiously.&lt;/li&gt;
  &lt;li&gt;Simplicity of the interface. We took on most of the complexity in the implementation, so application developers wouldn’t have to.&lt;/li&gt;
  &lt;li&gt;Consistency. We made everything from the query language, to the client drivers, to cluster configuration, to documentation, to the marketing copy on the front page as consistent as possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其分析的正确的方向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Timely arrival. They wanted the product to actually exist when they needed it, not three years later.&lt;/li&gt;
  &lt;li&gt;Palpable speed. People wanted RethinkDB to be fast on workloads they actually tried, rather than “real world” workloads we suggested. For example, they’d write quick scripts to measure how long it takes to insert ten thousand documents without ever reading them back. MongoDB mastered these workloads brilliantly, while we fought the losing battle of educating the market.&lt;/li&gt;
  &lt;li&gt;A use case. We set out to build a good database system, but users wanted a good way to do X(e.g. a good way to store JSON documents from hapi, a good way to store and analyze logs, a good way to create reports, etc.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;合适的就是最好的，这个是完美的注解。&lt;/p&gt;

&lt;p&gt;By the time we felt RethinkDB satisfied our design goals and we were confident enough to recommend it to be used in production, almost everyone was asking “how is RethinkDB different from MongoDB?” We worked hard to explain why correctness, simplicity, and consistency are important, but ultimately these weren’t the metrics of goodness that mattered to most users.&lt;/p&gt;

&lt;p&gt;迭代解决了很多的问题，满足需求，满足当下的需求，满足当下的有效的需求。&lt;/p&gt;

&lt;p&gt;But over time I learned to appreciate the wisdom of the crowds. MongoDB turned regular developers into heroes when people needed it, not years after the fact. It made data storage fast, and let people ship products quickly. And over time, MongoDB grew up. One by one, they fixed the issues with the architecture, and now it is an excellent product. It may not be as beautiful as we would have wanted, but it does the job, and it does it well.&lt;/p&gt;

&lt;p&gt;一步错步步错，在原有的基础性上进行了错误的方向转变。
The obvious problem with a small database company building a cloud service is that it pattern matches to a common startup failure mode – splitting focus. &lt;/p&gt;

&lt;p&gt;规律就是规律，不会因为你的忽视就不存在。
Early RethinkDB was quite a bit like that. We had no intuition for products or markets, so we’d go through the motions of building a company without actually understanding what we were doing. What’s more, we had enormous optimism bias. Just like physicians know that gifts from pharmaceutical companies have biasing effects for other physicians but believe they are immune from the effect, we believed we were immune from the laws of economics and the math of running a business. The math, of course, eventually caught up with us.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/09/whymongoDBSuccess/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/09/whymongoDBSuccess/</guid>
        
        
      </item>
    
      <item>
        <title>redis梳理</title>
        <description>&lt;p&gt;redis主要操作的数据有五种，String，List，Map，Set，sort Set 简称为ZSet。这五类的操作的数据的底层
是如何运行的。
redis为什么这么快？
redis的集群的模式
redis的内存管理模式
redis的持久化操作等常见的问题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先我们发现问题，然后我们一个一个的回答，深入。&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/01/redis-data/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/01/redis-data/</guid>
        
        <category>redis</category>
        
        
      </item>
    
  </channel>
</rss>
