<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 22 Oct 2019 09:48:05 +0800</pubDate>
    <lastBuildDate>Tue, 22 Oct 2019 09:48:05 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>打乱数组，洗牌算法</title>
        <description>&lt;p&gt;题目描述：Shuffle a set of numbers without duplicates.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);&lt;/p&gt;

&lt;p&gt;// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();&lt;/p&gt;

&lt;p&gt;// Resets the array back to its original configuration [1,2,3].
solution.reset();&lt;/p&gt;

&lt;p&gt;// Returns the random shuffling of array [1,2,3].
solution.shuffle();&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/28/L384/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/28/L384/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>L378 有序矩阵中第K小的元素</title>
        <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.&lt;/p&gt;

&lt;p&gt;Note that it is the kth smallest element in the sorted order, not the kth distinct element.
&lt;!--more--&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;return 13.
Note:
You may assume k is always valid, 1 ≤ k ≤ n2.&lt;/p&gt;

&lt;p&gt;分析思路：&lt;/p&gt;

&lt;p&gt;有序的矩阵，查找第K个小的元素，这种问题归类到已有的查找问题，和上一种小白的问题不同，这类我们可以称之为有踪迹或者可以归类的问题，类似于已有问题的扩展。就称之为基础问题吧。&lt;/p&gt;

&lt;p&gt;这类我们需要一个对照的模型，这个题目那，就是二分查找。为什么是二分查找尼？因为和二分查找很类似，如果不是矩阵的模式，而是一个数组的样式，那么就二分查找的问题。&lt;/p&gt;

&lt;p&gt;然后我们就去分析这道题目为什么不能直接的使用二分查找，二分查找有一个中间值和中间值的索引：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;from  to  和 mid = from+ （to-from）/2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对应到这个题目就是：
&lt;code class=&quot;highlighter-rouge&quot;&gt;[0][0] 和 [n][n]  mid = [0+(n-0)/2][0+(n-0)/2]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;再然后就是判断第K的跳转，是 from 到 mid 还是 mid 到 from，这个就和第K小的判断有关了，需要判断 mid 在数组中是第几小，然后和K进行比较。&lt;/p&gt;

&lt;p&gt;具体的代码实现为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int kthSmallest(int[][] matrix,int k){
    int n = matrix.length;
    int from = matrix[0][0];int to = matrix[n-1][n-1];

    while(from &amp;lt; to){
        int mid = from + (to -from)/2;
        int count = 0;// 计算mid为第几小的临时变量
        int j = matrix[0].length-1;
        // 计算mid为第几小
        for(int i = 0;i &amp;lt; matrix.length;i++){
            while(j &amp;gt;0 &amp;amp;&amp;amp; matrix[i][j]&amp;gt;mid) j--;
            count += (j+1);
        }
        if(count &amp;lt;k ){
             from=mid+1;    
        }else{
            to = mid;
        }

    }
    return from;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再然后就是优化一部分的逻辑，或者说归纳统一的逻辑，例如确定mid是第几小，可以归纳为一个方法里面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int lo = matrix[0][0], hi = matrix[n-1][n-1];
        while(lo &amp;lt; hi){
            int mid = lo + (hi - lo) / 2;
            int count = countLessOrEquals(mid, matrix);
            if(count &amp;lt; k)
                lo = mid+1;
            else
                hi = mid;
        }
        return lo;
    }
    
    public int countLessOrEquals(int target, int[][] matrix){
        int i = matrix.length-1, j = 0;
        int count = 0;
        while(i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; matrix[0].length){
            if(target &amp;lt; matrix[i][j]){
                i--;
            }else{
                count += i+1;
                j++;
            }
        }
        return count;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 28 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/28/L378/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/28/L378/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>对Leetcode问题的思索</title>
        <description>&lt;p&gt;突然想起来LeetCode的每一道题，最终要的是对思维能力的锻炼，解决方案的提取，不能一味的去刷题，那样太没有趣味和底下了。&lt;/p&gt;

&lt;p&gt;问题的描述为：
Given a list of daily temperatures T, return a list such that, for each day in the input, 
 tells you how many days you would have to wait until a warmer temperature.
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  
 If there is no future day for which this is possible, put 0 instead.
For example, given the list of temperatures 
T = [73, 74, 75, 71, 69, 72, 76, 73], 
your output should be [1, 1, 4, 2, 1, 1, 0, 0].

Note: The length of temperatures will be in the range [1, 30000]. 
Each temperature will be an integer in the range [30, 100].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一步是弄懂具体的问题，输入是什么？输出什么？
第二步是确定输入和输出之间的关系，这一步是最关键的。
大概的逻辑关系，就是数据的怎么得到的逻辑关系，应该还是能够分析出来的。
第三步：按照梳理出来的逻辑关系，来映射成为代码,这一步是最难的，但是我们因为知道它最难，我们采用我们学过的东西，对它进行分解，分类，拆成小步，一点一点的来解决。&lt;/p&gt;

&lt;p&gt;我们就按照这个逻辑来分析，这个题目：&lt;/p&gt;

&lt;p&gt;首先是输入的数组：&lt;code class=&quot;highlighter-rouge&quot;&gt;[73, 74, 75, 71, 69, 72, 76, 73]&lt;/code&gt;
输出的数组是：&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 1, 4, 2, 1, 1, 0, 0]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后就是输入和输出之间的关系，此类题目的关系，可以直接的观察到，我们称之为：小白型（给不懂计算机的人员，讲解的时候，我能够比较轻松的说明这个输出数据的）：如果距离比今天温度还高的日子，还差几天。&lt;/p&gt;

&lt;p&gt;第三步，就是映射成代码，针对小白型的题目，映射为代码，只需要梳理她的逻辑即可。&lt;/p&gt;

&lt;p&gt;第3.1步：针对小白型的题目，关键在于梳理输出得到的过程。&lt;/p&gt;

&lt;p&gt;首先肯定的需要对输入的数据进行遍历，不然找不到当前值，后须值的比对机会。&lt;/p&gt;

&lt;p&gt;有了遍历的基本的框架，我们就有了当前值，当前值的索引，后须值，后须值的索引。如果后续的这个值大于当前值，那么结果值直接就能够得到，为1，如果后须值小于当前值，这个就需要临时的变量来进行存储，存储什么东西尼，这块可能就是算法的核心点了。&lt;/p&gt;

&lt;p&gt;第3.2步：针对算法的核心点，我们才用梳理一直的量，和未知的量来探索这个点&lt;/p&gt;

&lt;p&gt;当前值，当前值的索引，后须值，后须值的索引，我们只需要把那一小的值和索引存储起来，当遇到比当前值大的之后，再去更新即可。这个更新，就是找到了比当前值的索引减去 当前值的索引就好。或者没有找到比当前置大的值，但是已经遍历结束了，那么直接的设置为0即可。&lt;/p&gt;

&lt;p&gt;这样的话，我们的关键点就在于，当时数组处于下降趋势的时候，存储下降趋势的索引值。&lt;/p&gt;

&lt;p&gt;第3.3步：梳理整理的算法，合并可以合并标识的东西，我们如果声明一个临时的变量组，【当前值的索引，其实就是下标】，然后是结果值，我们就能够很大程度的优化代码的表述。我们需要保存下降趋势的下标，其实这是一个点，保存下标的方式有很多种，包括链表，数组，栈能够保存下标，但是哪一种合适尼？在分析下，我们使用这些下标干什么？在有大的值的时候，需要减去前面的下标，然后就没有用了，这个就有点栈的味道了，然后再把栈这个数据结构，套上去，看看能不能实现。&lt;/p&gt;

&lt;p&gt;其实应该有3.4步，伪代码实现，然后再去编程。&lt;/p&gt;

&lt;p&gt;栈实现的解决办法：&lt;/p&gt;

&lt;p&gt;public int[] dailyTemperatures(int[] temperatures) {
  Stack&lt;Integer&gt; stack = new Stack&amp;lt;&amp;gt;();
  int[] ret = new int[temperatures.length];
  for(int i = 0; i &amp;lt; temperatures.length; i++) {
      while(!stack.isEmpty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[stack.peek()]) {
          int idx = stack.pop();
          ret[idx] = i - idx;
      }
      stack.push(i);
  }
  return ret;
}&lt;/Integer&gt;&lt;/p&gt;

&lt;p&gt;实现了之后，还有3.5 步，去优化，去实验其他的想法。&lt;/p&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int[] dailyTemperatures(int[] temperatures) {
  int[] stack = new int[temperatures.length];
  int top = -1;
  int[] ret = new int[temperatures.length];
  for(int i = 0; i &amp;lt; temperatures.length; i++) {
      while(top &amp;gt; -1 &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[stack[top]]) {
          int idx = stack[top--];
          ret[idx] = i - idx;
      }
      stack[++top] = i;
  }
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 27 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/27/%E6%80%9D%E7%B4%A2%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/27/%E6%80%9D%E7%B4%A2%E9%97%AE%E9%A2%98/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:49. Group Anagrams</title>
        <description>&lt;p&gt;问题的描述为：
Given an array of strings, group anagrams together.
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;All inputs will be in lowercase.
The order of your output does not matter.&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关键在于，有相同字符确定的不同字符串怎么的确定？
如果把hashcode变成字母的和，是不是直接的判断hashcode的值就行了？

转念在一想不行，例如：duh, ill 值是相同的，
所以我们可以采用26个特殊的值，它们相加的时候，和自己的有关，
这个设计到质数的概念，计算出26个质数，这个比较的困难！

确定一中唯一的比对规则很重要。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
  if (strs == null || strs.length == 0) {
   return null;
  }

  Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; judge = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
  for (String key : strs) {
   char[] value = key.toCharArray();
   Arrays.sort(value);
   String tmp1 = new String(value);
   if (!judge.containsKey(tmp1)) judge.put(tmp1, new ArrayList&amp;lt;String&amp;gt;());
   judge.get(tmp1).add(key);
  }

  return new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(judge.values());

 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/26/leetcode49/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/26/leetcode49/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:48. Rotate Image</title>
        <description>&lt;p&gt;问题的描述为：
You are given an n x n 2D matrix representing an image.&lt;/p&gt;

&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 3     7 8 9     7 4 1
4 5 6  =&amp;gt; 4 5 6  =&amp;gt; 8 5 2
7 8 9     1 2 3     9 6 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void rotate(int[][] matrix) {
    int s = 0, e = matrix.length - 1;
    while(s &amp;lt; e){
        int[] temp = matrix[s];
        matrix[s] = matrix[e];
        matrix[e] = temp;
        s++; e--;
    }

    for(int i = 0; i &amp;lt; matrix.length; i++){
        for(int j = i+1; j &amp;lt; matrix[i].length; j++){
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/25/leetcode48/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/25/leetcode48/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：5.Atomic 原子类，LockSupport支持类</title>
        <description>&lt;p&gt;在并发的场景下，除了常常使用的锁之类外，还有一些并发底层的支持类，例如：Atomic原子类和LockSupport，还有一个就是时常能见到，但是总感觉名字怪怪的：Unsafe等。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先我们来看Atomic原子类，自己把它分为三类的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;基础类型：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference之类的。&lt;/li&gt;
  &lt;li&gt;数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray之类的。&lt;/li&gt;
  &lt;li&gt;成员变成之类的：AtomicIntegerFiledUpdate等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们先从基础类说明：AtomicBoolean有三个主要的成员变量：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
      try {
         valueOffset = unsafe.objectFieldOffset
            (AtomicBoolean.class.getDeclaredField(&quot;value&quot;));
      } catch (Exception ex) { throw new Error(ex); }
  }

private volatile int value;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要的方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean get() {
     return value != 0;
}

public final boolean compareAndSet(boolean expect, boolean update) {
    int e = expect ? 1 : 0;
    int u = update ? 1 : 0;
    return unsafe.compareAndSwapInt(this, valueOffset, e, u);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现的原理就是，通过Unsafe，拿到Volatile修饰的成员变量value的内存地址，然后通过Unsafe的
compareAndSet方法来设置value的值。&lt;/p&gt;

&lt;p&gt;其他的基础类，基本就是这种模式的实现。&lt;/p&gt;

&lt;p&gt;AtomicIntegerArray 的实现的源码，也是操作内存地址，但是因为是数组，所以有了些许的变化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AtomicIntegerArray：

private static final int base = unsafe.arrayBaseOffset(int[].class);
 private static final int shift;
 private final int[] array;

 static {
  int scale = unsafe.arrayIndexScale(int[].class);
  if ((scale &amp;amp; (scale - 1)) != 0)
   throw new Error(&quot;data type scale not a power of two&quot;);
  shift = 31 - Integer.numberOfLeadingZeros(scale);
 }

 private long checkedByteOffset(int i) {
  if (i &amp;lt; 0 || i &amp;gt;= array.length)
   throw new IndexOutOfBoundsException(&quot;index &quot; + i);

  return byteOffset(i);
 }

 private static long byteOffset(int i) {
  return ((long) i &amp;lt;&amp;lt; shift) + base;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们看一个具体的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean compareAndSet(int i, int expect, int update) {
  return compareAndSetRaw(checkedByteOffset(i), expect, update);
 }

 private boolean compareAndSetRaw(long offset, int expect, int update) {
  return unsafe.compareAndSwapInt(array, offset, expect, update);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;checkedByteOffset 就是根据i，确实能够&lt;code class=&quot;highlighter-rouge&quot;&gt;array[i]&lt;/code&gt; 对应的内存地址： &lt;code class=&quot;highlighter-rouge&quot;&gt;((long) i &amp;lt;&amp;lt; shift) + base&lt;/code&gt;
其中shift 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;31 - Integer.numberOfLeadingZeros(unsafe.arrayIndexScale(int[].class))&lt;/code&gt;
就看计算公式，就让我们想起来数组的基础地址 + i* 每一个元素所占的步长的算法。&lt;/p&gt;

&lt;p&gt;这也是其他的数组类原子类的基本操作了。&lt;/p&gt;

</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/24/concurrent-7/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/24/concurrent-7/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:42  container water</title>
        <description>&lt;p&gt;问题的描述为：
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!

Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：主要在于观察图形的规律，有两种情况，一中为凹，一种为凸 ，但是这样的判断代码写起来非常的复杂。可以换另外的一种思路，观察总体的情况。&lt;/p&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int trap(int[] height) {

  int n = height.length;

  int[] left = new int[n];
  int[] right = new int[n];

  int leftMax = Integer.MIN_VALUE;
  int rightMax = Integer.MIN_VALUE;
  // construct left max (including self) array
  for (int i = 0; i &amp;lt; n; i++) {
   if (height[i] &amp;gt; leftMax) {
    leftMax = height[i];
   }
   left[i] = leftMax;
  }

  // construct right max (including self) array 
  for (int i = n - 1; i &amp;gt;= 0; i--) {
   if (height[i] &amp;gt; rightMax) {
    rightMax = height[i];
   }
   right[i] = rightMax;
  }

  int water = 0;

  // water trapped  
  for (int i = 0; i &amp;lt; n; i++) {

   int min = Math.min(left[i], right[i]);

   water += (min - height[i]);
  }

  return water;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/24/leetcode42/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/24/leetcode42/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:41  firstMissingPositive</title>
        <description>&lt;p&gt;数组的下标是一种天然的资源，有序，有界。在某些特殊的问题下，可以做为一种辅助信息。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;问题的描述为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an unsorted integer array, find the smallest missing positive integer.
 Example 1:
 Input: [1,2,0]
 Output: 3
 Example 2:
 Input: [3,4,-1,1]
 Output: 2
 Example 3:
 Input: [7,8,9,11,12]
 Output: 1
 Note:
 Your algorithm should run in O(n) time and uses constant extra space.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Your algorithm should run in O(n) time and uses constant extra space.
这里面的uses constant extra space 和 O(n) 也算是一种提示吧。&lt;/p&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int firstMissingPositive_(int[] A) {
  int i = 0;
  while (i &amp;lt; A.length) {
   if (A[i] == i + 1 || A[i] &amp;lt;= 0 || A[i] &amp;gt; A.length)
    i++;
   else if (A[A[i] - 1] != A[i])
    swap(A, i, A[i] - 1);
   else
    i++;
  }
  i = 0;
  while (i &amp;lt; A.length &amp;amp;&amp;amp; A[i] == i + 1)
   i++;
  return i + 1;
 }

 private void swap(int[] A, int i, int j) {
  int temp = A[i];
  A[i] = A[j];
  A[j] = temp;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/24/leetcode41/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/24/leetcode41/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：4. 阻塞队列</title>
        <description>&lt;p&gt;阻塞队列的接口为： BlockingQueue&lt;E&gt; 这块是已经陌生但是以前比较梳理的内容，写出来在熟悉一下。&lt;/E&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;blockingqueue-的操作方法&quot;&gt;BlockingQueue 的操作方法&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/queue/q1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图中所示：
add(e),当队列满了以后，抛出IllegalStateException。
offer(e),当队列满了以后,返回false。
put(e),当队列满了以后,会被阻塞。
put(e,time,unit):false if the specified waiting time elapses before space is available&lt;/p&gt;

&lt;h3 id=&quot;blockingqueue常用的四个实现类&quot;&gt;BlockingQueue常用的四个实现类&lt;/h3&gt;

&lt;p&gt;ArrayBlockingQueue：规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的.&lt;/p&gt;

&lt;p&gt;LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的
BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的&lt;/p&gt;

&lt;p&gt;PriorityBlockingQueue：类似于LinkedBlockQueue,但其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序.&lt;/p&gt;

&lt;p&gt;SynchronousQueue：特殊的BlockingQueue,对其的操作必须是放和取交替完成的.&lt;/p&gt;

&lt;h3 id=&quot;arrayblockingqueue-主要实现的逻辑&quot;&gt;ArrayBlockingQueue&lt;E&gt; 主要实现的逻辑&lt;/E&gt;&lt;/h3&gt;

&lt;p&gt;我们还可以先回看一下ArrayQueue的实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 成员变量

private int capacity;
private T[] queue;
private int head;
private int tail;

// 有点意思的是构造函数 capacity+1 
public ArrayQueue(int capacity) {
    this.capacity = capacity + 1;
    this.queue = newArray(capacity + 1);
    this.head = 0;
    this.tail = 0;
}
// 添加方法，采用的是tail+1 取余capacity 的方法，这也就是构建capacity+1的原因
 public boolean add(T o) {
  queue[tail] = o;
  int newtail = (tail + 1) % capacity;
  if (newtail == head)
   throw new IndexOutOfBoundsException(&quot;Queue full&quot;);
  tail = newtail;
  return true; // we did add something
 }

//删除的方法，采用的是 head+1 取余capacity 的方法，都是+1取余的操作
public T remove(int i) {
  if (i != 0)
   throw new IllegalArgumentException(&quot;Can only remove head of queue&quot;);
  if (head == tail)
   throw new IndexOutOfBoundsException(&quot;Queue empty&quot;);
  T removed = queue[head];
  queue[head] = null;
  head = (head + 1) % capacity;
  return removed;
 }

 public T get(int i) {
  int size = size();
  if (i &amp;lt; 0 || i &amp;gt;= size) {
   final String msg = &quot;Index &quot; + i + &quot;, queue size &quot; + size;
   throw new IndexOutOfBoundsException(msg);
  }
  int index = (head + i) % capacity;
  return queue[index];
 }

// 判定大小的时候，采用的是tail-head 的方法
 public int size() {
  // Can't use % here because it's not mod: -3 % 2 is -1, not +1.
  int diff = tail - head;
  if (diff &amp;lt; 0)
   diff += capacity;
  return diff;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们再看BlockingQueue的方法的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // ArrayBlockingQueue 的成员变量：

 /** The queued items */
 final Object[] items;

 /** items index for next take, poll, peek or remove */
 int takeIndex;

 /** items index for next put, offer, or add */
 int putIndex;

 /** Number of elements in the queue */
 int count;

 /** Main lock guarding all access */
 final ReentrantLock lock;

 /** Condition for waiting takes */
 private final Condition notEmpty;

 /** Condition for waiting puts */
 private final Condition notFull;

 public ArrayBlockingQueue(int capacity, boolean fair) {
  if (capacity &amp;lt;= 0)
   throw new IllegalArgumentException();
  this.items = new Object[capacity];
  lock = new ReentrantLock(fair);
  notEmpty = lock.newCondition();
  notFull = lock.newCondition();
 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的方法的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean add(E e) {
  return super.add(e);
 }

/**
实现的方式：
public boolean add(E e) {
   if (offer(e))
        return true;
   else
       throw new IllegalStateException(&quot;Queue full&quot;);
} 
*/
 public boolean offer(E e) {
  checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
   if (count == items.length)
    return false;
   else {
    // 保证lock的前提下，调用这个方法
    // 保证了队列不满，如果满了，直接在try方法中就已经返回
    enqueue(e);
    return true;
   }
  } finally {
   lock.unlock();
  }
 }
 /**
  * ① 已经拥有锁的前提下调用
  * ② 满的时候，putIndex直接设置为0，从头开始（这里面的putIndex为0，标识已经满了）
  * */
 private void enqueue(E x) {
  final Object[] items = this.items;
  items[putIndex] = x;
  if (++putIndex == items.length)
   putIndex = 0;
  count++;
  notEmpty.signal();
 }
 
 public void put(E e) throws InterruptedException {
  checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
   while (count == items.length)
    notFull.await();
   enqueue(e);
  } finally {
   lock.unlock();
  }
 }
 
 //相对应的四个方法：remove() poll()
 public E remove() {
  E x = poll();
  if (x != null)
      return x;
  else
      throw new NoSuchElementException();
}
public E poll() {
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
   return (count == 0) ? null : dequeue();
  } finally {
   lock.unlock();
  }
 }
private E dequeue() {
 final Object[] items = this.items;
 @SuppressWarnings(&quot;unchecked&quot;)
 E x = (E) items[takeIndex];
 items[takeIndex] = null;
 if (++takeIndex == items.length)
  takeIndex = 0;
 count--;
 if (itrs != null)
  itrs.elementDequeued();
 notFull.signal();
 return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LinkedBlockingQueue 的实现的源码，对比ArrayBlockingQueue，实现的框架上面，基本相同。当时具体的数据处理是不一样的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public boolean add(E e) {
  addLast(e);
  return true;
 }

 public void addLast(E e) {
  if (!offerLast(e))
   throw new IllegalStateException(&quot;Deque full&quot;);
 }

 public boolean offerLast(E e) {
  if (e == null)
   throw new NullPointerException();
  Node&amp;lt;E&amp;gt; node = new Node&amp;lt;E&amp;gt;(e);
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
   return linkLast(node);
  } finally {
   lock.unlock();
  }
 }

 private boolean linkLast(Node&amp;lt;E&amp;gt; node) {
  // assert lock.isHeldByCurrentThread();
  if (count &amp;gt;= capacity)
   return false;

  Node&amp;lt;E&amp;gt; l = last;
  node.prev = l;
  last = node;
  if (first == null)
   first = node;
  else
   l.next = node;

  ++count;
  notEmpty.signal();
  return true;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里面中的信号，使用到了Condition，Condition的建立是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lock = new ReentrantLock(fair);
  notEmpty = lock.newCondition();
  notFull = lock.newCondition();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ReentrantLock 的 newCondition的方法是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ReentrantLock.newCondition() {
  return sync.newCondition();
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;还是原来的：Sync 实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final ConditionObject newCondition() {
   return new ConditionObject();
  }
返回的是AQS的一个内部类ConditionObject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ConditionObject 为AQS专门实现的一个类，具体我们只看两个关键的方法，在BlockingQueue中，使用的比较的多。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void await() throws InterruptedException {
   if (Thread.interrupted())
    throw new InterruptedException();
   Node node = addConditionWaiter();
   // ！！！当调用await的时候，就已经释放了拥有的锁！！
   int savedState = fullyRelease(node);
   int interruptMode = 0;
   while (!isOnSyncQueue(node)) {
    LockSupport.park(this);
    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
     break;
   }
   if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
    interruptMode = REINTERRUPT;
   if (node.nextWaiter != null) // clean up if cancelled
    unlinkCancelledWaiters();
   if (interruptMode != 0)
    reportInterruptAfterWait(interruptMode);
  }


  // 增加到等待的队列里面
  private Node addConditionWaiter() {
   Node t = lastWaiter;
   // If lastWaiter is cancelled, clean out.
   if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
    unlinkCancelledWaiters();
    t = lastWaiter;
   }
   Node node = new Node(Thread.currentThread(), Node.CONDITION);
   if (t == null)
    firstWaiter = node;
   else
    t.nextWaiter = node;
   lastWaiter = node;
   return node;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void signal() {
   if (!isHeldExclusively())
    throw new IllegalMonitorStateException();
   Node first = firstWaiter;
   if (first != null)
    doSignal(first);
  }
  
  private void doSignal(Node first) {
   do {
    if ((firstWaiter = first.nextWaiter) == null)
     lastWaiter = null;
    first.nextWaiter = null;
   } while (!transferForSignal(first) &amp;amp;&amp;amp; (first = firstWaiter) != null);
  }
  
  final boolean transferForSignal(Node node) {
   /*
    * If cannot change waitStatus, the node has been cancelled.
    */
   if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
    return false;

   /*
    * Splice onto queue and try to set waitStatus of predecessor to
    * indicate that thread is (probably) waiting. If cancelled or
    * attempt to set waitStatus fails, wake up to resync (in which
    * case the waitStatus can be transiently and harmlessly wrong).
    */
   Node p = enq(node);
   int ws = p.waitStatus;
   if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
    LockSupport.unpark(node.thread);
   return true;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/23/concurrent-6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/23/concurrent-6/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:39,40,78,90,46,47,131</title>
        <description>&lt;p&gt;LeetCode 39. Combination Sum&lt;/p&gt;

&lt;p&gt;回溯算法是通过一步一步（通常是用递归）构建可能”解”，
并且回溯不可能”解”来求所有或者部分解决方案的通用算法。
其中“回溯”的具体意思就是将不可能解或者部分解的候选尽早的舍弃掉，
“解”需要满足一定的限制条件（constraint satisfaction）&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;回溯算法一般的通解：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALGORITHM try(v1,...,vi)  // 这里的V1.....V2携带的参数说明 “可能解”  
   // 入口处验证是否是全局解，如果是，直接返回。 
   // 实际编程中也需要查看是否是无效解，如果是，也是直接返回
   IF (v1,...,vi) is a solution THEN RETURN (v1,...,vi)  
   FOR each v DO  // 对于每一个可能的解，进行查看
      // 下面的含义是形成一个可能解 进行递归
      IF (v1,...,vi,v) is acceptable vector  THEN 
        sol = try(v1,...,vi,v) 
        IF sol != () THEN RETURN sol 
        // 这个地方其实需要增加“回溯” 处理，实际编程中通常是函数参数的变化
      END 
   END 
   RETURN () 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;题目1：78. Subsets&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list , List&amp;lt;Integer&amp;gt; tempList, int [] nums, int start){
    list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    for(int i = start; i &amp;lt; nums.length; i++){
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果值：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Subsets II&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;描述：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of integers that might contain duplicates, nums, 
return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int start){
    list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    for(int i = start; i &amp;lt; nums.length; i++){
        if(i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; // skip duplicates
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Permutations
描述：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of distinct integers, 
return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
   List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
   // Arrays.sort(nums); // not necessary
   backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums);
   return list;
}


private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums){
   if(tempList.size() == nums.length){
      list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
   } else{
      for(int i = 0; i &amp;lt; nums.length; i++){ 
         if(tempList.contains(nums[i])) continue; // element already exists, skip
         tempList.add(nums[i]);
         backtrack(list, tempList, nums);
         tempList.remove(tempList.size() - 1);
      }
   }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Permutations II&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of numbers that might contain duplicates, 
return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, new boolean[nums.length]);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, boolean [] used){
    if(tempList.size() == nums.length){
        list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    } else{
        for(int i = 0; i &amp;lt; nums.length; i++){
            if(used[i] || i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] &amp;amp;&amp;amp; !used[i - 1]) continue;
            used[i] = true; 
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, used);
            used[i] = false; 
            tempList.remove(tempList.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;39  Combination Sum&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a set of candidate numbers (candidates) (without duplicates) and 
a target number (target), find all unique combinations in candidates where 
the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] nums, int target) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, target, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int remain, int start){
    if(remain &amp;lt; 0) return;
    else if(remain == 0) list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    else{ 
        for(int i = start; i &amp;lt; nums.length; i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements
            tempList.remove(tempList.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Combination Sum II&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] nums, int target) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, target, 0);
    return list;
    
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int remain, int start){
    if(remain &amp;lt; 0) return;
    else if(remain == 0) list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    else{
        for(int i = start; i &amp;lt; nums.length; i++){
            if(i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; // skip duplicates
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i + 1);
            tempList.remove(tempList.size() - 1); 
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Palindrome Partitioning&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: &quot;aab&quot;
Output:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
   List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
   backtrack(list, new ArrayList&amp;lt;&amp;gt;(), s, 0);
   return list;
}

public void backtrack(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list, List&amp;lt;String&amp;gt; tempList, String s, int start){
   if(start == s.length())
      list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
   else{
      for(int i = start; i &amp;lt; s.length(); i++){
         if(isPalindrome(s, start, i)){
            tempList.add(s.substring(start, i + 1));
            backtrack(list, tempList, s, i + 1);
            tempList.remove(tempList.size() - 1);
         }
      }
   }
}

public boolean isPalindrome(String s, int low, int high){
   while(low &amp;lt; high)
      if(s.charAt(low++) != s.charAt(high--)) return false;
   return true;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/23/leetcode39/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/23/leetcode39/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
  </channel>
</rss>
