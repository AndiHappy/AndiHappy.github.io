<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 08 Sep 2019 10:14:29 +0800</pubDate>
    <lastBuildDate>Sun, 08 Sep 2019 10:14:29 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>LeetCode25</title>
        <description>&lt;p&gt;LeetCode 25题的分析和总结：Reverse Nodes in k-Group&lt;/p&gt;

&lt;p&gt;递归&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 25. Reverse Nodes in k-Group&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

Example:

Given this linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5

For k = 2, you should return: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5

For k = 3, you should return: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5

Note:

Only constant extra memory is allowed.
You may not alter the values in the list's nodes, only nodes itself may be changed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;链表翻转的变形类题目,我们可以采用L24后面总结的基本的算法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static ListNode reverseKGroup(ListNode head, int k) {
		
		ListNode returnVal = null;
		ListNode prevToSet = null;
		int count = count(head);
		if (k &amp;gt; count) return head;

		ListNode result = head;
		while (result != null &amp;amp;&amp;amp; count &amp;gt;= k) {
			ListNode[] tmp = reverseKGroupHelper(result, k);
			result = tmp[1].next;
			count = count - k;
			if (prevToSet != null) {
				prevToSet.next = tmp[0];
				prevToSet = tmp[1];
			}

			if (returnVal == null) {
				returnVal = tmp[0];
				prevToSet = tmp[1];
			}
		}

		return returnVal;
	}



	/**
	 * @param head
	 * @param count
	 * @return
	 */
	private static int count(ListNode head) {
		int count = 0;
		ListNode result = head;
		while (result != null) {
			result = result.next;
			++count;
		}
		return count;
	}
	
	/**
	 * 一段的反转的过程，具体的逻辑可以描述为：把元素轮流的插入链表的头部
	 * */
	public static ListNode[] reverseKGroupHelper(ListNode head, int limitk) {
		ListNode pre = head;
		ListNode current = head;
		//当前元素的下一个元素
		ListNode next = null;
		int count = 1;
		while (current.next != null &amp;amp;&amp;amp; count &amp;lt; limitk) {
			//下一个元素
			next = current.next;
			//把当前元素的下一个元素指向下一个元素的next，相当于是跳过了next所指向的元素
			current.next = next.next;
			//然后把next指向的元素的下一个元素设置为前一个元素，完成把头元素的后面的元素挪到前面的位置
			next.next = pre;
			pre = next;
			++count;
		}
		return new ListNode[] { pre, current };
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode reverseKGroup_copy(ListNode head, int k) {
    int n = 0;
    for (ListNode i = head; i != null; n++, i = i.next);
    
    ListNode dmy = new ListNode(0);
    dmy.next = head;
    for(ListNode prev = dmy, tail = head; n &amp;gt;= k; n -= k) {
        for (int i = 1; i &amp;lt; k; i++) {
            ListNode next = tail.next.next;
            tail.next.next = prev.next;
            prev.next = tail.next;
            tail.next = next;
        }
        
        prev = tail;
        tail = tail.next;
    }
    return dmy.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode25/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode25/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode24</title>
        <description>&lt;p&gt;LeetCode 24题的分析和总结：Swap Nodes in Pairs&lt;/p&gt;

&lt;p&gt;递归&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 24. Swap Nodes in Pairs&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a linked list, 
swap every two adjacent nodes and 
return its head.

You may not modify the values in the list's nodes, 
only nodes itself may be changed.

 

Example:

Given 
1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 
you should return the list as 
2-&amp;gt;1-&amp;gt;4-&amp;gt;3.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;链表翻转的变形类题目
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    //替换两个节点的值
	public static ListNode swapPairs(ListNode head) {
		if (head == null|| head.next == null)
			return head;
		
		ListNode pre = new ListNode(0);
		ListNode tmp = null;
		ListNode currentPre = pre;
		
		
		
		while (head != null &amp;amp;&amp;amp; head.next != null) {
			//next 插入到 head 之前即可 
			tmp = head.next;
				
		    head.next = tmp.next;
				
			tmp.next = head;
			
			currentPre.next = tmp;
			
			if(pre.next == null) pre.next = tmp;
			currentPre = head;
			
			head = head.next;
			
		}
		return pre.next;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个翻转的套路需要背会了，这次是两个翻转，下次有可能是3个元素翻转，再下次有可能是从i到j的翻转。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /***
   * 此方法的内容是翻转从head开始，后面的K个元素，如果不足K个元素，则不翻转
   * @param head 开始的节点
   * @param k 后续翻转元素的个数
   * */
	public static ListNode swapPairs(ListNode head,int k) {
		ListNode returntmp = new ListNode(-1);
		returntmp.next = head;
		ListNode currentPre = returntmp;
		ListNode tmp = head;
		int i = 0;
		while(tmp.next != null) {
			i++;
			tmp = tmp.next;
		}
		
		if(i&amp;lt;k) return head;
		
		ListNode tmp2 = head;int j = 0;
		
		while(tmp2 != null &amp;amp;&amp;amp; tmp2.next != null &amp;amp;&amp;amp; j &amp;lt; k) {
			ListNode tmp3 = tmp2.next;
			tmp2.next = tmp3.next;
			tmp3.next = tmp2;
			currentPre.next = tmp3;
			tmp2= tmp2.next;
		}
		
		return returntmp.next;
		
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode24/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode24/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode23</title>
        <description>&lt;p&gt;LeetCode 23题的分析和总结：Merge k Sorted Lists&lt;/p&gt;

&lt;p&gt;LeetCode 21. Merge Two Sorted Lists ，从2到K的扩展，解法确大不一样了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 23. Merge k Sorted Lists&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们已经实现过了 Merge two Sorted Lists,使用的是while循环，直接的设置一个新的List。但是这个就有点力不从心了，因为这个K值的大小无法确定，而且寻找最小的当前节点也比较的费时。需要采用另外的策略。

利用已经有的Merge two Sorted Lists，直接的采用分治的策略，先两两合并，然后在同一的合并在一起。


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public static ListNode mergeKLists_best(ListNode[] lists){
    return partion(lists,0,lists.length-1);
}

public static ListNode partion(ListNode[] lists,int s,int e){
    if(s==e)  return lists[s];
    if(s&amp;lt;e){
        int q=s+(e-s)/2;
        ListNode l1=partion(lists,s,q);
        ListNode l2=partion(lists,q+1,e);
        return mergeTwoLists(l1,l2);
    }else
        return null;
}

public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	ListNode head = new ListNode(-1);
	ListNode tmp = head;
	while (l1 != null || l2 != null) {
		int l1v = l1 != null ? l1.val : Integer.MAX_VALUE;
		int l2v = l2 != null ? l2.val : Integer.MAX_VALUE;
		if (l1v &amp;lt; l2v) {
			tmp.next = new ListNode(l1v);
			l1 = l1.next;
		} else {
			tmp.next = new ListNode(l2v);
			l2 = l2.next;
		}
		tmp = tmp.next;
	}
	return head.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的mergeTwoLists，还可以再次的使用递归的算法合并：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//This function is from Merge Two Sorted Lists.
public static ListNode merge(ListNode l1,ListNode l2){
    if(l1==null) return l2;
    if(l2==null) return l1;
    if(l1.val&amp;lt;l2.val){
        l1.next=merge(l1.next,l2);
        return l1;
    }else{
        l2.next=merge(l1,l2.next);
        return l2;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode23/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode23/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode22</title>
        <description>&lt;p&gt;LeetCode 22题的分析和总结：22. Generate Parentheses&lt;/p&gt;

&lt;p&gt;递归&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 22. Generate Parentheses&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given n pairs of parentheses, 
write a function to generate 
all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一开始的思路是插入，寻找插入的位置：
|（|）|
|（|）|（|）|
后来代码累出来之后，错误百出。

然后还是根据规律来进行办事，参看讨论的迭代思路，真正的梳理了逻辑之后，发现解决方案，还是一如既往的好看，简练，直接。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; generateParenthesis(int n) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        backtrack(list, &quot;&quot;, 0, 0, n);
        return list;
    }
    
    public void backtrack(List&amp;lt;String&amp;gt; list, String str, int open, int close, int max){
        
        if(str.length() == max*2){
            list.add(str);
            return;
        }
        
        if(open &amp;lt; max)
            backtrack(list, str+&quot;(&quot;, open+1, close, max);
        if(close &amp;lt; open)
            backtrack(list, str+&quot;)&quot;, open, close+1, max);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;理解这个算法的一个样例：
(
((
(((
((()
((())
((()))
(()
(()(
(()()
(()())
(())
(())(
(())()
()
()(
()((
()(()
()(())
()()
()()(
()()()&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode22/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode22/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode21</title>
        <description>&lt;p&gt;LeetCode 21题的分析和总结：Merge Two Sorted Lists
链表的合并。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;LeetCode 21. Merge Two Sorted Lists&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Merge two sorted linked lists and
return it as a new list. 
The new list should be made 
by splicing together the nodes of 
the first two lists.

Example:

Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;合并单链表
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	ListNode head = new ListNode(-1);
	ListNode tmp = head;
	while (l1 != null || l2 != null) {
		int l1v = l1 != null ? l1.val : Integer.MAX_VALUE;
		int l2v = l2 != null ? l2.val : Integer.MAX_VALUE;
		if (l1v &amp;lt; l2v) {
			tmp.next = new ListNode(l1v);
			l1 = l1.next;
		} else {
			tmp.next = new ListNode(l2v);
			l2 = l2.next;
		}
		tmp = tmp.next;
	}
	return head.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode21/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode21/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>JDK7的新特性1 ForkJoinPool</title>
        <description>&lt;p&gt;JDK7的一个新特性：ForkJoinPool 很值得一说。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;ForkJoinPool，首先上代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//计算 π 的值有一个通过多项式方法，即：π = 4 * (1 - 1/3 + 1/5 - 1/7 + 1/9 - ……)，而且多项式的项数越多，计算出的 π 的值越精确
	static class PiEstimateTask extends RecursiveTask&amp;lt;Double&amp;gt; {
		private static final long serialVersionUID = 1L;
		private final long begin;
    private final long end;
    private final long threshold; // 分割任务的临界值

    public PiEstimateTask(long begin, long end, long threshold) {
        this.begin = begin;
        this.end = end;
        this.threshold = threshold;
    }

    @Override
    protected Double compute() {  // 实现 compute 方法
        if (end - begin &amp;lt;= threshold) {  // 临界值之下，不再分割，直接计算

            int sign; // 符号，多项式中偶数位取 1，奇数位取 -1（位置从 0 开始）
            double result = 0.0;
            for (long i = begin; i &amp;lt; end; i++) {
                sign = (i &amp;amp; 1) == 0 ? 1 : -1;
                result += sign / (i * 2.0 + 1);
            }
            System.out.println(Thread.currentThread()+ &quot; From: &quot;+ begin + &quot; End: &quot;+ end);
            return result * 4;
        }

        // 分割任务
        long middle = (begin + end) / 2;
        PiEstimateTask leftTask = new PiEstimateTask(begin, middle, threshold);
        PiEstimateTask rightTask = new PiEstimateTask(middle, end, threshold);

        leftTask.fork();  // 异步执行 leftTask
        rightTask.fork(); // 异步执行 rightTask

        double leftResult = leftTask.join();   // 阻塞，直到 leftTask 执行完毕返回结果
        double rightResult = rightTask.join(); // 阻塞，直到 rightTask 执行完毕返回结果

        return leftResult + rightResult; // 合并结果
    }

}
	
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ForkJoinPool pool = new ForkJoinPool();
		pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
		PiEstimateTask task = new PiEstimateTask(0, 1_000_000_000, 10_000_00);
		pool.execute(task);
		System.out.println(task.get());
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面的代码中，我们可以看到ForkJoinPool，适用的一类业务：
把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。&lt;/p&gt;

&lt;p&gt;ForkJoinPool支持的任务大类有两种，一类是：Runnable ，类似于ExecutorService。一类是ForkJoinTask。&lt;/p&gt;

&lt;p&gt;其中的ForkJoinTask代表一个可以并行、合并的任务。ForkJoinTask是一个抽象类，它还有两个抽象子类：RecusiveAction和RecusiveTask。其中RecusiveTask代表有返回值的任务，而RecusiveAction代表没有返回值的任务。&lt;/p&gt;

&lt;h3 id=&quot;代码分析&quot;&gt;代码分析&lt;/h3&gt;

&lt;p&gt;根据上面的示例代码，可以看出 fork() 和 join() 是 Fork/Join Framework “魔法”的关键。我们可以根据函数名假设一下 fork() 和 join() 的作用：&lt;/p&gt;

&lt;p&gt;fork()：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。
join()：等待该任务的处理线程处理完毕，获得返回值。&lt;/p&gt;

&lt;p&gt;并不是每个 fork() 都会促成一个新线程被创建，而每个 join() 也不是一定会造成线程被阻塞。&lt;/p&gt;

&lt;p&gt;具体的数据结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://7cn0ma.ch.files.1drv.com/y4mNHOHsW33XQdE-_tAVdUXXxwQ_eW58g3q3bzMm1EyjfJdSLcqE_9iW-a-1xdrlxMpChFZauhFFLvOzHja9ZJvzkdNTjnOnaB1lGCace0GRpTQXS-eh0rGn02i6mjSw1o4aSEILUwDCP4AJF_yDvxE8QuQ_4wZl9jkH7OmCBTMsJpgKFCz_p45Mj6O9l3cgQWZS0_FjaxTwKfLYIIrt5sVzg?width=1848&amp;amp;height=1505&amp;amp;cropmode=none&quot; alt=&quot;数据结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fork/Join Framework 的实现算法并不是那么“显然”，而是一个更加复杂的算法——这个算法的名字就叫做 work stealing 算法。&lt;/p&gt;

&lt;p&gt;ForkJoinPool 的&lt;strong&gt;每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。&lt;/p&gt;

&lt;p&gt;每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。
在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。&lt;/p&gt;

&lt;p&gt;在既没有自己的任务，也没有可以窃取的任务时，进入休眠。&lt;/p&gt;

&lt;h3 id=&quot;fork-&quot;&gt;fork() ：&lt;/h3&gt;

&lt;p&gt;做的工作只有一件事，既是把任务推入当前工作线程的工作队列里。&lt;/p&gt;
&lt;h3 id=&quot;join-&quot;&gt;join() ：&lt;/h3&gt;

&lt;p&gt;工作则复杂得多，也是 join() 可以使得线程免于被阻塞的原因——不像同名的 Thread.join()。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查调用 join() 的线程是否是 ForkJoinThread 线程。如果不是（例如 main 线程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。&lt;/li&gt;
  &lt;li&gt;查看任务的完成状态，如果已经完成，直接返回结果。&lt;/li&gt;
  &lt;li&gt;如果任务尚未完成，但处于自己的工作队列内，则完成它。&lt;/li&gt;
  &lt;li&gt;如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务（以 FIFO 方式），执行，以期帮助它早日完成欲 join 的任务。&lt;/li&gt;
  &lt;li&gt;如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务时，则找到小偷的小偷，帮助它完成它的任务。
递归地执行第5步。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所谓work-stealing模式，即每个工作线程都会有自己的任务队列。当工作线程完成了自己所有的工作后，就会去“偷”别的工作线程的任务。&lt;/p&gt;

&lt;p&gt;假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以&lt;strong&gt;为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;submit&quot;&gt;submit():&lt;/h3&gt;

&lt;p&gt;其实除了前面介绍过的每个工作线程自己拥有的工作队列以外，ForkJoinPool 自身也拥有工作队列，这些工作队列的作用是用来接收由外部线程（非 ForkJoinThread 线程）提交过来的任务，而这些工作队列被称为 submitting queue 。&lt;/p&gt;

&lt;p&gt;submit() 和 fork() 其实没有本质区别，只是提交对象变成了 submitting queue 而已（还有一些同步，初始化的操作）。submitting queue 和其他 work queue 一样，是工作线程”窃取“的对象，因此当其中的任务被一个工作线程成功窃取时，就意味着提交的任务真正开始进入执行阶段。&lt;/p&gt;

&lt;p&gt;更加详细的研究：http://gee.cs.oswego.edu/dl/papers/fj.pdf&lt;/p&gt;

&lt;h3 id=&quot;forkjoinpool与threadpoolexecutor区别&quot;&gt;ForkJoinPool与ThreadPoolExecutor区别：&lt;/h3&gt;

&lt;p&gt;1.ForkJoinPool中的每个线程都会有一个队列，而ThreadPoolExecutor只有一个队列，并根据queue类型不同，细分出各种线程池&lt;/p&gt;

&lt;p&gt;2.ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务,ThreadPoolExecutor中根本没有什么父子关系任务&lt;/p&gt;

&lt;p&gt;3.ForkJoinPool在使用过程中，会创建大量的子任务，会进行大量的gc，但是ThreadPoolExecutor不需要，因此单线程（或者任务分配平均）&lt;/p&gt;

&lt;p&gt;4.ForkJoinPool在多任务，且任务分配不均是有优势，但是在单线程或者任务分配均匀的情况下，效率没有ThreadPoolExecutor高，毕竟要进行大量gc子任务&lt;/p&gt;

&lt;p&gt;ForkJoinPool在多线程情况下，能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。&lt;/p&gt;

&lt;p&gt;ThreadPoolExecutor因为它其中的线程并不会关注每个任务之间任务量的差异。当执行任务量最小的任务的线程执行完毕后，它就会处于空闲的状态(Idle)，等待任务量最大的任务执行完毕。&lt;/p&gt;

&lt;p&gt;因此多任务在多线程中分配不均时，ForkJoinPool效率高。&lt;/p&gt;

&lt;h3 id=&quot;stream中应用forkjoinpool&quot;&gt;stream中应用ForkJoinPool&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;)
                .parallelStream()
                .filter(s -&amp;gt; {
                    System.out.format(&quot;filter: %s [%s]\n&quot;,
                            s, Thread.currentThread().getName());
                    return true;
                })
                .map(s -&amp;gt; {
                    System.out.format(&quot;map: %s [%s]\n&quot;,
                            s, Thread.currentThread().getName());
                    return s.toUpperCase();
                })
                .sorted((s1, s2) -&amp;gt; {
                    System.out.format(&quot;sort: %s &amp;lt;&amp;gt; %s [%s]\n&quot;,
                            s1, s2, Thread.currentThread().getName());
                    return s1.compareTo(s2);
                })
                .forEach(s -&amp;gt; System.out.format(&quot;forEach: %s [%s]\n&quot;,
                        s, Thread.currentThread().getName()));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;parallelStream让部分Java代码自动地以并行的方式执行&lt;/p&gt;

&lt;p&gt;最后：&lt;/p&gt;

&lt;p&gt;有一点要注意，就是手动设置ForkJoinPool的线程数量时，实际线程数为设置的线程数+1，因为还有一个main主线程&lt;/p&gt;

&lt;p&gt;即使将ForkJoinPool的通用线程池的线程数量设置为1，实际上也会有2个工作线程。因此线程数为1的ForkJoinPool通用线程池和线程数为2的ThreadPoolExecutor是等价的。&lt;/p&gt;

&lt;p&gt;与ForkJoinPool对应的是CompletableFuture&lt;/p&gt;

&lt;p&gt;Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。
阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果&lt;/p&gt;

&lt;p&gt;CompletableFuture就是利用观察者设计模式当计算结果完成及时通知监听者
在Java 8中, 新增加了一个包含50个方法左右的类: CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/15/day5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/15/day5/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>LeetCode18, 19，20</title>
        <description>&lt;p&gt;LeetCode 第18，19，20题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 18. 4Sum&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:

Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3Sum 变形题目，同一个思路
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) {
      List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
    List&amp;lt;Integer&amp;gt; l;
    Arrays.sort(nums);
    int len = nums.length;
    for (int i = 0; i &amp;lt; len - 3; i++) {
      // 相同直接返回
      if (i != 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue;
      // 最小值如果大于target，直接的返回
      if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &amp;gt; target) break;
      // 此值和最大的三个值相加，小于target 直接的返回
      if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 2] &amp;lt; target) continue;

      for (int j = i + 1; j &amp;lt; len - 2; j++) {
        // 相同直接返回
        if (j != i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue;
        // 最小值如果大于target，直接的返回
        if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &amp;gt; target) break;
        // 此值和最大的三个值相加，小于target 直接的返回
        if (nums[i] + nums[j] + nums[len - 1] + nums[len - 2] &amp;lt; target) continue;

        int head = j + 1, end = len - 1;
        while (head &amp;lt; end) {
          int tempt = nums[i] + nums[j] + nums[head] + nums[end];
          if (tempt == target) {
            l = new ArrayList&amp;lt;Integer&amp;gt;();
            l.add(nums[i]);
            l.add(nums[j]);
            l.add(nums[head]);
            l.add(nums[end]);
            list.add(l);
            head++;
			end--;
            while (head &amp;lt; end &amp;amp;&amp;amp; nums[head] == nums[head - 1]) {
              head++;
            }
			while (head &amp;lt; end &amp;amp;&amp;amp; nums[end] == nums[end+1]) {
              end--;
            }
          } else if (tempt &amp;gt; target)
            end--;
          else
            head++;
        }
      }
    }
    return list; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode 19. Remove Nth Node From End of List&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.

After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;简单题目，注意链表的表头的处理，下标的处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode removeNthFromEnd_copy(ListNode head, int n) {
	ListNode tmp = new ListNode(-1);
	ListNode first = tmp;ListNode second = tmp;
	tmp.next = head;
	for(int i = 1 ; i&amp;lt;=n+1;i++) {
		first = first.next;
	}
	while(first != null) {
		first = first.next;
		second = second.next;
	}
		
	second.next = second.next.next;
		
	return tmp.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode 20. Valid Parentheses&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing just the characters 
'(', ')', '{', '}', '[' and ']', 
determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: &quot;()&quot;
Output: true
Example 2:

Input: &quot;()[]{}&quot;
Output: true
Example 3:

Input: &quot;(]&quot;
Output: false
Example 4:

Input: &quot;([)]&quot;
Output: false
Example 5:

Input: &quot;{[]}&quot;
Output: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;典型的栈的应用，但是有两种不同的思路。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//正常的思路
public boolean isValid(String s) {
	if(s == null || s.length() &amp;lt;= 0){
   		return true;
   	}
   	Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;Character&amp;gt;();
   	for (int i = 0; i &amp;lt; s.length(); i++) {
   		char cha = s.charAt(i);
		switch (cha) {
		case '(':
		case '{':
		case '[':
			stack.push(cha);
			break;
		case ')':
			if(stack.isEmpty() || stack.pop() != '(' ){
				return false;
			}
			break;
		case '}':
			if(stack.isEmpty() || stack.pop()!= '{' ){
				return false;
			}
			break;
		case ']':
			if(stack.isEmpty() || stack.pop() != '[' ){
			return false;
			}
			break;
		default:
			break;
		}
	}
   	return stack.isEmpty();
}

//匹配的思路

public boolean isValid(String s) {
	Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;Character&amp;gt;();
	for (char c : s.toCharArray()) {
		if (c == '(')
			stack.push(')');
		else if (c == '{')
			stack.push('}');
		else if (c == '[')
			stack.push(']');
		else if (stack.isEmpty() || stack.pop() != c)
			return false;
	}
	return stack.isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/14/day4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/14/day4/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode16，17</title>
        <description>&lt;p&gt;LeetCode 第16，17题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 16. 3Sum Closest&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3Sum 变形题目，使用绝对值表示离目标值的远和近
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int threeSumClosest_copy(int[] num,int target) {
	int result = num[0]+num[1]+num[num.length-1];
	Arrays.parallelSort(num);
	int small = num[0]+num[1]+num[2];
	if(small &amp;gt;= target) return small;
	int big = num[num.length-3]+num[num.length-2]+num[num.length-1];
	if(big &amp;lt;= target) return big;

	for (int i = 0; i &amp;lt; num.length - 2; i++) {
    int start = i + 1, end = num.length - 1;
    while (start &amp;lt; end) {
        int sum = num[i] + num[start] + num[end];
        if (sum &amp;gt; target) {
            end--;
        } else {
            start++;
        }
        if (Math.abs(sum - target) &amp;lt; Math.abs(result - target)) {
            result = sum;
        }
    }
 }
 return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode 17. Letter Combinations of a Phone Number&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing digits from 2-9 inclusive,
return all possible letter combinations
that the number could represent.

A mapping of digit to letters
(just like on the telephone buttons)
is given below.
 Note that 1 does not map to any letters.

Example:

Input: &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;,
&quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;集合和排序的变种
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; letterCombinations(String digits) {
	LinkedList&amp;lt;String&amp;gt; ans = new LinkedList&amp;lt;String&amp;gt;();
	if(digits.isEmpty()) return ans;
	String[] mapping = new String[] {&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
	ans.add(&quot;&quot;);
	for(int i =0; i&amp;lt;digits.length();i++){
		int x = Character.getNumericValue(digits.charAt(i));
		while(ans.peek().length()==i){
			String t = ans.remove();
			for(char s : mapping[x].toCharArray())
				ans.add(t+s);
		}
	}
	return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里使用了迭代的思路，但是用的非常的优雅，首先是遍历给出的digits每一位的数字，
然后利用队列或者栈的先进先出的原则，循环的遍历已经组合完成的数组，添加上后来的数据，比较的巧妙和优雅。&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day4/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode14,15</title>
        <description>&lt;p&gt;LeetCode 第14,15题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 14. Longest Common Prefix&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string &quot;&quot;.

Example 1:

Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
Example 2:

Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
Note:

All given inputs are in lowercase letters a-z.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;遍历寻找即可
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public String longestCommonPrefix_copy(String[] strs) {
  if(strs == null || strs.length == 0) return &quot;&quot;;
  if(strs.length == 1) return strs[0];
  int from = 0;boolean flag = true;
  int end = strs[0].length();
  String tmp = strs[0];
  for(;from &amp;lt; end &amp;amp;&amp;amp; flag;from++) {
    for(int j = 1;j&amp;lt;strs.length;j++) {
      if(from &amp;gt;= strs[j].length() || strs[j].charAt(from) != tmp.charAt(from)) {
        flag=false;
        from = from-1;
        break;
      }
    }
  }

  return tmp.substring(0, from);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode:15. 3Sum&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先是排序，拍好了续，才能够使用“双指针的方法”，最后注意相等的值的处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/***
 * 关键在于nums的先排序
 * 然后两头堵的方式，from =0，end = length-1 ， 中间的sum = sumvalue- (from+end)
 * 循环的条件是先确定匹配值i（0 到 length-1），然后去（i+1，i+2，。。。length-1 中寻找from 和 end）
 */
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {
	List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
	Arrays.sort(nums);
	for (int i = 0; i &amp;lt; nums.length - 2; i++) {
		if (i == 0 || (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] != nums[i - 1])) {
			int from = i + 1;
			int end = nums.length - 1;
			int sumt = 0 - nums[i];
			while (from &amp;lt; end) {
				int temp = nums[from] + nums[end];
				if (sumt == temp) {
					res.add(Arrays.asList(nums[i], nums[from], nums[end]));

					while (from &amp;lt; end &amp;amp;&amp;amp; from + 1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[from] == nums[from + 1])
						from++;
					while (from &amp;lt; end &amp;amp;&amp;amp; end + 1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[end] == nums[end + 1])
						end--;

					from++;
					end--;
				} else if (sumt &amp;lt; temp) {
					end--;
				} else {
					from++;
				}
			}
	}
}
	return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day3/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode12,13</title>
        <description>&lt;p&gt;LeetCode 第12,13题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;第12题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: &quot;III&quot;
Example 2:

Input: 4
Output: &quot;IV&quot;
Example 3:

Input: 9
Output: &quot;IX&quot;
Example 4:

Input: 58
Output: &quot;LVIII&quot;
Explanation: L = 50, V = 5, III = 3.
Example 5:

Input: 1994
Output: &quot;MCMXCIV&quot;
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;阿拉伯数字到古罗马数字的转化，最关键的是确定数字的范围，但是这里有一个小技巧，如果是100，那么M的值为0个，应该怎么在代码中优雅的表述尼？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static String intToRoman(int num) {  

        //1000-3000
        String M[] = {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};
        //100-900
        String C[] = {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};
        //10-90
        String X[] = {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
        //0-9
        String I[] = {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
        // is so beautiful
        return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第13题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: &quot;III&quot;
Output: 3
Example 2:

Input: &quot;IV&quot;
Output: 4
Example 3:

Input: &quot;IX&quot;
Output: 9
Example 4:

Input: &quot;LVIII&quot;
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 5:

Input: &quot;MCMXCIV&quot;
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;古罗马数字到的阿拉伯数字转化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int romanToInt(String s) {

  if(s == null || s.length() == 0) return 0;
	int len = s.length();
	HashMap&amp;lt;Character,Integer&amp;gt; map = new HashMap&amp;lt;Character,Integer&amp;gt;();
	 map.put('I',1);
	 map.put('V',5);
	 map.put('X',10);
	 map.put('L',50);
	 map.put('C',100);
	 map.put('D',500);
	 map.put('M',1000);

	 int result = map.get(s.charAt(len -1));
	 int pivot = result;
	 for(int i = len -2; i&amp;gt;= 0;i--){
			 int curr = map.get(s.charAt(i));
			 if(curr &amp;gt;=  pivot){
			      result += curr;
			 }else{
			       result -= curr;
			 }
	 		 pivot = curr;
	 }
	return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
  </channel>
</rss>
