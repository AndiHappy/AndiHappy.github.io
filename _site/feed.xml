<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 16 Sep 2019 10:10:18 +0800</pubDate>
    <lastBuildDate>Mon, 16 Sep 2019 10:10:18 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Leetcode:39,40,78,90,46,47,131</title>
        <description>&lt;p&gt;LeetCode 39. Combination Sum&lt;/p&gt;

&lt;p&gt;回溯算法是通过一步一步（通常是用递归）构建可能”解”，
并且回溯不可能”解”来求所有或者部分解决方案的通用算法。
其中“回溯”的具体意思就是将不可能解或者部分解的候选尽早的舍弃掉，
“解”需要满足一定的限制条件（constraint satisfaction）&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;回溯算法一般的通解：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALGORITHM try(v1,...,vi)  // 这里的V1.....V2携带的参数说明 “可能解”  
   // 入口处验证是否是全局解，如果是，直接返回。 
   // 实际编程中也需要查看是否是无效解，如果是，也是直接返回
   IF (v1,...,vi) is a solution THEN RETURN (v1,...,vi)  
   FOR each v DO  // 对于每一个可能的解，进行查看
      // 下面的含义是形成一个可能解 进行递归
      IF (v1,...,vi,v) is acceptable vector  THEN 
        sol = try(v1,...,vi,v) 
        IF sol != () THEN RETURN sol 
        // 这个地方其实需要增加“回溯” 处理，实际编程中通常是函数参数的变化
      END 
   END 
   RETURN () 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;题目1：78. Subsets&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list , List&amp;lt;Integer&amp;gt; tempList, int [] nums, int start){
    list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    for(int i = start; i &amp;lt; nums.length; i++){
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果值：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Subsets II&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;描述：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of integers that might contain duplicates, nums, 
return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int start){
    list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    for(int i = start; i &amp;lt; nums.length; i++){
        if(i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; // skip duplicates
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Permutations
描述：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of distinct integers, 
return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
   List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
   // Arrays.sort(nums); // not necessary
   backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums);
   return list;
}


private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums){
   if(tempList.size() == nums.length){
      list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
   } else{
      for(int i = 0; i &amp;lt; nums.length; i++){ 
         if(tempList.contains(nums[i])) continue; // element already exists, skip
         tempList.add(nums[i]);
         backtrack(list, tempList, nums);
         tempList.remove(tempList.size() - 1);
      }
   }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Permutations II&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of numbers that might contain duplicates, 
return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, new boolean[nums.length]);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, boolean [] used){
    if(tempList.size() == nums.length){
        list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    } else{
        for(int i = 0; i &amp;lt; nums.length; i++){
            if(used[i] || i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] &amp;amp;&amp;amp; !used[i - 1]) continue;
            used[i] = true; 
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, used);
            used[i] = false; 
            tempList.remove(tempList.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;39  Combination Sum&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a set of candidate numbers (candidates) (without duplicates) and 
a target number (target), find all unique combinations in candidates where 
the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] nums, int target) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, target, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int remain, int start){
    if(remain &amp;lt; 0) return;
    else if(remain == 0) list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    else{ 
        for(int i = start; i &amp;lt; nums.length; i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements
            tempList.remove(tempList.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Combination Sum II&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] nums, int target) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, target, 0);
    return list;
    
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int remain, int start){
    if(remain &amp;lt; 0) return;
    else if(remain == 0) list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    else{
        for(int i = start; i &amp;lt; nums.length; i++){
            if(i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; // skip duplicates
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i + 1);
            tempList.remove(tempList.size() - 1); 
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Palindrome Partitioning&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: &quot;aab&quot;
Output:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
   List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
   backtrack(list, new ArrayList&amp;lt;&amp;gt;(), s, 0);
   return list;
}

public void backtrack(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list, List&amp;lt;String&amp;gt; tempList, String s, int start){
   if(start == s.length())
      list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
   else{
      for(int i = start; i &amp;lt; s.length(); i++){
         if(isPalindrome(s, start, i)){
            tempList.add(s.substring(start, i + 1));
            backtrack(list, tempList, s, i + 1);
            tempList.remove(tempList.size() - 1);
         }
      }
   }
}

public boolean isPalindrome(String s, int low, int high){
   while(low &amp;lt; high)
      if(s.charAt(low++) != s.charAt(high--)) return false;
   return true;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/23/leetcode39/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/23/leetcode39/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：4. 读写锁等其他的类型的锁的支持</title>
        <description>&lt;p&gt;ReentrantReadWriteLock 是在重入锁的基础上，添加读写的控制。主要是关注Condition的运用，底层的实现，更加清楚的明白重入锁的控制。&lt;/p&gt;

&lt;!--more--&gt;

</description>
        <pubDate>Thu, 22 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/22/concurrent-5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/22/concurrent-5/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 34.Find First and Last Position of Element in Sorted Array </title>
        <description>&lt;p&gt;LeetCode 34. Find First and Last Position of Element in Sorted Array&lt;/p&gt;

&lt;p&gt;如果使用O(n)的遍历，根本就不会有什么难度了，但是题目中已经明确的标注了：Sorted Array，那么就不行了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;那就使用二分查找出第一个值，最后一个值。原本的思路。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：首先是按照思路来的，一种类似作弊的思路，前后加减0.5&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int[] searchRange(int[] nums, int target) {
        double left = target - 0.5, right = target + 0.5;
        int l = bs(nums, left), r = bs(nums, right);
        if(l == r) return new int[]{-1, -1};
        return new int[]{l, r-1};
}
    
public int bs(int[] nums, double target) {
        int l = 0, h = nums.length-1;
        while(l &amp;lt;= h){
            int m = l + (h - l)/2;
            if(target &amp;gt; nums[m]) l = m+1;
            else h = m-1;
        }
        return l;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正规的思路分析：&lt;/p&gt;

&lt;p&gt;The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:&lt;/p&gt;

&lt;p&gt;First let’s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:&lt;/p&gt;

&lt;p&gt;If A[mid] &amp;lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration)
If A[mid] &amp;gt; target, it means the range must begins on the left of mid (j = mid-1)
If A[mid] = target, then the range must begins on the left of or at mid (j= mid)
Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:&lt;/p&gt;

&lt;p&gt;2*. If A[mid] &amp;gt;= target, j = mid;&lt;/p&gt;

&lt;p&gt;Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &amp;lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why?&lt;/p&gt;

&lt;p&gt;No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:&lt;/p&gt;

&lt;p&gt;case 1: [5 7] (A[i] = target &amp;lt; A[j])
case 2: [5 3] (A[i] = target &amp;gt; A[j])
case 3: [5 5] (A[i] = target = A[j])
case 4: [3 5] (A[j] = target &amp;gt; A[i])
case 5: [3 7] (A[i] &amp;lt; target &amp;lt; A[j])
case 6: [3 4] (A[i] &amp;lt; A[j] &amp;lt; target)
case 7: [6 7] (target &amp;lt; A[i] &amp;lt; A[j])
For case 1, 2 and 3, if we follow the above rule, since mid = i =&amp;gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.&lt;/p&gt;

&lt;p&gt;For case 4, since A[mid] &amp;lt; target, then set i = mid+1. The loop terminates and both i and j point to 5.&lt;/p&gt;

&lt;p&gt;For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.&lt;/p&gt;

&lt;p&gt;In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;&lt;/p&gt;

&lt;p&gt;For the right of the range, we can use a similar idea. Again we can come up with several rules:&lt;/p&gt;

&lt;p&gt;If A[mid] &amp;gt; target, then the range must begins on the left of mid (j = mid-1)
If A[mid] &amp;lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration)
If A[mid] = target, then the range must begins on the right of or at mid (i= mid)
Again, we can merge condition 2 and 3 into:&lt;/p&gt;

&lt;p&gt;2* If A[mid] &amp;lt;= target, then i = mid;
However, the terminate condition on longer works this time. Consider the following case:&lt;/p&gt;

&lt;p&gt;[5 7], target = 5
Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!&lt;/p&gt;

&lt;p&gt;The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:&lt;/p&gt;

&lt;p&gt;mid = (i+j)/2+1
Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won’t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1.&lt;/p&gt;

&lt;p&gt;All this reasoning boils down to the following simple code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
vector&amp;lt;int&amp;gt; searchRange(int A[], int n, int target) {
    int i = 0, j = n - 1;
    vector&amp;lt;int&amp;gt; ret(2, -1);
    // Search for the left one
    while (i &amp;lt; j)
    {
        int mid = (i + j) /2;
        if (A[mid] &amp;lt; target) i = mid + 1;
        else j = mid;
    }
    if (A[i]!=target) return ret;
    else ret[0] = i;
    
    // Search for the right one
    j = n-1;  // We don't have to set i to 0 the second time.
    while (i &amp;lt; j)
    {
        int mid = (i + j) /2 + 1;	// Make mid biased to the right
        if (A[mid] &amp;gt; target) j = mid - 1;  
        else i = mid;				// So that this won't make the search range stuck.
    }
    ret[1] = j;
    return ret; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 22 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/22/leetcode34/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/22/leetcode34/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 33. Search in Rotated Sorted Array</title>
        <description>&lt;p&gt;LeetCode 33. Search in Rotated Sorted Array&lt;/p&gt;

&lt;p&gt;从根本上面说，这个数据很有意思，只是正常的数据进行的一次转换，我们需要的就是怎么转换回来，或者说在经典的算法中，下标计算的时候，怎么能够不受这次转换的影响。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;既然是有一段数据被翻转回到了数据的开头，那我们怎么能够比较巧妙的翻转回去尼？

i = (i + k) % n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int search(int A[], int n, int target) {
  int lo = 0, hi = n - 1;
  //！！！寻找折点的算法也是折半查找！！！
  while (lo &amp;lt; hi) {
   int mid = (lo + hi) / 2;
   if (A[mid] &amp;gt; A[hi])
    lo = mid + 1;
   else
    hi = mid;
  }


  int rot = lo;
  lo = 0;
  hi = n - 1;

  while (lo &amp;lt;= hi) {
   int mid = (lo + hi) / 2;
   //最关键的一句，说明了，这个题目看数据的方式
   int realmid = (mid + rot) % n;
   if (A[realmid] == target)
    return realmid;
   if (A[realmid] &amp;lt; target)
    lo = mid + 1;
   else
    hi = mid - 1;
  }
  return -1;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode33/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode33/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 32. Longest Valid Parentheses</title>
        <description>&lt;p&gt;LeetCode 32. Longest Valid Parentheses
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: &quot;(()&quot;
Output: 2
Explanation: The longest valid parentheses substring is &quot;()&quot;
Example 2:

Input: &quot;)()())&quot;
Output: 4
Explanation: The longest valid parentheses substring is &quot;()()&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 1. 首先理解题意是关键的步骤：挑选可以使用的括号规则，如下的规则
 * 
 * ()(() 计算值为2
 * ()()) 计算值为4
 * 
 * 2. 理解了题意之后，就是梳理具体的逻辑
 * 
 * 采用栈的的数据结构，来匹配右括号与左括号的匹配的规则
 * 左括号则入栈，右括号需要处理的逻辑是：
 * 匹配或者不匹配的情况
 *   如果是匹配的情况，那么需要把匹配的左括号出栈，然后根据出栈后的情况：
 *   如果还有内容，没有匹配完呢，直接的更新数据。
 *   如果栈内没有了内容，需要计算最大的长度。
 * 
 * 	 如果是不匹配的情况，右括号不匹配的情况，就是直接的丢弃。判断这个时候的栈内元素为空，并且更新最大长度的开始的值。
 * 			
 * */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int longestValidParentheses_copy(String s) {
  int n = s.length(), longest = 0;
  //记录遍历过程中s的下标的值
  Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;Integer&amp;gt;();
  
  for (int i = 0; i &amp;lt; n; i++) {
      if (s.charAt(i) == '(') {
       st.push(i);
      }else {
          if (!st.empty() &amp;amp;&amp;amp; s.charAt(st.peek()) == '(') {
           st.pop();
          }else {
           st.push(i);
          }
      }
  }
  
  if (st.empty()) longest = n;
  else {
      int a = n, b = 0;
      while (!st.empty()) {
          b = st.peek(); st.pop();
          longest = Math.max(longest, a-b-1);
          a = b;
      }
      longest = Math.max(longest, a);
  }
  return longest;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方案，可以比较清晰的看到，解题的思路，但是可能清晰的看到优化的空间，因为后面遍历stack的过程，可以融合在第一次遍历s的过程中。就如思路中所描述的那样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int longestValidParentheses(String s) {
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;();
        int max=0;
        // 匹配开始的节点
        int left = -1;//设想是(),匹配结束的i应该是1，则1-（-1） = 2 
        for(int j=0;j&amp;lt;s.length();j++){
            if(s.charAt(j)=='(') stack.push(j);
            else {
                if (stack.isEmpty()) left=j;
                else{
                    stack.pop();
                    if(stack.isEmpty()) max=Math.max(max,j-left);
                    else max=Math.max(max,j-stack.peek());
                }
            }
        }
        return max;
    }

System.out.println(longestValidParentheses(&quot;()(()&quot;)); //2
System.out.println(longestValidParentheses(&quot;)()())&quot;));//4
System.out.println(longestValidParentheses1(&quot;()(()&quot;)); //2
System.out.println(longestValidParentheses1(&quot;)()())&quot;));//4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode32/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode32/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 31. nextPermutation</title>
        <description>&lt;p&gt;LeetCode 31.nextPermutation&lt;/p&gt;

&lt;p&gt;题目一开始完全没有看懂，也不知道什么是next Permutation。知道排列，但是不知道next Permutation 是什么。这道题目的难点，全部的在于理解题意，并且找到翻转的规律。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:

Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input:
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
Output: []

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I don't think any one can understand this solution without seeing an example, 
here is an example:
2,3,6,5,4,1

Solution:
Step1, from right to left, 
find the first number which not increase in a ascending order. 
In this case which is 3.

Step2, here we can have two situations:

We cannot find the number, 
all the numbers increasing in a ascending order. 
This means this permutation is the last permutation,
 we need to rotate back to the first permutation. 
 So we reverse the whole array, 
 for example, 6,5,4,3,2,1 we turn it to 1,2,3,4,5,6.

We can find the number, then the next step, 
we will start from right most to leftward, 
try to find the first number which is larger than 3, 
in this case it is 4.
Then we swap 3 and 4, the list turn to 2,4,6,5,3,1.
Last, we reverse numbers on the right of 4,
we finally get 2,4,1,3,5,6.

Time complexity is: O(3*n)=O(n).

At the end, I don't know how to come up this solution. Here is just to understand the solution with example. Hope this helps.


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void nextPermutation(int[] nums) {
      int n = nums.length - 1, p = -1, pv = 0;

      for(int i = n - 1; i &amp;gt;= 0; i--){
        if(nums[i] &amp;lt; nums[i + 1]) {
            p = i;
            pv = nums[i];
            break;
        }
      }    
      
      if(p == -1) {
        reverse(nums, 0, n);
        return;
      }
      
      for(int i = n; i &amp;gt;= 0; i--){
        if(nums[i] &amp;gt; pv){
          swap(nums, p, i);
          break;
        }
      }
      
      reverse(nums, p + 1, n);
    }
    
    void reverse(int[] nums, int s, int e){
      while(s &amp;lt; e){
        swap(nums, s, e);
        s++;
        e--;
      }
    }
    
    void swap(int[] nums, int s, int e){
        int t = nums[s];
        nums[s] = nums[e];
        nums[e] = t;     
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode31/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode31/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：3. 通过具体的应用展示锁的实现机制</title>
        <description>&lt;p&gt;上一节关于AQS的锁的架构实现，说的非常的抽象，看的非常的费劲，这次通过代码的注释和说明，来展示具体是如何实现的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;reentrantlock&quot;&gt;ReentrantLock&lt;/h2&gt;

&lt;p&gt;关于可重入锁带着两个问题，去分析的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;怎么判断的重入，如何增加锁的次数的。&lt;/li&gt;
  &lt;li&gt;重入次数的判断，释放锁的时候，如果消减锁的次数，释放以后，其他的等待的线程是如何响应的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reentrantlock-lock-方法&quot;&gt;ReentrantLock lock 方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ReentrantLock() {
	sync = new NonfairSync();
}
public void lock() {
	sync.lock();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;符合使用框架的时候，都采用内部类NonfairSync来实现实现的需要实现的接口，这点也符合DOC的说明。&lt;/p&gt;

&lt;p&gt;NonfairSync 的实现逻辑如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static final class NonfairSync extends Sync {
  /**
   * so beautiful ！ 整个操作如此的不见烟火气：
   *
   * ①首先是CAS(state,1) 确定是否已经有线程抢占到锁，然后设置：ExclusiveThread（这个是普通的成员变量）,返回true；
   *  
   * 然后是：Acquire(1),更新state为1，
   * 
   * 具体的逻辑： !tryAcquire(1) =&amp;gt; acquireQueued(addWaiter(Node.EXCLUSIVE), 1)) =&amp;gt;selfInterrupt()
   * 
   * 根据getState的状态进行判断： 
   *    如果是0，说明原来的线程已经释放锁，重新的走① 
   *    如果大于零，当前的线程（Thread.concurrent）和 ExclusiveOwnerThread 进行比较 
   *              如果是独占线程为当前线程，则state+1，返回true; 如果不是，则返回false
   * 
   * 只有在返回false的前提下，才会执行：addWaiter(Node.EXCLUSIVE), 1)，
   */
  final void lock() {
   // 只是使用一个CAS的操作，就保证了线程抢占的唯一性
   if (compareAndSetState(0, 1))
    // private transient Thread exclusiveOwnerThread; 可以说只是一个普通的成员变量
    setExclusiveOwnerThread(Thread.currentThread());
   else
    // 如果是同一个线程，则去更新状态为1，如果不是当前的线程，会被阻塞的
    acquire(1);
  }

  protected final boolean tryAcquire(int acquires) {
   return nonfairTryAcquire(acquires);
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ReentrantLock的lock方法，其实默认的调用的就是 NonfairSync的lock方法，也就是说默认的是非公屏锁。这里就产生了一个问题：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;为什么是非公平的，和公平的差在什么地方？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后具体的流程就是CAS后，设置独占线程，Note：这个独占线程为普通的成员变量。&lt;/p&gt;

&lt;p&gt;再次就是acquire(1) ,这个方法其实调用的是AQS中的那个经典的方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//独占模式下的获取锁
 public final void acquire(int arg) {
  if (!tryAcquire(arg) &amp;amp;&amp;amp; // tryAcquire 为子类必须实现的方法，提供扩展的逻辑
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 获取锁失败以后
   selfInterrupt();
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的tryAcquire方法，就是在NonfairSync 继承的 Sync 中实习。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
   * 非公平获取锁 ！！！重要的框架！！！
   */
  final boolean nonfairTryAcquire(int acquires) {
   final Thread current = Thread.currentThread();
   int c = getState();
   if (c == 0) {
    if (compareAndSetState(0, acquires)) {
     setExclusiveOwnerThread(current);
     return true;
    }
   } else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc &amp;lt; 0) // overflow
     throw new Error(&quot;Maximum lock count exceeded&quot;);
    setState(nextc);
    return true;
   }
   return false;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先没有判断是否是独占线程，而是首先判断的state的状态！根据state的状态，进行二次的CAS操作。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果首先判断是否是独占线程，是否有问题？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后再去判断是否是独占线程，如果是，则去更新state的状态。&lt;/p&gt;

&lt;p&gt;返回以后，则进入AQS的框架中，如果没有抢到锁，则进入等待的队列，这里需要说一下这个等待的队列的加入函数：addWaiter&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 独占性的节点和共享性的节点，加入等待的链表中
 private Node addWaiter(Node mode) {
  Node node = new Node(Thread.currentThread(), mode);
  // Try the fast path of enq; backup to full enq on failure
  Node pred = tail;
  if (pred != null) {
   node.prev = pred;
   if (compareAndSetTail(pred, node)) {//相当于 tail=(pre==tail)?node:pre
    pred.next = node;
    return node;
   }

   /**
    *   head(new Node()) &amp;lt;----Thread[Thread-1] &amp;lt;---- Thread[Thread-2] &amp;lt;---- Thread[Thread-3](tail)
    *  相当于把node节点插入到队尾。
    *  Node node = new Node()
    *  Node pred = tail;
    *  node.prev = pred;
    *  tail = node;
    *  pred.next = node;
    * */
  }
  // 设置失败之后，进入enq，enq为for的无线循环的模式
  enq(node);
  return node;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的注释可以比较清楚明白的说明，线程排队的数据结构。其中的enq也是tail为null的时候的，初始化操作。&lt;/p&gt;

&lt;p&gt;然后就是更新线程队列的状态（我们现在只讨论比较普通的状况，特殊的等到遇见了在进行说明），以及怎么让线程“停下来”：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
  boolean failed = true;
  try {
   boolean interrupted = false;
   for (;;) {
    //Node 的 prev 成员变量
    final Node p = node.predecessor();
    // 再次去检查，是否有机会获取锁
    if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
     setHead(node);
     p.next = null; // help GC
     failed = false;
     return interrupted;
    }
    if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; parkAndCheckInterrupt())
     interrupted = true;
   }
  } finally {
   if (failed)
    cancelAcquire(node);
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再去更新等待队列线程节点Node的状态的时候，还是首先的去尝试获取锁，当然这个尝试是有条件的，那就是：&lt;code class=&quot;highlighter-rouge&quot;&gt;node.predecessor() == head&lt;/code&gt; 这个条件就是说明，node的前一个节点就是头结点，在等待队列初始化的时候，我们已经知道头结点只是一个“象征节点”，是没有对应线程的。所以如果满足条件，那么这个就应该是争抢锁的下一个节点。&lt;/p&gt;

&lt;p&gt;如果不满足条件，则会调用：&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldParkAfterFailedAcquire&lt;/code&gt; 这个就是线程对应的链表状态的更新：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
   /*
    * This node has already set status asking a release
    * to signal it, so it can safely park.
    */
   return true;
  if (ws &amp;gt; 0) {
   /*
    * Predecessor was cancelled. Skip over predecessors and
    * indicate retry.
    */
   do {
    node.prev = pred = pred.prev;
   } while (pred.waitStatus &amp;gt; 0);
   pred.next = node;
  } else {
   /*
    * waitStatus must be 0 or PROPAGATE.  Indicate that we
    * need a signal, but don't park yet.  Caller will need to
    * retry to make sure it cannot acquire before parking.
    */
   /**
    * 这句是pre设置为了Node.SIGNAL状态:
    * 待唤醒后继状态，当前节点的线程处于此状态，后继节点会被挂起，当前节点释放锁或取消之后必须唤醒它的后继节点。
    * */
   compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里注意一下：
&lt;code class=&quot;highlighter-rouge&quot;&gt;acquireQueued&lt;/code&gt; 是一个无限的for循环结构，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldParkAfterFailedAcquire&lt;/code&gt; 可能会被调用很多次。所以一般的会被调用两次，第一次，因为新建的Node节点，waitStatus 就是默认值0，所以如果下载再有阻塞节点的时候，
&lt;code class=&quot;highlighter-rouge&quot;&gt;node.pre == 0&lt;/code&gt;
都会先把前驱节点设置为：Node.SIGNAL，也就是调用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;compareAndSetWaitStatus(pred, ws, Node.SIGNAL)&lt;/code&gt;
然后下次acquireQueued的for循环里面，再次判断的时候&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;node.pre 就等于 Node.SIGNAL&lt;/code&gt;
然后shouldParkAfterFailedAcquire，返回了true。&lt;/p&gt;

&lt;p&gt;轮到了函数：&lt;code class=&quot;highlighter-rouge&quot;&gt;parkAndCheckInterrupt&lt;/code&gt; 这个方法很有意思：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final boolean parkAndCheckInterrupt() {
  LockSupport.park(this);
  return Thread.interrupted();
 }

// LockSupport 的park方法
 public static void park(Object blocker) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(false, 0L);
        setBlocker(t, null);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里涉及到一个挺有意思的工具类：LockSupport，我们最基础的和工具类了，这个类的详细我们会面会说，只说一下其支持的两个方法的特点：&lt;/p&gt;

&lt;p&gt;java.util.concurrent.locks.LockSupport.park(Object object)
暂停当前的线程,在缺乏凭证的前提下，会一直的:the current thread becomes disabled for thread scheduling&lt;/p&gt;

&lt;p&gt;java.util.concurrent.locks.LockSupport.unpark(Thread thread)
给与参数中的Thread中的凭证，也就是立刻的唤醒对应的线程。&lt;/p&gt;

&lt;p&gt;另外还有一点，unpark可以在 park之前调用，这样就不必担心漏掉“凭证”。具体的测试代码见：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) throws InterruptedException {

  Thread test1 = new Thread(new Runnable() {
   @Override
   public void run() {

    try {
     Thread.sleep(1000);
    } catch (InterruptedException e) {
    }
    System.out.println(&quot;park before !&quot;);
    LockSupport.park(&quot;&quot;);
    System.out.println(&quot;park after !&quot;);
   }
  });
  
  test1.start();

  LockSupport.unpark(test1);
  System.out.println(&quot;Call unpark first&quot;);

  Thread.sleep(1000);
  System.out.println(&quot;Thread.state: &quot; + test1.getState().name());

 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后回到&lt;code class=&quot;highlighter-rouge&quot;&gt;parkAndCheckInterrupt&lt;/code&gt; 方法，则等待的队列中的线程，算是真正的在等待着了。后面的只有等待别的线程释放锁以后，才能够运行了，我们接着看realease方法。&lt;/p&gt;

&lt;h3 id=&quot;reentrantlock-unlock-方法&quot;&gt;ReentrantLock unlock 方法&lt;/h3&gt;

&lt;p&gt;unlock 方法和lock的方法，又有很大的不同，因为lock方法一开始调用的时候，也就是一开始执行CAS代码的时候，是可能多个线程同时执行，但是unlock方法，在一开始的时候，只有拥有锁的方法，才去调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void unlock() {
  sync.release(1);
 }

 //sync.release方法，直接进入AQS的框架

 /**
  * 释放锁的框架：tryRelease(int arg) 有子类进行实现
  * 如果释放成功，则去通知等待的线程
  * */
 public final boolean release(int arg) {
  if (tryRelease(arg)) {
   Node h = head;
   //如果存在等待的线程：Wait queue中有值，根据我们先前的AddWaiter和shouldParkAfterFailedAcquire 逻辑
   // head 应该是new Node(),并且 waitStatus 为 Signal状态
   if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
    unparkSuccessor(h);
   return true;
  }
  return false;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们还是按照原来的流程，先去关注Sync实现的子类方法tryRelease：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /**
   * 释放的时候，肯定是获得锁的线程进行调用，所以不需要CAS之类的操作，只需要判定状态即可
   */
  protected final boolean tryRelease(int releases) {
   int c = getState() - releases;
   if (Thread.currentThread() != getExclusiveOwnerThread())
    throw new IllegalMonitorStateException();
   boolean free = false;
   if (c == 0) {
    free = true;
    setExclusiveOwnerThread(null);
   }
   setState(c);
   return free;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先是状态检查，然后根据state的值，判断锁释放是否成功，可以说这段的代码就是单线程在执行，不用担心线程安全的问题。&lt;/p&gt;

&lt;p&gt;然后就是 release方法中的 再次争抢锁的过程了，这里面有一个比较重要的看点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void unparkSuccessor(Node node) {
  // 把当Node节点（head节点），设置为了状态0
  int ws = node.waitStatus;
  if (ws &amp;lt; 0)
   compareAndSetWaitStatus(node, ws, 0);

  //根据状态，获得最近的可以被唤醒的线程节点
  Node s = node.next;
  if (s == null || s.waitStatus &amp;gt; 0) {
   s = null;
   for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
    if (t.waitStatus &amp;lt;= 0)
     s = t;
  }
  if (s != null)
   LockSupport.unpark(s.thread);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法有意思的一点就是，是和shouldParkAfterFailedAcquire 相对应的，shouldParkAfterFailedAcquire 把自己的pre Node 设置为Node.SIGNAL 状态，而unparkSuccessor 把Node 设置为原来的0 状态。&lt;/p&gt;

&lt;p&gt;然后调用：
 &lt;code class=&quot;highlighter-rouge&quot;&gt;LockSupport.unpark(s.thread)&lt;/code&gt; 
唤醒队列中最先等待的线程，让它去抢锁。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这不看起来挺公平的吗？为什么叫做：NonfairSync，难道有锁的时候，大家一起抢，才算作是公平吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在来看一下，公平锁是怎么实现的，公平又是如何体现的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static final class FairSync extends Sync {
  private static final long serialVersionUID = -3000897897090466540L;

  final void lock() {
   acquire(1);
  }

  /**
   * Fair version of tryAcquire.  Don't grant access unless
   * recursive call or no waiters or is first.
   */
  protected final boolean tryAcquire(int acquires) {
   final Thread current = Thread.currentThread();
   int c = getState();
   if (c == 0) {
    if (!hasQueuedPredecessors() &amp;amp;&amp;amp; compareAndSetState(0, acquires)) {
     setExclusiveOwnerThread(current);
     return true;
    }
   } else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc &amp;lt; 0)
     throw new Error(&quot;Maximum lock count exceeded&quot;);
    setState(nextc);
    return true;
   }
   return false;
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;两点比较重要：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;没有单独的实现realease方法，说明在释放锁的逻辑上和非公平锁的逻辑是一样的，都是释放锁成功后，唤醒等待链表中，等待时间最长的那个。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;lock 方法上面有差别，公平锁上来就是acquire(1),然后在tryAcquire方法中，增加了一个!hasQueuedPredecessors 的判断。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中hasQueuedPredecessors代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean hasQueuedPredecessors() {
  Node t = tail; // Read fields in reverse initialization order
  Node h = head;
  Node s;
  return h != t &amp;amp;&amp;amp; ((s = h.next) == null || s.thread != Thread.currentThread());
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;tail != head 好理解，意思是有线程在排队
(s = h.next) == null || s.thread != Thread.currentThread() 排队的线程不是当前线程&lt;/p&gt;

&lt;p&gt;到了这里公平锁的逻辑就算理清楚了，它是在抢锁的时候，保证公平，如果有等待队列的时候，新进来的线程，首先会进行：!hasQueuedPredecessors，立马回返回false，因为存在等待的线程，并且当前的等待激活的线程不是当前的线程，就会立即的进入等待线程中等待。&lt;/p&gt;

&lt;p&gt;但是被唤醒的线程，就会因为当前的等待激活的线程就是当前的线程
，而去执行&lt;code class=&quot;highlighter-rouge&quot;&gt;compareAndSetState(0, acquires)&lt;/code&gt; 才有可能抢到锁。&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/20/concurrent-4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/20/concurrent-4/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 30. Substring with Concatenation of All Words</title>
        <description>&lt;p&gt;LeetCode 30. Substring with Concatenation of All Words&lt;/p&gt;

&lt;p&gt;hard&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 30. Substring with Concatenation of All Words&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:

Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input:
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
Output: []

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先是words的定长，这个在匹配的时候，
肯定更加的好判断一点，还有就是题目中没有明确说明的重复出现的单词的现象，
需要考虑一下。可以采用Map的数据结构存储，key为单词，value为单词出现的
次数。

对于匹配的元素，再次的采用map数据记录。
根据匹配的个数是否与words的length值相等来判断是否，匹配成功。

对字符串进行遍历操作，每次的i，都要进行words的匹配的校验
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;Integer&amp;gt; findSubstring(String s, String[] words) {
        final Map&amp;lt;String, Integer&amp;gt; counts = new HashMap&amp;lt;&amp;gt;();
        for (final String word : words) {
            counts.put(word, counts.getOrDefault(word, 0) + 1);
        }

        final List&amp;lt;Integer&amp;gt; indexes = new ArrayList&amp;lt;&amp;gt;();
        final int n = s.length(), num = words.length, len = words[0].length();
        for (int i = 0; i &amp;lt; n - num * len + 1; i++) {
            final Map&amp;lt;String, Integer&amp;gt; seen = new HashMap&amp;lt;&amp;gt;();
            int j = 0;
            while (j &amp;lt; num) {
                final String word = s.substring(i + j * len, i + (j + 1) * len);
                if (counts.containsKey(word)) {
                    seen.put(word, seen.getOrDefault(word, 0) + 1);
                    if (seen.get(word) &amp;gt; counts.getOrDefault(word, 0)) {
                        break;
                    }
                } else {
                    break;
                }
                j++;
            }
            if (j == num) {
                indexes.add(i);
            }
        }
        return indexes;
    }	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 19 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/19/leetcode30/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/19/leetcode30/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 29. Divide Two Integers</title>
        <description>&lt;p&gt;LeetCode 29 题的分析和总结：  29. Divide Two Integers&lt;/p&gt;

&lt;p&gt;迭代循环&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 29. Divide Two Integers&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;迭代逻辑，不使用乘除，取余的计算，我们还可以使用加法，位移运算等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public int divide_copy(int dividend, int divisor) {
    if (dividend == Integer.MIN_VALUE &amp;amp;&amp;amp; divisor == -1) {
        return Integer.MAX_VALUE;
    }

    if (dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0) {
        return divideHelper(-dividend, -divisor);
    } else if (dividend &amp;gt; 0) {
        return -divideHelper(-dividend, divisor);
    }
    else if(divisor &amp;gt; 0) {
        return -divideHelper(dividend, -divisor);
    }
    else {
        return divideHelper(dividend, divisor);
    }
}

private int divideHelper(int dividend, int divisor){
    int res = 0;
    int currentDivisor = divisor;
    while(dividend&amp;lt;=divisor){    // abs(divisor) &amp;lt;= abs(dividend)
    	
        int temp = 1;  
        //test max temp for: temp * abs(divisor) &amp;lt;= abs(dividend), while temp = 2^n
        while( (currentDivisor &amp;lt;&amp;lt; 1) &amp;gt;=dividend &amp;amp;&amp;amp; (currentDivisor &amp;lt;&amp;lt; 1) &amp;lt;0 ){  
            temp &amp;lt;&amp;lt;=1;
            currentDivisor &amp;lt;&amp;lt;=1;
        }
        
        dividend -= currentDivisor;  
        res += temp;    
        currentDivisor = divisor;
    }       
    return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本来还有一个采用加法循环res的值，但是如果是除以1的话，会有超时的问题，所以才有了位移的操作。关于这个为什么是负数的操作，下面有一个正数的操作，但是报错了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public int divide(int dividend, int divisor) {
		//首先判定符号的问题
		boolean flag = (dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0) || (dividend &amp;lt; 0 &amp;amp;&amp;amp; divisor &amp;lt; 0);
		int dividends = 0;
		int divisors = 0;
		if (dividend == Integer.MIN_VALUE) dividend = Integer.MAX_VALUE;
		if (divisor == Integer.MIN_VALUE) divisor = Integer.MAX_VALUE;
		
		dividends = dividend &amp;gt; 0 ? dividend : -dividend;
		divisors = divisor &amp;gt; 0 ? divisor : -divisor;
		
		int res = 0;int curdivisors = divisors;
		while (dividends - divisors &amp;gt;= 0) {
			int tmp = 1;
			while( (divisors &amp;lt;&amp;lt; 1 &amp;lt;= dividends) &amp;amp;&amp;amp; (divisors &amp;lt;&amp;lt; 1) &amp;gt; 0 ) {
				tmp &amp;lt;&amp;lt;=1;
				divisors &amp;lt;&amp;lt;=1;
			}
			
			res+=tmp;
			dividends -= divisors;
			divisors = curdivisors;
		}
		return flag ? res : -res;
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;错误的测试用例是：
-2147483648 1&lt;/p&gt;

&lt;p&gt;错误的根由在于 (Integer.MAX_VALUE），(Integer.MIN_VALUE) 一个是 -2147483648，一个是2147483647，这道题目下，如果不使用Long值，修改为负数比较合适。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    		public int divide(int dividend, int divisor) {
		//首先判定符号的问题
		boolean flag = (dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0) || (dividend &amp;lt; 0 &amp;amp;&amp;amp; divisor &amp;lt; 0);

		int dividends = dividend &amp;gt; 0 ? -dividend : dividend;
		int divisors = divisor &amp;gt; 0 ? -divisor : divisor;
		
		int res = 0;int curdivisors = divisors;
		while (dividends &amp;lt;= divisors) {
			int tmp = 1;
			while( (divisors &amp;lt;&amp;lt; 1 &amp;gt;= dividends) &amp;amp;&amp;amp; (divisors &amp;lt;&amp;lt; 1) &amp;lt; 0 ) {
				tmp &amp;lt;&amp;lt;=1;
				divisors &amp;lt;&amp;lt;=1;
			}
			
			res+=tmp;
			dividends -= divisors;
			divisors = curdivisors;
		}
			return flag ? res==Integer.MIN_VALUE?Integer.MAX_VALUE:res : -res;

	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode29/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode29/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode28   Implement strStr()</title>
        <description>&lt;p&gt;LeetCode 28 题的分析和总结：  Implement strStr()&lt;/p&gt;

&lt;p&gt;字符串操作&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 28. Implement strStr()&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
Output: 2
Example 2:

Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;needle 为null的时候，返回的是0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int strStr(String haystack, String needle) {
		if (needle == null || &quot;&quot;.equals(needle))
			return 0;
		char[] haystackc = haystack.toCharArray();
		char[] neddlec = needle.toCharArray();
		for (int i = 0; i &amp;lt; haystackc.length - neddlec.length + 1; i++) {
			char hc = haystackc[i];
			if (hc == neddlec[0]) {
				if (meetCondition(haystackc, i + 1, neddlec, 1)) {
					return i;
				}
			}
		}

		return -1;
	}

private boolean meetCondition(char[] haystackc, int i, char[] neddlec, int j) {
	for (; j &amp;lt; neddlec.length &amp;amp;&amp;amp; i &amp;lt; haystackc.length; j++, i++) {
		if (neddlec[j] != haystackc[i]) {
			return false;
		}
	}
	return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JAVA 的JDK里面的 String的API方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public int indexOf(String str) {
        return indexOf(str, 0);
    }

	public int indexOf(String str, int fromIndex) {
        return indexOf(value, 0, value.length,
                str.value, 0, str.value.length, fromIndex);
    }

	 /**
     * Code shared by String and StringBuffer to do searches. The
     * source is the character array being searched, and the target
     * is the string being searched for.
     *
     * @param   source       the characters being searched.
     * @param   sourceOffset offset of the source string.
     * @param   sourceCount  count of the source string.
     * @param   target       the characters being searched for.
     * @param   targetOffset offset of the target string.
     * @param   targetCount  count of the target string.
     * @param   fromIndex    the index to begin searching from.
     */
    static int indexOf(char[] source, int sourceOffset, int sourceCount,
            char[] target, int targetOffset, int targetCount,
            int fromIndex) {
        if (fromIndex &amp;gt;= sourceCount) {
            return (targetCount == 0 ? sourceCount : -1);
        }
        if (fromIndex &amp;lt; 0) {
            fromIndex = 0;
        }
        if (targetCount == 0) {
            return fromIndex;
        }

        char first = target[targetOffset];
        int max = sourceOffset + (sourceCount - targetCount);

        for (int i = sourceOffset + fromIndex; i &amp;lt;= max; i++) {
            /* Look for first character. */
            if (source[i] != first) {
                while (++i &amp;lt;= max &amp;amp;&amp;amp; source[i] != first);
            }

            /* Found first character, now look at the rest of v2 */
            if (i &amp;lt;= max) {
                int j = i + 1;
                int end = j + targetCount - 1;
                for (int k = targetOffset + 1; j &amp;lt; end &amp;amp;&amp;amp; source[j]
                        == target[k]; j++, k++);

                if (j == end) {
                    /* Found whole string. */
                    return i - sourceOffset;
                }
            }
        }
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;总感觉JDK的代码写的比较的优雅一些，到底是哪里比较好尼？
首先是参数名称的定义：
char[] source 
char[] target 
这两个就不说了，关键是sourceOffset，sourceCount，targetOffset，targetCount和fromIndex 定义的比较的赏心悦目。
另外就是整个算法的逻辑比较清晰，首先异常处理，然后确定首次的匹配开始i，然后i之后的判断。还有一点就是缩写的使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; while (++i &amp;lt;= max &amp;amp;&amp;amp; source[i] != first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int k = targetOffset + 1; j &amp;lt; end &amp;amp;&amp;amp; source[j]== target[k]; j++, k++);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode28/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode28/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
  </channel>
</rss>
