<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 09 Sep 2019 09:30:09 +0800</pubDate>
    <lastBuildDate>Mon, 09 Sep 2019 09:30:09 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>LeetCode26  Remove Duplicates from Sorted Array</title>
        <description>&lt;p&gt;LeetCode 26 题的分析和总结： Remove Duplicates from Sorted Array&lt;/p&gt;

&lt;p&gt;数组操作&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 26.  Remove Duplicates from Sorted Array&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关键在于 in-place 操作，但是反过来想， in-place 操作也是算法提示的一种。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int removeDuplicates(int[] nums) {

	public int removeDuplicates(int[] nums) {
		if(nums == null || nums.length &amp;lt;2) return nums.length;
		int key = nums[0],cur = 1;
		for (int current = 1; current &amp;lt; nums.length; current++) {
			if(nums[current] != key){
				nums[cur] = nums[current];
				++cur;
				key = nums[current];
			}
		}
		return cur;
	}     
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在比较一下标准的简练答案：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int removeDuplicates(int[] A) {
    if (A.length&amp;lt;=1) return nums.length;
    int j=0;
    for (int i=0; i&amp;lt;A.length; i++)
        if (A[i]!=A[j]) A[++j]=A[i];
    return ++j;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode26/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode26/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：2. Lock</title>
        <description>&lt;p&gt;java.util.concurrent.locks.Lock 为一个接口，围绕着这个接口实现了一些列的锁。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;lock&quot;&gt;Lock&lt;/h2&gt;

&lt;p&gt;Lock接口和Condition接口的均为锁相关的两个接口，具体的说明：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a ReadWriteLock.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其声明的接口为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Lock {

    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();

    /**
     Returns a new Condition instance that is bound to this Lock instance.
     Before waiting on the condition the lock must be held by the current thread.
     A call to Condition.await() will atomically release the lock before waiting 
     and re-acquire the lock before the wait returns.
     */
    Condition newCondition();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Condition的实例绑定在Lock实例上，只有当前的线程拿到了锁以后，才能够调用Condition的wait方法。调用了condition的await()方法，会自动的释放锁。wait结束以后，会重新的获得这个锁。类似synchronized里面 object.wait()方法。&lt;/p&gt;

&lt;h2 id=&quot;锁的实现的基础aqs&quot;&gt;锁的实现的基础：AQS&lt;/h2&gt;

&lt;p&gt;说起来锁的实现就必须要说：AQS。AQS是用来构建锁和其他同步组件的基础框架，它也是Java三大并发工具类（CountDownLatch、CyclicBarrier、Semaphore）的基础。ReentrantLock，甚至BlockingQueue也是基于它的实现，可以说是非常重要了。&lt;/p&gt;

&lt;p&gt;简单介绍一下，AQS其实就是一个类，全称是AbstractQueuedSynchronizer，队列同步器。&lt;/p&gt;

&lt;p&gt;想要了解AQS，那就先仔细的阅读DOC。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState(), setState(int) and compareAndSetState(int, int) is tracked with respect to synchronization.
依赖FIFO的等待队列，实现了一个针对阻塞锁和同步器的框架。
使用一个 atomic int value 来标识状态。

Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly(int) that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods.
子类一般的采用非public的内部类的形式来实现需要满足同步特性的方法。

This class supports either or both a default exclusive mode and a shared mode. When acquired in exclusive mode, attempted acquires by other threads cannot succeed. Shared mode acquires by multiple threads may (but need not) succeed. This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well. Threads waiting in the different modes share the same FIFO queue. Usually, implementation subclasses support only one of these modes, but both can come into play for example in a ReadWriteLock. Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode.

这个类提供了两种模式：独占和共享。一般来说子类只使用一种模式，
但是ReadWriteLock是两种模式共存的。

This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively() reports whether synchronization is exclusively held with respect to the current thread, method release(int) invoked with the current getState() value fully releases this object, and acquire(int), given this saved state value, eventually restores this object to its previous acquired state. No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of AbstractQueuedSynchronizer.ConditionObject depends of course on the semantics of its synchronizer implementation.
这个类还提供了一个Condition类。

This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects. These can be exported as desired into classes using an AbstractQueuedSynchronizer for their synchronization mechanics.

Serialization of this class stores only the underlying atomic integer maintaining state, so deserialized objects have empty thread queues. Typical subclasses requiring serializability will define a readObject method that restores this to a known initial state upon deserialization.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;阅读了DOC有一个大致的了解，我们还是看源码比较的利索。AQS的成员变量有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private transient volatile Node head;

    private transient volatile Node tail;

    private volatile int state;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AQS中主要维护了state（锁状态的表示）和一个可阻塞的等待队列。
state是临界资源，也是锁的描述。表示有多少线程已经获取了锁。&lt;/p&gt;

&lt;p&gt;关于state有一个更改的CAS操作：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;

    stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));

    protected final boolean compareAndSetState(int expect, int update) {
        // See below for intrinsics setup to support this
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;成员变量的head ， tail 标识的是等待队列（也称之为 CHL，同步队列）的头结点和尾节点。
CHL队列主要有链表实现，以自旋的方式获取资源，是可阻塞的先进先出的双向队列。通过自旋才做来保证节点插入和移除的原子性。获取锁失败的线程，则会被添加到队尾。&lt;/p&gt;

&lt;h3 id=&quot;aqs的内部类node&quot;&gt;AQS的内部类：Node&lt;/h3&gt;

&lt;p&gt;该Node代表的是 Wait queue node class。 组织形式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      +------+  prev +-----+       +-----+
 head |      | &amp;lt;---- |     | &amp;lt;---- |     |  tail
      +------+       +-----+       +-----+

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Node有大段的注释，我们能够了解到：
We instead use them for blocking synchronizers, 
but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node.&lt;/p&gt;

&lt;p&gt;还有其他的内容，我们结合着代码进行说明。&lt;/p&gt;

&lt;p&gt;AQS的工作模式分为独占模式和共享模式，记录在节点的信息中。它还使用了模板方法设计模式，定义一个操作中算法的骨架，而将一些步骤的实现延迟到子类中。比如获取资源的方法就能很好的品味模板模式。一般地，它的实现类只实现一种模式，ReentrantLock就实现了独占模式；但也有例外，ReentrantReadAndWriteLock实现了独占模式和共享模式。下面来看Node相关源码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        //当前节点处于共享模式的标记
        static final Node SHARED = new Node();
       
        //当前节点处于独占模式的标记
        static final Node EXCLUSIVE = null;

        //线程被取消了
        static final int CANCELLED =  1;
        //释放资源后需唤醒后继节点
        static final int SIGNAL    = -1;
        //等待condition唤醒
        static final int CONDITION = -2;
        //工作于共享锁状态，需要向后传播，
        //比如根据资源是否剩余，唤醒后继节点
        static final int PROPAGATE = -3;

        //等待状态，有1,0,-1,-2,-3五个值。分别对应上面的值
        volatile int waitStatus;

        //前驱节点
        volatile Node prev;

        //后继节点
        volatile Node next;

        //等待锁的线程
        volatile Thread thread;

        //等待条件的下一个节点，ConditonObject中用到
        Node nextWaiter;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;状态说明：&lt;/p&gt;

&lt;p&gt;CANCELLED
作废状态，该节点的线程由于超时，中断等原因而处于作废状态。是不可逆的，一旦处于这个状态，说明应该将该节点移除了。&lt;/p&gt;

&lt;p&gt;SIGNAL
待唤醒后继状态，当前节点的线程处于此状态，后继节点会被挂起，当前节点释放锁或取消之后必须唤醒它的后继节点。&lt;/p&gt;

&lt;p&gt;CONDITION
等待状态，表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。&lt;/p&gt;

&lt;h3 id=&quot;获取资源锁&quot;&gt;获取资源（锁）&lt;/h3&gt;

&lt;p&gt;获取释放资源其实都是对state变量的修改，有的文章会管他叫锁，笔者更喜欢叫资源。
获取资源的方法有acquire()，acquiredShared()。先来看acquire()，该方法只工作于独占模式。&lt;/p&gt;

&lt;h4 id=&quot;acquire独占模式获取资源&quot;&gt;acquire()–独占模式获取资源&lt;/h4&gt;

&lt;p&gt;aquire()：以独占模式获取资源，忽略中断（ReentrantLock.lock()中调用了这个方法）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Acquires in exclusive mode, ignoring interrupts. 
//Implemented by invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success. 
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;

            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之前也提到了AQS使用了模板方法模式，其实tryAcuire()方法就是一个钩子方法。在AQS中，此方法会抛出UnsupportedOperationException，所以需要子类去实现。tryAcquire(arg)返回false，其实就是获取锁失败的情况。这时候就调用：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)&lt;/p&gt;

&lt;p&gt;addWaiter()：将当前线程插入至队尾，返回在等待队列中的节点（就是处理了它的前驱后继）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Node addWaiter(Node mode) {
        //把当前线程封装为node,指定资源访问模式
        Node node = new Node(Thread.currentThread(), mode);

        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        //如果tail不为空,把node插入末尾
        if (pred != null) {
            node.prev = pred;
            //此时可能有其他线程插入,所以使用CAS重新判断tail
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        //如果tail为空，说明队列还没有初始化，执行enq()
        enq(node);
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAS设置队尾：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long tailOffset;
 tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));

   /**
     * CAS tail field. Used only by enq.
     */
    private final boolean compareAndSetTail(Node expect, Node update) {
        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/17/concurrent-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/17/concurrent-3/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：1. synchronized</title>
        <description>&lt;p&gt;synchronized 关键字作为并发理念中，最最基础的部分，需要首先搞明白。&lt;/p&gt;

&lt;p&gt;Volatile 关键字，又做了哪些工作和Synchronized 有什么不同？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先还是实例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Producer extends Thread {
	static final int MAXQUEUE = 5;
	private Vector&amp;lt;String&amp;gt; messages = new Vector&amp;lt;String&amp;gt;();

	@Override
	public void run() {
		try {
			while (true) {
				putMessage();
			}
		} catch (InterruptedException e) {
		}
	}

	private synchronized void putMessage() throws InterruptedException {
		while (messages.size() == MAXQUEUE) {
			wait();
		}
		messages.addElement(new java.util.Date().toString());
		System.out.println(&quot;put message&quot;);
		notify();
		//Later, when the necessary event happens, the thread that is running it calls notify() from a block synchronized on the same object.
	}

	// Called by Consumer
	public synchronized String getMessage() throws InterruptedException {
		notify();
		while (messages.size() == 0) {
			wait();//By executing wait() from a synchronized block, a thread gives up its hold on the lock and goes to sleep.
		}
		String message = (String) messages.firstElement();
		messages.removeElement(message);
		return message;
	}
}

class Consumer extends Thread {
	Producer producer;

	Consumer(Producer p) {
		producer = p;
	}
	@Override
	public void run() {
		try {
			while (true) {
				String message = producer.getMessage();
				System.out.println(&quot;Got message: &quot; + message);
				//sleep(200);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public static void main(String args[]) {
		Producer producer = new Producer();
		producer.start();
		new Consumer(producer).start();
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Java虚拟机的运行时数据区中的堆和方法区是所有线程共享的区域，这个是加锁机制的基础：数据存储在一个公用的地方，这是为什么加锁的原因，也是可以加锁的基础。&lt;/p&gt;

&lt;p&gt;Java虚拟机将锁与每个对象或类关联起来。锁就像一种特权，在任何时候只有一个线程可以“拥有”它。如果一个线程想要锁定一个特定的对象或类，它会请求JVM，在线程向JVM请求锁之后(如果锁未被持有可能很快，如果锁被持有也可能稍后，也可能永远不会)，JVM将锁提供给线程。当线程不再需要锁时，它将锁返回给JVM。&lt;/p&gt;

&lt;p&gt;这个时候，就会有一个疑问，锁到底是什么？&lt;/p&gt;

&lt;p&gt;对象锁：也就是类实例对象的锁。类锁实际上是作为对象锁实现的。当JVM加载类文件时，它会创建类java.lang.Class的实例。当锁定一个类时，实际上锁定了那个类的类对象。&lt;/p&gt;

&lt;p&gt;在HotSpot虚拟机中，Java对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充。对象头包含两部分，第一部分包含对象的HashCode、分代年龄、锁标志位、线程持有的锁、偏向线程ID等数据，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit，官方称为Mark World。考虑到虚拟机的空间效率，Mark World内部的数据结构是非固定的，也就是说对象头中存储的内容是不固定的，下图展示了不同状态下，对象头中存储的内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://7cmppq.ch.files.1drv.com/y4mH5bJLLrgVmBTfUJ_z3-ynrSM39knd9mcDHzpSE4DTGZIJdjeh48UFstIs1JD0Qat9LMxaRStoRoKtVMSw-qLqL0a-Dr4RLsjImgiP76b5so_lNdw-mpZLMR-3yR2iFfSDopIKyO_yyV5msy15_qstR5RGrln5VY-oyBEY1sQWfxMqChGvLaJM4amyaDlu_9PElfbphfFStlPpLQylV-LcQ?width=1376&amp;amp;height=372&amp;amp;cropmode=none&quot; alt=&quot;对象头存储的内容&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当使用synchronized修饰方法或修饰语句块时(即获取对象锁或类锁时)，对象(类实例对象或类的类对象)的对象头中锁状态处于重量级锁，此时锁标志位为10，其余30bit用于存储指向互斥量(重量级锁)的指针，这里的指针，笔者理解为monitor对象的地址。&lt;/p&gt;

&lt;p&gt;Java虚拟机中，synchronized支持的同步方法和同步语句都是使用monitor来实现的。&lt;strong&gt;每个对象都与一个monitor相关联，当一个线程执行到一个monitor监视下的代码块中的第一个指令时，该线程必须在引用的对象上获得一个锁，这个锁是monitor实现的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在HotSpot虚拟机中，monitor是由ObjectMonitor实现，使用C++编写实现，具体代码在HotSpot虚拟机源码ObjectMonitor.hpp文件中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ObjectMonitor() {
    _header       = NULL;
    _count        = 0;    // 记录该线程获取锁的次数
    _waiters      = 0,
    _recursions   = 0;    // 锁的重入次数
    _object       = NULL;
    _owner        = NULL; // 指向持有ObjectMonitor对象的线程
    _WaitSet      = NULL; // 处于wait状态的线程集合
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 处于等待锁block状态的线程队列
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当并发线程执行synchronized修饰的方法或语句块时，先进入_EntryList中，当某个线程获取到对象的monitor后，把monitor对象中的_owner变量设置为当前线程，同时monitor对象中的计数器_count加1，当前线程获取同步锁成功。&lt;/p&gt;

&lt;p&gt;当synchronized修饰的方法或语句块中的线程调用wait()方法时，&lt;strong&gt;当前线程将释放持有的monitor对象，monitor对象中的_owner变量赋值为null，同时，monitor对象中的_count值减1，然后当前线程进入_WaitSet集合中等待被唤醒。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个线程可以多次锁定同一个对象。对于每个对象，JVM维护对象被锁定的次数的计数。未加锁的对象的计数为零。当线程第一次获得锁时，计数将增加到1。每次线程获取同一个对象上的锁时，都会增加一个计数。每次线程释放锁时，计数将被递减。当计数达到0时，锁被释放，此时其它线程可以继续请求获取锁。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。&lt;/p&gt;

&lt;p&gt;可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将会引发许多严重问题。&lt;/p&gt;

&lt;p&gt;Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。&lt;/p&gt;

&lt;p&gt;一旦一个共享变量（类的成员变量、 类的静态成员变量） 被 volatile 修饰之后， 那么就具备了两层语义：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;保证了不同线程对这个变量进行读取时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 (volatile 解决了线程间共享变量的可见性问题)。&lt;/li&gt;
  &lt;li&gt;禁止进行指令重排序， 阻止编译器对代码的优化。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;内存可见性&quot;&gt;内存可见性&lt;/h3&gt;

&lt;p&gt;要说内存的可见性，就得知道JMM（JVM的内存模型）和硬件内存架构大致的样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://7cocvg.ch.files.1drv.com/y4mYFPEo_uZaGWDzyWpvKyK1cUSkgtVrZucLl-Av_44-1w-HpwewW0YmxQvi689NZHYqZAe1lAj-Knv5RFl_v2kDpH9aKskfWJ8jxN74aAWOqbveBiKXkaAMklt9OQ2M_lt43LGbiMzOLbPcf2DJqae2Uj1iBE8AcLFCf5icVBuOCuB1QWTTRPkhBcZ912vHYb3gX9bYgMpnVztL1ruKbf-Ig?width=920&amp;amp;height=766&amp;amp;cropmode=none&quot; alt=&quot;JVM的内存模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://7cmdmw.ch.files.1drv.com/y4mHUqHQZ0hbKJDhqqpbWPeq7tSuN0mvwCEUDESuo4xDk0KAjSTvKMGDOD0kFoA-woavXsOasaKMwk3kW0OddjwYblSZ_YX8SK-CDX55xtdSOFluvjiJ8f-8ASPpc2y2nEDF2uvyxd1djcuYom2p5DUknCBUkrzNCS19Hi10dA68F2h9ETe1hCoE41Jw721mg44qvPdRfyrtxx5G41AmNzolQ?width=443&amp;amp;height=382&amp;amp;cropmode=none&quot; alt=&quot;内存模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sjmzpw.ch.files.1drv.com/y4mBwlQrTVdfTSw8wqIo5KR9F9k33dsYh6vg2S3PbSHDmgx3MUCaD9CiaUmgfdUbd3UHO_s-6aDbiBSYTSwVK0jUQFrTNJcGZeDdnpGKO6qGAOZ0ORjmKT0LgF-SZ3siEr35GpyT0-zmAuL5F2E_XObf9618_o5_sEmv4rS89Mo8ZwMt6rzrxKG-qYmUFhCJzHaw7APSn_zqZF7iZRHVdUOig?width=1330&amp;amp;height=614&amp;amp;cropmode=none&quot; alt=&quot;映射&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：&lt;/p&gt;

&lt;p&gt;线程之间的共享变量存储在主内存（Main Memory）中
每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。&lt;/p&gt;

&lt;p&gt;从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。&lt;/p&gt;

&lt;p&gt;Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。&lt;/p&gt;

&lt;p&gt;说完了内存的模型以后，就必须的说一个协议：
&lt;img src=&quot;https://sjo0gw.ch.files.1drv.com/y4muaDk9g7Gq1j1knYF4XPVM4hj37ZuZUikoecn7FIVgp6Uf8XTamzDK0961iu_1croUQaiikNAZHhzvcerDo-MfvVoCPObZyi5tJM0d6NX6tWq0xeYUnpNhLeTmH1QFIndiX7t5h7irWi2kEKbUYM0KY7YPoo2qSFHbCYwnhZAZYroabYzaaKGobjpRXhS52b6W8CvPT1JhsDk6XYjDwpgCQ?width=1412&amp;amp;height=976&amp;amp;cropmode=none&quot; alt=&quot;缓存一致性协议&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说完了这么多的以后，Volatile是如何实现的内存可见性？
深入来说:通过加入内存屏障和禁止重排序优化来实现的&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对volatile变量执行写操作时,会在&lt;strong&gt;写操作后加入一条store屏障指令&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对volatile变量执行读操作时,会在&lt;strong&gt;读操作前加入一条load屏障指令&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通俗地讲:volatile变量在每次被线程访问时,都强迫从主内存中重读该变量的值,而当该变量发生变化时,又会强迫将最新的值刷新到主内存,这样任何时刻,不同的线程总能看到该变量的最新值&lt;/p&gt;

&lt;p&gt;volatile不能保证volatile变量复合操作的原子性,解决方案如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用synchronized关键字&lt;/li&gt;
  &lt;li&gt;使用ReentrantLock关键字(java.util.concurrent.locks包下)&lt;/li&gt;
  &lt;li&gt;使用AtomicInterger(java.util.concurrent.atomic包下)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是Volatile的主要用法也不是符合操作，而是：&lt;/p&gt;

&lt;p&gt;模式 #1：状态标志
模式 #2：一次性安全发布（one-time safe publication）
模式 #3：独立观察（independent observation）
模式 #4：“volatile bean” 模式
模式 #5：开销较低的读－写锁策略（存疑）&lt;/p&gt;

</description>
        <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/17/concurrent-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/17/concurrent-2/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：概述</title>
        <description>&lt;p&gt;梳理自己所掌握的，关于并发的内容。稳固而知道新的东西，想更加深入的方向，夯实自己薄弱基础。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;并发的东西，涉及的比较的多，自己只能从自己所知的角度来说明，来复习。&lt;/p&gt;

&lt;p&gt;从是否设计到一个JVM，还是多个JVM的角度划分：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;单机版本的并发&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;多机版本的并发&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们首先说单机版本的并发支持，这个主要就是JDK支持的并发模型了。JDK的并发的模型：&lt;strong&gt;java.util.concurrent&lt;/strong&gt; 首先列一下需要关注的内容，然后，一个一个的梳理。&lt;/p&gt;

&lt;h3 id=&quot;0-synchronizedvolatile关键字-和其相关联的waitnotify机制&quot;&gt;0. synchronized,Volatile关键字 和其相关联的wait，notify机制。&lt;/h3&gt;

&lt;h3 id=&quot;1-javautilconcurrentlocks&quot;&gt;1. java.util.concurrent.locks&lt;/h3&gt;

&lt;p&gt;Lock 锁，读写锁，可重入锁，Condition以及他们的实现的机制，具体的原理。&lt;/p&gt;

&lt;h3 id=&quot;2-javautilconcurrentatomic&quot;&gt;2. java.util.concurrent.atomic&lt;/h3&gt;

&lt;p&gt;AtomicInteger，AtomicLong，AtomicReference，AtomicIntegerArray，AtomicLongArray 等相关的内容，运用的方式，原理性的内容。&lt;/p&gt;

&lt;h3 id=&quot;3-javautilconcurrentblockingqueue&quot;&gt;3. java.util.concurrent.BlockingQueue&lt;E&gt;&lt;/E&gt;&lt;/h3&gt;

&lt;p&gt;在其上的ArrayBlockingQueue，ConcurrentLinkedQueue Deque等等的实现的方式&lt;/p&gt;

&lt;h3 id=&quot;4-javautilconcurrentconcurrentmap&quot;&gt;4. java.util.concurrent.ConcurrentMap&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap，ConcurrentSkipListMap，等等二元的数据结构&lt;/p&gt;

&lt;h3 id=&quot;5-countdownlatchcyclicbarrierexchanger&quot;&gt;5. CountDownLatch，CyclicBarrier，Exchanger&lt;/h3&gt;

&lt;p&gt;比较经典的并发场景&lt;/p&gt;

&lt;h3 id=&quot;4-javautilconcurrentabstractexecutorservice&quot;&gt;4. java.util.concurrent.AbstractExecutorService&lt;/h3&gt;

&lt;p&gt;在其上的线程池的原理：&lt;/p&gt;

&lt;p&gt;java.util.concurrent.ForkJoinPool，&lt;/p&gt;

&lt;p&gt;java.util.concurrent.ScheduledExecutorService，&lt;/p&gt;

&lt;p&gt;java.util.concurrent.ThreadPoolExecutor  以及其关联的 Callable，Thread，CompletionService等&lt;/p&gt;

</description>
        <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/17/concurrent-1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/17/concurrent-1/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>LeetCode25</title>
        <description>&lt;p&gt;LeetCode 25题的分析和总结：Reverse Nodes in k-Group&lt;/p&gt;

&lt;p&gt;递归&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 25. Reverse Nodes in k-Group&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

Example:

Given this linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5

For k = 2, you should return: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5

For k = 3, you should return: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5

Note:

Only constant extra memory is allowed.
You may not alter the values in the list's nodes, only nodes itself may be changed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;链表翻转的变形类题目,我们可以采用L24后面总结的基本的算法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static ListNode reverseKGroup(ListNode head, int k) {
		
		ListNode returnVal = null;
		ListNode prevToSet = null;
		int count = count(head);
		if (k &amp;gt; count) return head;

		ListNode result = head;
		while (result != null &amp;amp;&amp;amp; count &amp;gt;= k) {
			ListNode[] tmp = reverseKGroupHelper(result, k);
			result = tmp[1].next;
			count = count - k;
			if (prevToSet != null) {
				prevToSet.next = tmp[0];
				prevToSet = tmp[1];
			}

			if (returnVal == null) {
				returnVal = tmp[0];
				prevToSet = tmp[1];
			}
		}

		return returnVal;
	}



	/**
	 * @param head
	 * @param count
	 * @return
	 */
	private static int count(ListNode head) {
		int count = 0;
		ListNode result = head;
		while (result != null) {
			result = result.next;
			++count;
		}
		return count;
	}
	
	/**
	 * 一段的反转的过程，具体的逻辑可以描述为：把元素轮流的插入链表的头部
	 * */
	public static ListNode[] reverseKGroupHelper(ListNode head, int limitk) {
		ListNode pre = head;
		ListNode current = head;
		//当前元素的下一个元素
		ListNode next = null;
		int count = 1;
		while (current.next != null &amp;amp;&amp;amp; count &amp;lt; limitk) {
			//下一个元素
			next = current.next;
			//把当前元素的下一个元素指向下一个元素的next，相当于是跳过了next所指向的元素
			current.next = next.next;
			//然后把next指向的元素的下一个元素设置为前一个元素，完成把头元素的后面的元素挪到前面的位置
			next.next = pre;
			pre = next;
			++count;
		}
		return new ListNode[] { pre, current };
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode reverseKGroup_copy(ListNode head, int k) {
    int n = 0;
    for (ListNode i = head; i != null; n++, i = i.next);
    
    ListNode dmy = new ListNode(0);
    dmy.next = head;
    for(ListNode prev = dmy, tail = head; n &amp;gt;= k; n -= k) {
        for (int i = 1; i &amp;lt; k; i++) {
            ListNode next = tail.next.next;
            tail.next.next = prev.next;
            prev.next = tail.next;
            tail.next = next;
        }
        
        prev = tail;
        tail = tail.next;
    }
    return dmy.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode25/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode25/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode24</title>
        <description>&lt;p&gt;LeetCode 24题的分析和总结：Swap Nodes in Pairs&lt;/p&gt;

&lt;p&gt;递归&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 24. Swap Nodes in Pairs&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a linked list, 
swap every two adjacent nodes and 
return its head.

You may not modify the values in the list's nodes, 
only nodes itself may be changed.

 

Example:

Given 
1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 
you should return the list as 
2-&amp;gt;1-&amp;gt;4-&amp;gt;3.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;链表翻转的变形类题目
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    //替换两个节点的值
	public static ListNode swapPairs(ListNode head) {
		if (head == null|| head.next == null)
			return head;
		
		ListNode pre = new ListNode(0);
		ListNode tmp = null;
		ListNode currentPre = pre;
		
		
		
		while (head != null &amp;amp;&amp;amp; head.next != null) {
			//next 插入到 head 之前即可 
			tmp = head.next;
				
		    head.next = tmp.next;
				
			tmp.next = head;
			
			currentPre.next = tmp;
			
			if(pre.next == null) pre.next = tmp;
			currentPre = head;
			
			head = head.next;
			
		}
		return pre.next;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个翻转的套路需要背会了，这次是两个翻转，下次有可能是3个元素翻转，再下次有可能是从i到j的翻转。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /***
   * 此方法的内容是翻转从head开始，后面的K个元素，如果不足K个元素，则不翻转
   * @param head 开始的节点
   * @param k 后续翻转元素的个数
   * */
	public static ListNode swapPairs(ListNode head,int k) {
		ListNode returntmp = new ListNode(-1);
		returntmp.next = head;
		ListNode currentPre = returntmp;
		ListNode tmp = head;
		int i = 0;
		while(tmp.next != null) {
			i++;
			tmp = tmp.next;
		}
		
		if(i&amp;lt;k) return head;
		
		ListNode tmp2 = head;int j = 0;
		
		while(tmp2 != null &amp;amp;&amp;amp; tmp2.next != null &amp;amp;&amp;amp; j &amp;lt; k) {
			ListNode tmp3 = tmp2.next;
			tmp2.next = tmp3.next;
			tmp3.next = tmp2;
			currentPre.next = tmp3;
			tmp2= tmp2.next;
		}
		
		return returntmp.next;
		
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode24/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode24/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode23</title>
        <description>&lt;p&gt;LeetCode 23题的分析和总结：Merge k Sorted Lists&lt;/p&gt;

&lt;p&gt;LeetCode 21. Merge Two Sorted Lists ，从2到K的扩展，解法确大不一样了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 23. Merge k Sorted Lists&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们已经实现过了 Merge two Sorted Lists,使用的是while循环，直接的设置一个新的List。但是这个就有点力不从心了，因为这个K值的大小无法确定，而且寻找最小的当前节点也比较的费时。需要采用另外的策略。

利用已经有的Merge two Sorted Lists，直接的采用分治的策略，先两两合并，然后在同一的合并在一起。


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public static ListNode mergeKLists_best(ListNode[] lists){
    return partion(lists,0,lists.length-1);
}

public static ListNode partion(ListNode[] lists,int s,int e){
    if(s==e)  return lists[s];
    if(s&amp;lt;e){
        int q=s+(e-s)/2;
        ListNode l1=partion(lists,s,q);
        ListNode l2=partion(lists,q+1,e);
        return mergeTwoLists(l1,l2);
    }else
        return null;
}

public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	ListNode head = new ListNode(-1);
	ListNode tmp = head;
	while (l1 != null || l2 != null) {
		int l1v = l1 != null ? l1.val : Integer.MAX_VALUE;
		int l2v = l2 != null ? l2.val : Integer.MAX_VALUE;
		if (l1v &amp;lt; l2v) {
			tmp.next = new ListNode(l1v);
			l1 = l1.next;
		} else {
			tmp.next = new ListNode(l2v);
			l2 = l2.next;
		}
		tmp = tmp.next;
	}
	return head.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的mergeTwoLists，还可以再次的使用递归的算法合并：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//This function is from Merge Two Sorted Lists.
public static ListNode merge(ListNode l1,ListNode l2){
    if(l1==null) return l2;
    if(l2==null) return l1;
    if(l1.val&amp;lt;l2.val){
        l1.next=merge(l1.next,l2);
        return l1;
    }else{
        l2.next=merge(l1,l2.next);
        return l2;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode23/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode23/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode22</title>
        <description>&lt;p&gt;LeetCode 22题的分析和总结：22. Generate Parentheses&lt;/p&gt;

&lt;p&gt;递归&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 22. Generate Parentheses&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given n pairs of parentheses, 
write a function to generate 
all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一开始的思路是插入，寻找插入的位置：
|（|）|
|（|）|（|）|
后来代码累出来之后，错误百出。

然后还是根据规律来进行办事，参看讨论的迭代思路，真正的梳理了逻辑之后，发现解决方案，还是一如既往的好看，简练，直接。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; generateParenthesis(int n) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        backtrack(list, &quot;&quot;, 0, 0, n);
        return list;
    }
    
    public void backtrack(List&amp;lt;String&amp;gt; list, String str, int open, int close, int max){
        
        if(str.length() == max*2){
            list.add(str);
            return;
        }
        
        if(open &amp;lt; max)
            backtrack(list, str+&quot;(&quot;, open+1, close, max);
        if(close &amp;lt; open)
            backtrack(list, str+&quot;)&quot;, open, close+1, max);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;理解这个算法的一个样例：
(
((
(((
((()
((())
((()))
(()
(()(
(()()
(()())
(())
(())(
(())()
()
()(
()((
()(()
()(())
()()
()()(
()()()&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode22/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode22/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode21</title>
        <description>&lt;p&gt;LeetCode 21题的分析和总结：Merge Two Sorted Lists
链表的合并。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;LeetCode 21. Merge Two Sorted Lists&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Merge two sorted linked lists and
return it as a new list. 
The new list should be made 
by splicing together the nodes of 
the first two lists.

Example:

Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;合并单链表
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	ListNode head = new ListNode(-1);
	ListNode tmp = head;
	while (l1 != null || l2 != null) {
		int l1v = l1 != null ? l1.val : Integer.MAX_VALUE;
		int l2v = l2 != null ? l2.val : Integer.MAX_VALUE;
		if (l1v &amp;lt; l2v) {
			tmp.next = new ListNode(l1v);
			l1 = l1.next;
		} else {
			tmp.next = new ListNode(l2v);
			l2 = l2.next;
		}
		tmp = tmp.next;
	}
	return head.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/leetcode21/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/leetcode21/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>JDK7的新特性1 ForkJoinPool</title>
        <description>&lt;p&gt;JDK7的一个新特性：ForkJoinPool 很值得一说。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;ForkJoinPool，首先上代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//计算 π 的值有一个通过多项式方法，即：π = 4 * (1 - 1/3 + 1/5 - 1/7 + 1/9 - ……)，而且多项式的项数越多，计算出的 π 的值越精确
	static class PiEstimateTask extends RecursiveTask&amp;lt;Double&amp;gt; {
		private static final long serialVersionUID = 1L;
		private final long begin;
    private final long end;
    private final long threshold; // 分割任务的临界值

    public PiEstimateTask(long begin, long end, long threshold) {
        this.begin = begin;
        this.end = end;
        this.threshold = threshold;
    }

    @Override
    protected Double compute() {  // 实现 compute 方法
        if (end - begin &amp;lt;= threshold) {  // 临界值之下，不再分割，直接计算

            int sign; // 符号，多项式中偶数位取 1，奇数位取 -1（位置从 0 开始）
            double result = 0.0;
            for (long i = begin; i &amp;lt; end; i++) {
                sign = (i &amp;amp; 1) == 0 ? 1 : -1;
                result += sign / (i * 2.0 + 1);
            }
            System.out.println(Thread.currentThread()+ &quot; From: &quot;+ begin + &quot; End: &quot;+ end);
            return result * 4;
        }

        // 分割任务
        long middle = (begin + end) / 2;
        PiEstimateTask leftTask = new PiEstimateTask(begin, middle, threshold);
        PiEstimateTask rightTask = new PiEstimateTask(middle, end, threshold);

        leftTask.fork();  // 异步执行 leftTask
        rightTask.fork(); // 异步执行 rightTask

        double leftResult = leftTask.join();   // 阻塞，直到 leftTask 执行完毕返回结果
        double rightResult = rightTask.join(); // 阻塞，直到 rightTask 执行完毕返回结果

        return leftResult + rightResult; // 合并结果
    }

}
	
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ForkJoinPool pool = new ForkJoinPool();
		pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
		PiEstimateTask task = new PiEstimateTask(0, 1_000_000_000, 10_000_00);
		pool.execute(task);
		System.out.println(task.get());
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面的代码中，我们可以看到ForkJoinPool，适用的一类业务：
把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。&lt;/p&gt;

&lt;p&gt;ForkJoinPool支持的任务大类有两种，一类是：Runnable ，类似于ExecutorService。一类是ForkJoinTask。&lt;/p&gt;

&lt;p&gt;其中的ForkJoinTask代表一个可以并行、合并的任务。ForkJoinTask是一个抽象类，它还有两个抽象子类：RecusiveAction和RecusiveTask。其中RecusiveTask代表有返回值的任务，而RecusiveAction代表没有返回值的任务。&lt;/p&gt;

&lt;h3 id=&quot;代码分析&quot;&gt;代码分析&lt;/h3&gt;

&lt;p&gt;根据上面的示例代码，可以看出 fork() 和 join() 是 Fork/Join Framework “魔法”的关键。我们可以根据函数名假设一下 fork() 和 join() 的作用：&lt;/p&gt;

&lt;p&gt;fork()：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。
join()：等待该任务的处理线程处理完毕，获得返回值。&lt;/p&gt;

&lt;p&gt;并不是每个 fork() 都会促成一个新线程被创建，而每个 join() 也不是一定会造成线程被阻塞。&lt;/p&gt;

&lt;p&gt;具体的数据结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://7cn0ma.ch.files.1drv.com/y4mNHOHsW33XQdE-_tAVdUXXxwQ_eW58g3q3bzMm1EyjfJdSLcqE_9iW-a-1xdrlxMpChFZauhFFLvOzHja9ZJvzkdNTjnOnaB1lGCace0GRpTQXS-eh0rGn02i6mjSw1o4aSEILUwDCP4AJF_yDvxE8QuQ_4wZl9jkH7OmCBTMsJpgKFCz_p45Mj6O9l3cgQWZS0_FjaxTwKfLYIIrt5sVzg?width=1848&amp;amp;height=1505&amp;amp;cropmode=none&quot; alt=&quot;数据结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fork/Join Framework 的实现算法并不是那么“显然”，而是一个更加复杂的算法——这个算法的名字就叫做 work stealing 算法。&lt;/p&gt;

&lt;p&gt;ForkJoinPool 的&lt;strong&gt;每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。&lt;/p&gt;

&lt;p&gt;每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。
在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。&lt;/p&gt;

&lt;p&gt;在既没有自己的任务，也没有可以窃取的任务时，进入休眠。&lt;/p&gt;

&lt;h3 id=&quot;fork-&quot;&gt;fork() ：&lt;/h3&gt;

&lt;p&gt;做的工作只有一件事，既是把任务推入当前工作线程的工作队列里。&lt;/p&gt;
&lt;h3 id=&quot;join-&quot;&gt;join() ：&lt;/h3&gt;

&lt;p&gt;工作则复杂得多，也是 join() 可以使得线程免于被阻塞的原因——不像同名的 Thread.join()。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查调用 join() 的线程是否是 ForkJoinThread 线程。如果不是（例如 main 线程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。&lt;/li&gt;
  &lt;li&gt;查看任务的完成状态，如果已经完成，直接返回结果。&lt;/li&gt;
  &lt;li&gt;如果任务尚未完成，但处于自己的工作队列内，则完成它。&lt;/li&gt;
  &lt;li&gt;如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务（以 FIFO 方式），执行，以期帮助它早日完成欲 join 的任务。&lt;/li&gt;
  &lt;li&gt;如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务时，则找到小偷的小偷，帮助它完成它的任务。
递归地执行第5步。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所谓work-stealing模式，即每个工作线程都会有自己的任务队列。当工作线程完成了自己所有的工作后，就会去“偷”别的工作线程的任务。&lt;/p&gt;

&lt;p&gt;假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以&lt;strong&gt;为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;submit&quot;&gt;submit():&lt;/h3&gt;

&lt;p&gt;其实除了前面介绍过的每个工作线程自己拥有的工作队列以外，ForkJoinPool 自身也拥有工作队列，这些工作队列的作用是用来接收由外部线程（非 ForkJoinThread 线程）提交过来的任务，而这些工作队列被称为 submitting queue 。&lt;/p&gt;

&lt;p&gt;submit() 和 fork() 其实没有本质区别，只是提交对象变成了 submitting queue 而已（还有一些同步，初始化的操作）。submitting queue 和其他 work queue 一样，是工作线程”窃取“的对象，因此当其中的任务被一个工作线程成功窃取时，就意味着提交的任务真正开始进入执行阶段。&lt;/p&gt;

&lt;p&gt;更加详细的研究：http://gee.cs.oswego.edu/dl/papers/fj.pdf&lt;/p&gt;

&lt;h3 id=&quot;forkjoinpool与threadpoolexecutor区别&quot;&gt;ForkJoinPool与ThreadPoolExecutor区别：&lt;/h3&gt;

&lt;p&gt;1.ForkJoinPool中的每个线程都会有一个队列，而ThreadPoolExecutor只有一个队列，并根据queue类型不同，细分出各种线程池&lt;/p&gt;

&lt;p&gt;2.ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务,ThreadPoolExecutor中根本没有什么父子关系任务&lt;/p&gt;

&lt;p&gt;3.ForkJoinPool在使用过程中，会创建大量的子任务，会进行大量的gc，但是ThreadPoolExecutor不需要，因此单线程（或者任务分配平均）&lt;/p&gt;

&lt;p&gt;4.ForkJoinPool在多任务，且任务分配不均是有优势，但是在单线程或者任务分配均匀的情况下，效率没有ThreadPoolExecutor高，毕竟要进行大量gc子任务&lt;/p&gt;

&lt;p&gt;ForkJoinPool在多线程情况下，能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。&lt;/p&gt;

&lt;p&gt;ThreadPoolExecutor因为它其中的线程并不会关注每个任务之间任务量的差异。当执行任务量最小的任务的线程执行完毕后，它就会处于空闲的状态(Idle)，等待任务量最大的任务执行完毕。&lt;/p&gt;

&lt;p&gt;因此多任务在多线程中分配不均时，ForkJoinPool效率高。&lt;/p&gt;

&lt;h3 id=&quot;stream中应用forkjoinpool&quot;&gt;stream中应用ForkJoinPool&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;)
                .parallelStream()
                .filter(s -&amp;gt; {
                    System.out.format(&quot;filter: %s [%s]\n&quot;,
                            s, Thread.currentThread().getName());
                    return true;
                })
                .map(s -&amp;gt; {
                    System.out.format(&quot;map: %s [%s]\n&quot;,
                            s, Thread.currentThread().getName());
                    return s.toUpperCase();
                })
                .sorted((s1, s2) -&amp;gt; {
                    System.out.format(&quot;sort: %s &amp;lt;&amp;gt; %s [%s]\n&quot;,
                            s1, s2, Thread.currentThread().getName());
                    return s1.compareTo(s2);
                })
                .forEach(s -&amp;gt; System.out.format(&quot;forEach: %s [%s]\n&quot;,
                        s, Thread.currentThread().getName()));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;parallelStream让部分Java代码自动地以并行的方式执行&lt;/p&gt;

&lt;p&gt;最后：&lt;/p&gt;

&lt;p&gt;有一点要注意，就是手动设置ForkJoinPool的线程数量时，实际线程数为设置的线程数+1，因为还有一个main主线程&lt;/p&gt;

&lt;p&gt;即使将ForkJoinPool的通用线程池的线程数量设置为1，实际上也会有2个工作线程。因此线程数为1的ForkJoinPool通用线程池和线程数为2的ThreadPoolExecutor是等价的。&lt;/p&gt;

&lt;p&gt;与ForkJoinPool对应的是CompletableFuture&lt;/p&gt;

&lt;p&gt;Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。
阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果&lt;/p&gt;

&lt;p&gt;CompletableFuture就是利用观察者设计模式当计算结果完成及时通知监听者
在Java 8中, 新增加了一个包含50个方法左右的类: CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/15/day5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/15/day5/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
  </channel>
</rss>
