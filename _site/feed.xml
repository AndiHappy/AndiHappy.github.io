<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 13 Sep 2019 23:43:29 +0800</pubDate>
    <lastBuildDate>Fri, 13 Sep 2019 23:43:29 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>LeetCode 33. Search in Rotated Sorted Array</title>
        <description>&lt;p&gt;LeetCode 33. Search in Rotated Sorted Array&lt;/p&gt;

&lt;p&gt;从根本上面说，这个数据很有意思，只是正常的数据进行的一次转换，我们需要的就是怎么转换回来，或者说在经典的算法中，下标计算的时候，怎么能够不受这次转换的影响。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;既然是有一段数据被翻转回到了数据的开头，那我们怎么能够比较巧妙的翻转回去尼？

i = (i + k) % n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int search(int A[], int n, int target) {
  int lo = 0, hi = n - 1;
  //！！！寻找折点的算法也是折半查找！！！
  while (lo &amp;lt; hi) {
   int mid = (lo + hi) / 2;
   if (A[mid] &amp;gt; A[hi])
    lo = mid + 1;
   else
    hi = mid;
  }


  int rot = lo;
  lo = 0;
  hi = n - 1;

  while (lo &amp;lt;= hi) {
   int mid = (lo + hi) / 2;
   //最关键的一句，说明了，这个题目看数据的方式
   int realmid = (mid + rot) % n;
   if (A[realmid] == target)
    return realmid;
   if (A[realmid] &amp;lt; target)
    lo = mid + 1;
   else
    hi = mid - 1;
  }
  return -1;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode33/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode33/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 32. Longest Valid Parentheses</title>
        <description>&lt;p&gt;LeetCode 32. Longest Valid Parentheses
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: &quot;(()&quot;
Output: 2
Explanation: The longest valid parentheses substring is &quot;()&quot;
Example 2:

Input: &quot;)()())&quot;
Output: 4
Explanation: The longest valid parentheses substring is &quot;()()&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 1. 首先理解题意是关键的步骤：挑选可以使用的括号规则，如下的规则
 * 
 * ()(() 计算值为2
 * ()()) 计算值为4
 * 
 * 2. 理解了题意之后，就是梳理具体的逻辑
 * 
 * 采用栈的的数据结构，来匹配右括号与左括号的匹配的规则
 * 左括号则入栈，右括号需要处理的逻辑是：
 * 匹配或者不匹配的情况
 *   如果是匹配的情况，那么需要把匹配的左括号出栈，然后根据出栈后的情况：
 *   如果还有内容，没有匹配完呢，直接的更新数据。
 *   如果栈内没有了内容，需要计算最大的长度。
 * 
 * 	 如果是不匹配的情况，右括号不匹配的情况，就是直接的丢弃。判断这个时候的栈内元素为空，并且更新最大长度的开始的值。
 * 			
 * */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int longestValidParentheses_copy(String s) {
  int n = s.length(), longest = 0;
  //记录遍历过程中s的下标的值
  Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;Integer&amp;gt;();
  
  for (int i = 0; i &amp;lt; n; i++) {
      if (s.charAt(i) == '(') {
       st.push(i);
      }else {
          if (!st.empty() &amp;amp;&amp;amp; s.charAt(st.peek()) == '(') {
           st.pop();
          }else {
           st.push(i);
          }
      }
  }
  
  if (st.empty()) longest = n;
  else {
      int a = n, b = 0;
      while (!st.empty()) {
          b = st.peek(); st.pop();
          longest = Math.max(longest, a-b-1);
          a = b;
      }
      longest = Math.max(longest, a);
  }
  return longest;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方案，可以比较清晰的看到，解题的思路，但是可能清晰的看到优化的空间，因为后面遍历stack的过程，可以融合在第一次遍历s的过程中。就如思路中所描述的那样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int longestValidParentheses(String s) {
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;();
        int max=0;
        // 匹配开始的节点
        int left = -1;//设想是(),匹配结束的i应该是1，则1-（-1） = 2 
        for(int j=0;j&amp;lt;s.length();j++){
            if(s.charAt(j)=='(') stack.push(j);
            else {
                if (stack.isEmpty()) left=j;
                else{
                    stack.pop();
                    if(stack.isEmpty()) max=Math.max(max,j-left);
                    else max=Math.max(max,j-stack.peek());
                }
            }
        }
        return max;
    }

System.out.println(longestValidParentheses(&quot;()(()&quot;)); //2
System.out.println(longestValidParentheses(&quot;)()())&quot;));//4
System.out.println(longestValidParentheses1(&quot;()(()&quot;)); //2
System.out.println(longestValidParentheses1(&quot;)()())&quot;));//4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode32/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode32/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 31. nextPermutation</title>
        <description>&lt;p&gt;LeetCode 31.nextPermutation&lt;/p&gt;

&lt;p&gt;题目一开始完全没有看懂，也不知道什么是next Permutation。知道排列，但是不知道next Permutation 是什么。这道题目的难点，全部的在于理解题意，并且找到翻转的规律。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:

Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input:
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
Output: []

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I don't think any one can understand this solution without seeing an example, 
here is an example:
2,3,6,5,4,1

Solution:
Step1, from right to left, 
find the first number which not increase in a ascending order. 
In this case which is 3.

Step2, here we can have two situations:

We cannot find the number, 
all the numbers increasing in a ascending order. 
This means this permutation is the last permutation,
 we need to rotate back to the first permutation. 
 So we reverse the whole array, 
 for example, 6,5,4,3,2,1 we turn it to 1,2,3,4,5,6.

We can find the number, then the next step, 
we will start from right most to leftward, 
try to find the first number which is larger than 3, 
in this case it is 4.
Then we swap 3 and 4, the list turn to 2,4,6,5,3,1.
Last, we reverse numbers on the right of 4,
we finally get 2,4,1,3,5,6.

Time complexity is: O(3*n)=O(n).

At the end, I don't know how to come up this solution. Here is just to understand the solution with example. Hope this helps.


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void nextPermutation(int[] nums) {
      int n = nums.length - 1, p = -1, pv = 0;

      for(int i = n - 1; i &amp;gt;= 0; i--){
        if(nums[i] &amp;lt; nums[i + 1]) {
            p = i;
            pv = nums[i];
            break;
        }
      }    
      
      if(p == -1) {
        reverse(nums, 0, n);
        return;
      }
      
      for(int i = n; i &amp;gt;= 0; i--){
        if(nums[i] &amp;gt; pv){
          swap(nums, p, i);
          break;
        }
      }
      
      reverse(nums, p + 1, n);
    }
    
    void reverse(int[] nums, int s, int e){
      while(s &amp;lt; e){
        swap(nums, s, e);
        s++;
        e--;
      }
    }
    
    void swap(int[] nums, int s, int e){
        int t = nums[s];
        nums[s] = nums[e];
        nums[e] = t;     
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode31/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode31/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：3. 通过具体的应用展示锁的实现机制</title>
        <description>&lt;p&gt;上一节关于AQS的锁的架构实现，说的非常的抽象，看的非常的费劲，这次通过代码的注释和说明，来展示具体是如何实现的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;reentrantlock&quot;&gt;ReentrantLock&lt;/h2&gt;

&lt;p&gt;关于可重入锁带着两个问题，去分析的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;怎么判断的重入，如何增加锁的次数的。&lt;/li&gt;
  &lt;li&gt;重入次数的判断，释放锁的时候，如果消减锁的次数，释放以后，其他的等待的线程是如何响应的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reentrantlock-lock-方法&quot;&gt;ReentrantLock lock 方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ReentrantLock() {
	sync = new NonfairSync();
}
public void lock() {
	sync.lock();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;符合使用框架的时候，都采用内部类NonfairSync来实现实现的需要实现的接口，这点也符合DOC的说明。&lt;/p&gt;

&lt;p&gt;NonfairSync 的实现逻辑如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static final class NonfairSync extends Sync {
  /**
   * so beautiful ！ 整个操作如此的不见烟火气：
   *
   * ①首先是CAS(state,1) 确定是否已经有线程抢占到锁，然后设置：ExclusiveThread（这个是普通的成员变量）,返回true；
   *  
   * 然后是：Acquire(1),更新state为1，
   * 
   * 具体的逻辑： !tryAcquire(1) =&amp;gt; acquireQueued(addWaiter(Node.EXCLUSIVE), 1)) =&amp;gt;selfInterrupt()
   * 
   * 根据getState的状态进行判断： 
   *    如果是0，说明原来的线程已经释放锁，重新的走① 
   *    如果大于零，当前的线程（Thread.concurrent）和 ExclusiveOwnerThread 进行比较 
   *              如果是独占线程为当前线程，则state+1，返回true; 如果不是，则返回false
   * 
   * 只有在返回false的前提下，才会执行：addWaiter(Node.EXCLUSIVE), 1)，
   */
  final void lock() {
   // 只是使用一个CAS的操作，就保证了线程抢占的唯一性
   if (compareAndSetState(0, 1))
    // private transient Thread exclusiveOwnerThread; 可以说只是一个普通的成员变量
    setExclusiveOwnerThread(Thread.currentThread());
   else
    // 如果是同一个线程，则去更新状态为1，如果不是当前的线程，会被阻塞的
    acquire(1);
  }

  protected final boolean tryAcquire(int acquires) {
   return nonfairTryAcquire(acquires);
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ReentrantLock的lock方法，其实默认的调用的就是 NonfairSync的lock方法，也就是说默认的是非公屏锁。这里就产生了一个问题：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;为什么是非公平的，和公平的差在什么地方？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后具体的流程就是CAS后，设置独占线程，Note：这个独占线程为普通的成员变量。&lt;/p&gt;

&lt;p&gt;再次就是acquire(1) ,这个方法其实调用的是AQS中的那个经典的方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//独占模式下的获取锁
 public final void acquire(int arg) {
  if (!tryAcquire(arg) &amp;amp;&amp;amp; // tryAcquire 为子类必须实现的方法，提供扩展的逻辑
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 获取锁失败以后
   selfInterrupt();
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的tryAcquire方法，就是在NonfairSync 继承的 Sync 中实习。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
   * 非公平获取锁 ！！！重要的框架！！！
   */
  final boolean nonfairTryAcquire(int acquires) {
   final Thread current = Thread.currentThread();
   int c = getState();
   if (c == 0) {
    if (compareAndSetState(0, acquires)) {
     setExclusiveOwnerThread(current);
     return true;
    }
   } else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc &amp;lt; 0) // overflow
     throw new Error(&quot;Maximum lock count exceeded&quot;);
    setState(nextc);
    return true;
   }
   return false;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先没有判断是否是独占线程，而是首先判断的state的状态！根据state的状态，进行二次的CAS操作。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果首先判断是否是独占线程，是否有问题？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后再去判断是否是独占线程，如果是，则去更新state的状态。&lt;/p&gt;

&lt;p&gt;返回以后，则进入AQS的框架中，如果没有抢到锁，则进入等待的队列，这里需要说一下这个等待的队列的加入函数：addWaiter&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 独占性的节点和共享性的节点，加入等待的链表中
 private Node addWaiter(Node mode) {
  Node node = new Node(Thread.currentThread(), mode);
  // Try the fast path of enq; backup to full enq on failure
  Node pred = tail;
  if (pred != null) {
   node.prev = pred;
   if (compareAndSetTail(pred, node)) {//相当于 tail=(pre==tail)?node:pre
    pred.next = node;
    return node;
   }

   /**
    *   head(new Node()) &amp;lt;----Thread[Thread-1] &amp;lt;---- Thread[Thread-2] &amp;lt;---- Thread[Thread-3](tail)
    *  相当于把node节点插入到队尾。
    *  Node node = new Node()
    *  Node pred = tail;
    *  node.prev = pred;
    *  tail = node;
    *  pred.next = node;
    * */
  }
  // 设置失败之后，进入enq，enq为for的无线循环的模式
  enq(node);
  return node;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的注释可以比较清楚明白的说明，线程排队的数据结构。其中的enq也是tail为null的时候的，初始化操作。&lt;/p&gt;

&lt;p&gt;然后就是更新线程队列的状态（我们现在只讨论比较普通的状况，特殊的等到遇见了在进行说明），以及怎么让线程“停下来”：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
  boolean failed = true;
  try {
   boolean interrupted = false;
   for (;;) {
    //Node 的 prev 成员变量
    final Node p = node.predecessor();
    // 再次去检查，是否有机会获取锁
    if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
     setHead(node);
     p.next = null; // help GC
     failed = false;
     return interrupted;
    }
    if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; parkAndCheckInterrupt())
     interrupted = true;
   }
  } finally {
   if (failed)
    cancelAcquire(node);
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再去更新等待队列线程节点Node的状态的时候，还是首先的去尝试获取锁，当然这个尝试是有条件的，那就是：&lt;code class=&quot;highlighter-rouge&quot;&gt;node.predecessor() == head&lt;/code&gt; 这个条件就是说明，node的前一个节点就是头结点，在等待队列初始化的时候，我们已经知道头结点只是一个“象征节点”，是没有对应线程的。所以如果满足条件，那么这个就应该是争抢锁的下一个节点。&lt;/p&gt;

&lt;p&gt;如果不满足条件，则会调用：&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldParkAfterFailedAcquire&lt;/code&gt; 这个就是线程对应的链表状态的更新：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
   /*
    * This node has already set status asking a release
    * to signal it, so it can safely park.
    */
   return true;
  if (ws &amp;gt; 0) {
   /*
    * Predecessor was cancelled. Skip over predecessors and
    * indicate retry.
    */
   do {
    node.prev = pred = pred.prev;
   } while (pred.waitStatus &amp;gt; 0);
   pred.next = node;
  } else {
   /*
    * waitStatus must be 0 or PROPAGATE.  Indicate that we
    * need a signal, but don't park yet.  Caller will need to
    * retry to make sure it cannot acquire before parking.
    */
   /**
    * 这句是pre设置为了Node.SIGNAL状态:
    * 待唤醒后继状态，当前节点的线程处于此状态，后继节点会被挂起，当前节点释放锁或取消之后必须唤醒它的后继节点。
    * */
   compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里注意一下：
&lt;code class=&quot;highlighter-rouge&quot;&gt;acquireQueued&lt;/code&gt; 是一个无限的for循环结构，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldParkAfterFailedAcquire&lt;/code&gt; 可能会被调用很多次。所以一般的会被调用两次，第一次，因为新建的Node节点，waitStatus 就是默认值0，所以如果下载再有阻塞节点的时候，
&lt;code class=&quot;highlighter-rouge&quot;&gt;node.pre == 0&lt;/code&gt;
都会先把前驱节点设置为：Node.SIGNAL，也就是调用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;compareAndSetWaitStatus(pred, ws, Node.SIGNAL)&lt;/code&gt;
然后下次acquireQueued的for循环里面，再次判断的时候&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;node.pre 就等于 Node.SIGNAL&lt;/code&gt;
然后shouldParkAfterFailedAcquire，返回了true。&lt;/p&gt;

&lt;p&gt;轮到了函数：&lt;code class=&quot;highlighter-rouge&quot;&gt;parkAndCheckInterrupt&lt;/code&gt; 这个方法很有意思：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final boolean parkAndCheckInterrupt() {
  LockSupport.park(this);
  return Thread.interrupted();
 }

// LockSupport 的park方法
 public static void park(Object blocker) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(false, 0L);
        setBlocker(t, null);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里涉及到一个挺有意思的工具类：LockSupport，我们最基础的和工具类了，这个类的详细我们会面会说，只说一下其支持的两个方法的特点：&lt;/p&gt;

&lt;p&gt;java.util.concurrent.locks.LockSupport.park(Object object)
暂停当前的线程,在缺乏凭证的前提下，会一直的:the current thread becomes disabled for thread scheduling&lt;/p&gt;

&lt;p&gt;java.util.concurrent.locks.LockSupport.unpark(Thread thread)
给与参数中的Thread中的凭证，也就是立刻的唤醒对应的线程。&lt;/p&gt;

&lt;p&gt;另外还有一点，unpark可以在 park之前调用，这样就不必担心漏掉“凭证”。具体的测试代码见：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) throws InterruptedException {

  Thread test1 = new Thread(new Runnable() {
   @Override
   public void run() {

    try {
     Thread.sleep(1000);
    } catch (InterruptedException e) {
    }
    System.out.println(&quot;park before !&quot;);
    LockSupport.park(&quot;&quot;);
    System.out.println(&quot;park after !&quot;);
   }
  });
  
  test1.start();

  LockSupport.unpark(test1);
  System.out.println(&quot;Call unpark first&quot;);

  Thread.sleep(1000);
  System.out.println(&quot;Thread.state: &quot; + test1.getState().name());

 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后回到&lt;code class=&quot;highlighter-rouge&quot;&gt;parkAndCheckInterrupt&lt;/code&gt; 方法，则等待的队列中的线程，算是真正的在等待着了。后面的只有等待别的线程释放锁以后，才能够运行了，我们接着看realease方法。&lt;/p&gt;

&lt;h3 id=&quot;reentrantlock-unlock-方法&quot;&gt;ReentrantLock unlock 方法&lt;/h3&gt;

&lt;p&gt;unlock 方法和lock的方法，又有很大的不同，因为lock方法一开始调用的时候，也就是一开始执行CAS代码的时候，是可能多个线程同时执行，但是unlock方法，在一开始的时候，只有拥有锁的方法，才去调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void unlock() {
  sync.release(1);
 }

 //sync.release方法，直接进入AQS的框架

 /**
  * 释放锁的框架：tryRelease(int arg) 有子类进行实现
  * 如果释放成功，则去通知等待的线程
  * */
 public final boolean release(int arg) {
  if (tryRelease(arg)) {
   Node h = head;
   //如果存在等待的线程：Wait queue中有值，根据我们先前的AddWaiter和shouldParkAfterFailedAcquire 逻辑
   // head 应该是new Node(),并且 waitStatus 为 Signal状态
   if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
    unparkSuccessor(h);
   return true;
  }
  return false;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们还是按照原来的流程，先去关注Sync实现的子类方法tryRelease：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /**
   * 释放的时候，肯定是获得锁的线程进行调用，所以不需要CAS之类的操作，只需要判定状态即可
   */
  protected final boolean tryRelease(int releases) {
   int c = getState() - releases;
   if (Thread.currentThread() != getExclusiveOwnerThread())
    throw new IllegalMonitorStateException();
   boolean free = false;
   if (c == 0) {
    free = true;
    setExclusiveOwnerThread(null);
   }
   setState(c);
   return free;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先是状态检查，然后根据state的值，判断锁释放是否成功，可以说这段的代码就是单线程在执行，不用担心线程安全的问题。&lt;/p&gt;

&lt;p&gt;然后就是 release方法中的 再次争抢锁的过程了，这里面有一个比较重要的看点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void unparkSuccessor(Node node) {
  // 把当Node节点（head节点），设置为了状态0
  int ws = node.waitStatus;
  if (ws &amp;lt; 0)
   compareAndSetWaitStatus(node, ws, 0);

  //根据状态，获得最近的可以被唤醒的线程节点
  Node s = node.next;
  if (s == null || s.waitStatus &amp;gt; 0) {
   s = null;
   for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
    if (t.waitStatus &amp;lt;= 0)
     s = t;
  }
  if (s != null)
   LockSupport.unpark(s.thread);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法有意思的一点就是，是和shouldParkAfterFailedAcquire 相对应的，shouldParkAfterFailedAcquire 把自己的pre Node 设置为Node.SIGNAL 状态，而unparkSuccessor 把Node 设置为原来的0 状态。&lt;/p&gt;

&lt;p&gt;然后调用：
 &lt;code class=&quot;highlighter-rouge&quot;&gt;LockSupport.unpark(s.thread)&lt;/code&gt; 
唤醒队列中最先等待的线程，让它去抢锁。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这不看起来挺公平的吗？为什么叫做：NonfairSync，难道有锁的时候，大家一起抢，才算作是公平吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在来看一下，公平锁是怎么实现的，公平又是如何体现的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static final class FairSync extends Sync {
  private static final long serialVersionUID = -3000897897090466540L;

  final void lock() {
   acquire(1);
  }

  /**
   * Fair version of tryAcquire.  Don't grant access unless
   * recursive call or no waiters or is first.
   */
  protected final boolean tryAcquire(int acquires) {
   final Thread current = Thread.currentThread();
   int c = getState();
   if (c == 0) {
    if (!hasQueuedPredecessors() &amp;amp;&amp;amp; compareAndSetState(0, acquires)) {
     setExclusiveOwnerThread(current);
     return true;
    }
   } else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc &amp;lt; 0)
     throw new Error(&quot;Maximum lock count exceeded&quot;);
    setState(nextc);
    return true;
   }
   return false;
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;两点比较重要：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;没有单独的实现realease方法，说明在释放锁的逻辑上和非公平锁的逻辑是一样的，都是释放锁成功后，唤醒等待链表中，等待时间最长的那个。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;lock 方法上面有差别，公平锁上来就是acquire(1),然后在tryAcquire方法中，增加了一个!hasQueuedPredecessors 的判断。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中hasQueuedPredecessors代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean hasQueuedPredecessors() {
  Node t = tail; // Read fields in reverse initialization order
  Node h = head;
  Node s;
  return h != t &amp;amp;&amp;amp; ((s = h.next) == null || s.thread != Thread.currentThread());
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;tail != head 好理解，意思是有线程在排队
(s = h.next) == null || s.thread != Thread.currentThread() 排队的线程不是当前线程&lt;/p&gt;

&lt;p&gt;到了这里公平锁的逻辑就算理清楚了，它是在抢锁的时候，保证公平，如果有等待队列的时候，新进来的线程，首先会进行：!hasQueuedPredecessors，立马回返回false，因为存在等待的线程，并且当前的等待激活的线程不是当前的线程，就会立即的进入等待线程中等待。&lt;/p&gt;

&lt;p&gt;但是被唤醒的线程，就会因为当前的等待激活的线程就是当前的线程
，而去执行&lt;code class=&quot;highlighter-rouge&quot;&gt;compareAndSetState(0, acquires)&lt;/code&gt; 才有可能抢到锁。&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/20/concurrent-4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/20/concurrent-4/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 30. Substring with Concatenation of All Words</title>
        <description>&lt;p&gt;LeetCode 30. Substring with Concatenation of All Words&lt;/p&gt;

&lt;p&gt;hard&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 30. Substring with Concatenation of All Words&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:

Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input:
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
Output: []

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先是words的定长，这个在匹配的时候，
肯定更加的好判断一点，还有就是题目中没有明确说明的重复出现的单词的现象，
需要考虑一下。可以采用Map的数据结构存储，key为单词，value为单词出现的
次数。

对于匹配的元素，再次的采用map数据记录。
根据匹配的个数是否与words的length值相等来判断是否，匹配成功。

对字符串进行遍历操作，每次的i，都要进行words的匹配的校验
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;Integer&amp;gt; findSubstring(String s, String[] words) {
        final Map&amp;lt;String, Integer&amp;gt; counts = new HashMap&amp;lt;&amp;gt;();
        for (final String word : words) {
            counts.put(word, counts.getOrDefault(word, 0) + 1);
        }

        final List&amp;lt;Integer&amp;gt; indexes = new ArrayList&amp;lt;&amp;gt;();
        final int n = s.length(), num = words.length, len = words[0].length();
        for (int i = 0; i &amp;lt; n - num * len + 1; i++) {
            final Map&amp;lt;String, Integer&amp;gt; seen = new HashMap&amp;lt;&amp;gt;();
            int j = 0;
            while (j &amp;lt; num) {
                final String word = s.substring(i + j * len, i + (j + 1) * len);
                if (counts.containsKey(word)) {
                    seen.put(word, seen.getOrDefault(word, 0) + 1);
                    if (seen.get(word) &amp;gt; counts.getOrDefault(word, 0)) {
                        break;
                    }
                } else {
                    break;
                }
                j++;
            }
            if (j == num) {
                indexes.add(i);
            }
        }
        return indexes;
    }	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 19 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/19/leetcode30/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/19/leetcode30/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 29. Divide Two Integers</title>
        <description>&lt;p&gt;LeetCode 29 题的分析和总结：  29. Divide Two Integers&lt;/p&gt;

&lt;p&gt;迭代循环&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 29. Divide Two Integers&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;迭代逻辑，不使用乘除，取余的计算，我们还可以使用加法，位移运算等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public int divide_copy(int dividend, int divisor) {
    if (dividend == Integer.MIN_VALUE &amp;amp;&amp;amp; divisor == -1) {
        return Integer.MAX_VALUE;
    }

    if (dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0) {
        return divideHelper(-dividend, -divisor);
    } else if (dividend &amp;gt; 0) {
        return -divideHelper(-dividend, divisor);
    }
    else if(divisor &amp;gt; 0) {
        return -divideHelper(dividend, -divisor);
    }
    else {
        return divideHelper(dividend, divisor);
    }
}

private int divideHelper(int dividend, int divisor){
    int res = 0;
    int currentDivisor = divisor;
    while(dividend&amp;lt;=divisor){    // abs(divisor) &amp;lt;= abs(dividend)
    	
        int temp = 1;  
        //test max temp for: temp * abs(divisor) &amp;lt;= abs(dividend), while temp = 2^n
        while( (currentDivisor &amp;lt;&amp;lt; 1) &amp;gt;=dividend &amp;amp;&amp;amp; (currentDivisor &amp;lt;&amp;lt; 1) &amp;lt;0 ){  
            temp &amp;lt;&amp;lt;=1;
            currentDivisor &amp;lt;&amp;lt;=1;
        }
        
        dividend -= currentDivisor;  
        res += temp;    
        currentDivisor = divisor;
    }       
    return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本来还有一个采用加法循环res的值，但是如果是除以1的话，会有超时的问题，所以才有了位移的操作。关于这个为什么是负数的操作，下面有一个正数的操作，但是报错了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public int divide(int dividend, int divisor) {
		//首先判定符号的问题
		boolean flag = (dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0) || (dividend &amp;lt; 0 &amp;amp;&amp;amp; divisor &amp;lt; 0);
		int dividends = 0;
		int divisors = 0;
		if (dividend == Integer.MIN_VALUE) dividend = Integer.MAX_VALUE;
		if (divisor == Integer.MIN_VALUE) divisor = Integer.MAX_VALUE;
		
		dividends = dividend &amp;gt; 0 ? dividend : -dividend;
		divisors = divisor &amp;gt; 0 ? divisor : -divisor;
		
		int res = 0;int curdivisors = divisors;
		while (dividends - divisors &amp;gt;= 0) {
			int tmp = 1;
			while( (divisors &amp;lt;&amp;lt; 1 &amp;lt;= dividends) &amp;amp;&amp;amp; (divisors &amp;lt;&amp;lt; 1) &amp;gt; 0 ) {
				tmp &amp;lt;&amp;lt;=1;
				divisors &amp;lt;&amp;lt;=1;
			}
			
			res+=tmp;
			dividends -= divisors;
			divisors = curdivisors;
		}
		return flag ? res : -res;
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;错误的测试用例是：
-2147483648 1&lt;/p&gt;

&lt;p&gt;错误的根由在于 (Integer.MAX_VALUE），(Integer.MIN_VALUE) 一个是 -2147483648，一个是2147483647，这道题目下，如果不使用Long值，修改为负数比较合适。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    		public int divide(int dividend, int divisor) {
		//首先判定符号的问题
		boolean flag = (dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0) || (dividend &amp;lt; 0 &amp;amp;&amp;amp; divisor &amp;lt; 0);

		int dividends = dividend &amp;gt; 0 ? -dividend : dividend;
		int divisors = divisor &amp;gt; 0 ? -divisor : divisor;
		
		int res = 0;int curdivisors = divisors;
		while (dividends &amp;lt;= divisors) {
			int tmp = 1;
			while( (divisors &amp;lt;&amp;lt; 1 &amp;gt;= dividends) &amp;amp;&amp;amp; (divisors &amp;lt;&amp;lt; 1) &amp;lt; 0 ) {
				tmp &amp;lt;&amp;lt;=1;
				divisors &amp;lt;&amp;lt;=1;
			}
			
			res+=tmp;
			dividends -= divisors;
			divisors = curdivisors;
		}
			return flag ? res==Integer.MIN_VALUE?Integer.MAX_VALUE:res : -res;

	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode29/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode29/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode28   Implement strStr()</title>
        <description>&lt;p&gt;LeetCode 28 题的分析和总结：  Implement strStr()&lt;/p&gt;

&lt;p&gt;字符串操作&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 28. Implement strStr()&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
Output: 2
Example 2:

Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;needle 为null的时候，返回的是0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int strStr(String haystack, String needle) {
		if (needle == null || &quot;&quot;.equals(needle))
			return 0;
		char[] haystackc = haystack.toCharArray();
		char[] neddlec = needle.toCharArray();
		for (int i = 0; i &amp;lt; haystackc.length - neddlec.length + 1; i++) {
			char hc = haystackc[i];
			if (hc == neddlec[0]) {
				if (meetCondition(haystackc, i + 1, neddlec, 1)) {
					return i;
				}
			}
		}

		return -1;
	}

private boolean meetCondition(char[] haystackc, int i, char[] neddlec, int j) {
	for (; j &amp;lt; neddlec.length &amp;amp;&amp;amp; i &amp;lt; haystackc.length; j++, i++) {
		if (neddlec[j] != haystackc[i]) {
			return false;
		}
	}
	return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JAVA 的JDK里面的 String的API方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public int indexOf(String str) {
        return indexOf(str, 0);
    }

	public int indexOf(String str, int fromIndex) {
        return indexOf(value, 0, value.length,
                str.value, 0, str.value.length, fromIndex);
    }

	 /**
     * Code shared by String and StringBuffer to do searches. The
     * source is the character array being searched, and the target
     * is the string being searched for.
     *
     * @param   source       the characters being searched.
     * @param   sourceOffset offset of the source string.
     * @param   sourceCount  count of the source string.
     * @param   target       the characters being searched for.
     * @param   targetOffset offset of the target string.
     * @param   targetCount  count of the target string.
     * @param   fromIndex    the index to begin searching from.
     */
    static int indexOf(char[] source, int sourceOffset, int sourceCount,
            char[] target, int targetOffset, int targetCount,
            int fromIndex) {
        if (fromIndex &amp;gt;= sourceCount) {
            return (targetCount == 0 ? sourceCount : -1);
        }
        if (fromIndex &amp;lt; 0) {
            fromIndex = 0;
        }
        if (targetCount == 0) {
            return fromIndex;
        }

        char first = target[targetOffset];
        int max = sourceOffset + (sourceCount - targetCount);

        for (int i = sourceOffset + fromIndex; i &amp;lt;= max; i++) {
            /* Look for first character. */
            if (source[i] != first) {
                while (++i &amp;lt;= max &amp;amp;&amp;amp; source[i] != first);
            }

            /* Found first character, now look at the rest of v2 */
            if (i &amp;lt;= max) {
                int j = i + 1;
                int end = j + targetCount - 1;
                for (int k = targetOffset + 1; j &amp;lt; end &amp;amp;&amp;amp; source[j]
                        == target[k]; j++, k++);

                if (j == end) {
                    /* Found whole string. */
                    return i - sourceOffset;
                }
            }
        }
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;总感觉JDK的代码写的比较的优雅一些，到底是哪里比较好尼？
首先是参数名称的定义：
char[] source 
char[] target 
这两个就不说了，关键是sourceOffset，sourceCount，targetOffset，targetCount和fromIndex 定义的比较的赏心悦目。
另外就是整个算法的逻辑比较清晰，首先异常处理，然后确定首次的匹配开始i，然后i之后的判断。还有一点就是缩写的使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; while (++i &amp;lt;= max &amp;amp;&amp;amp; source[i] != first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int k = targetOffset + 1; j &amp;lt; end &amp;amp;&amp;amp; source[j]== target[k]; j++, k++);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode28/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode28/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode27  Remove Element</title>
        <description>&lt;p&gt;LeetCode 27 题的分析和总结： Remove Element&lt;/p&gt;

&lt;p&gt;数组操作&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 26.  Remove Element&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example 1:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;看明白题目的意思，即可。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public int removeElement(int[] nums, int val) {
		int m = 0;
		for (int i : nums) {
			if (i != val) {
				nums[m] = i;
				m++;
			}
		}
		return m;
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode27/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode27/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode26  Remove Duplicates from Sorted Array</title>
        <description>&lt;p&gt;LeetCode 26 题的分析和总结： Remove Duplicates from Sorted Array&lt;/p&gt;

&lt;p&gt;数组操作&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 26.  Remove Duplicates from Sorted Array&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关键在于 in-place 操作，但是反过来想， in-place 操作也是算法提示的一种。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int removeDuplicates(int[] nums) {

	public int removeDuplicates(int[] nums) {
		if(nums == null || nums.length &amp;lt;2) return nums.length;
		int key = nums[0],cur = 1;
		for (int current = 1; current &amp;lt; nums.length; current++) {
			if(nums[current] != key){
				nums[cur] = nums[current];
				++cur;
				key = nums[current];
			}
		}
		return cur;
	}     
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在比较一下标准的简练答案：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int removeDuplicates(int[] A) {
    if (A.length&amp;lt;=1) return nums.length;
    int j=0;
    for (int i=0; i&amp;lt;A.length; i++)
        if (A[i]!=A[j]) A[++j]=A[i];
    return ++j;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/18/leetcode26/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/18/leetcode26/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：2. Lock</title>
        <description>&lt;p&gt;java.util.concurrent.locks.Lock 为一个接口，围绕着这个接口实现了一些列的锁。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;lock&quot;&gt;Lock&lt;/h2&gt;

&lt;p&gt;Lock接口和Condition接口的均为锁相关的两个接口，具体的说明：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a ReadWriteLock.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其声明的接口为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Lock {

    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();

    /**
     Returns a new Condition instance that is bound to this Lock instance.
     Before waiting on the condition the lock must be held by the current thread.
     A call to Condition.await() will atomically release the lock before waiting 
     and re-acquire the lock before the wait returns.
     */
    Condition newCondition();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Condition的实例绑定在Lock实例上，只有当前的线程拿到了锁以后，才能够调用Condition的wait方法。调用了condition的await()方法，会自动的释放锁。wait结束以后，会重新的获得这个锁。类似synchronized里面 object.wait()方法。&lt;/p&gt;

&lt;h2 id=&quot;锁的实现的基础aqs&quot;&gt;锁的实现的基础：AQS&lt;/h2&gt;

&lt;p&gt;说起来锁的实现就必须要说：AQS。AQS是用来构建锁和其他同步组件的基础框架，它也是Java三大并发工具类（CountDownLatch、CyclicBarrier、Semaphore）的基础。ReentrantLock，甚至BlockingQueue也是基于它的实现，可以说是非常重要了。&lt;/p&gt;

&lt;p&gt;简单介绍一下，AQS其实就是一个类，全称是AbstractQueuedSynchronizer，队列同步器。&lt;/p&gt;

&lt;p&gt;想要了解AQS，那就先仔细的阅读DOC。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState(), setState(int) and compareAndSetState(int, int) is tracked with respect to synchronization.
依赖FIFO的等待队列，实现了一个针对阻塞锁和同步器的框架。
使用一个 atomic int value 来标识状态。

Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly(int) that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods.
子类一般的采用非public的内部类的形式来实现需要满足同步特性的方法。

This class supports either or both a default exclusive mode and a shared mode. When acquired in exclusive mode, attempted acquires by other threads cannot succeed. Shared mode acquires by multiple threads may (but need not) succeed. This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well. Threads waiting in the different modes share the same FIFO queue. Usually, implementation subclasses support only one of these modes, but both can come into play for example in a ReadWriteLock. Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode.

这个类提供了两种模式：独占和共享。一般来说子类只使用一种模式，
但是ReadWriteLock是两种模式共存的。

This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively() reports whether synchronization is exclusively held with respect to the current thread, method release(int) invoked with the current getState() value fully releases this object, and acquire(int), given this saved state value, eventually restores this object to its previous acquired state. No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of AbstractQueuedSynchronizer.ConditionObject depends of course on the semantics of its synchronizer implementation.
这个类还提供了一个Condition类。

This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects. These can be exported as desired into classes using an AbstractQueuedSynchronizer for their synchronization mechanics.

Serialization of this class stores only the underlying atomic integer maintaining state, so deserialized objects have empty thread queues. Typical subclasses requiring serializability will define a readObject method that restores this to a known initial state upon deserialization.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;阅读了DOC有一个大致的了解，我们还是看源码比较的利索。AQS的成员变量有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private transient volatile Node head;

    private transient volatile Node tail;

    private volatile int state;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AQS中主要维护了state（锁状态的表示）和一个可阻塞的等待队列。
state是临界资源，也是锁的描述。表示有多少线程已经获取了锁。&lt;/p&gt;

&lt;p&gt;关于state有一个更改的CAS操作：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;

    stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));

    protected final boolean compareAndSetState(int expect, int update) {
        // See below for intrinsics setup to support this
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;成员变量的head ， tail 标识的是等待队列（也称之为 CHL，同步队列）的头结点和尾节点。
CHL队列主要有链表实现，以自旋的方式获取资源，是可阻塞的先进先出的双向队列。通过自旋才做来保证节点插入和移除的原子性。获取锁失败的线程，则会被添加到队尾。&lt;/p&gt;

&lt;h3 id=&quot;aqs的内部类node&quot;&gt;AQS的内部类：Node&lt;/h3&gt;

&lt;p&gt;该Node代表的是 Wait queue node class。 组织形式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      +------+  prev +-----+       +-----+
 head |      | &amp;lt;---- |     | &amp;lt;---- |     |  tail
      +------+       +-----+       +-----+

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Node有大段的注释，我们能够了解到：
We instead use them for blocking synchronizers, 
but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node.&lt;/p&gt;

&lt;p&gt;还有其他的内容，我们结合着代码进行说明。&lt;/p&gt;

&lt;p&gt;AQS的工作模式分为独占模式和共享模式，记录在节点的信息中。它还使用了模板方法设计模式，定义一个操作中算法的骨架，而将一些步骤的实现延迟到子类中。比如获取资源的方法就能很好的品味模板模式。一般地，它的实现类只实现一种模式，ReentrantLock就实现了独占模式；但也有例外，ReentrantReadAndWriteLock实现了独占模式和共享模式。下面来看Node相关源码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        //当前节点处于共享模式的标记
        static final Node SHARED = new Node();
       
        //当前节点处于独占模式的标记
        static final Node EXCLUSIVE = null;

        //线程被取消了
        static final int CANCELLED =  1;
        //释放资源后需唤醒后继节点
        static final int SIGNAL    = -1;
        //等待condition唤醒
        static final int CONDITION = -2;
        //工作于共享锁状态，需要向后传播，
        //比如根据资源是否剩余，唤醒后继节点
        static final int PROPAGATE = -3;

        //等待状态，有1,0,-1,-2,-3五个值。分别对应上面的值
        volatile int waitStatus;

        //前驱节点
        volatile Node prev;

        //后继节点
        volatile Node next;

        //等待锁的线程
        volatile Thread thread;

        //等待条件的下一个节点，ConditonObject中用到
        Node nextWaiter;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;状态说明：&lt;/p&gt;

&lt;p&gt;CANCELLED
作废状态，该节点的线程由于超时，中断等原因而处于作废状态。是不可逆的，一旦处于这个状态，说明应该将该节点移除了。&lt;/p&gt;

&lt;p&gt;SIGNAL
待唤醒后继状态，当前节点的线程处于此状态，后继节点会被挂起，当前节点释放锁或取消之后必须唤醒它的后继节点。&lt;/p&gt;

&lt;p&gt;CONDITION
等待状态，表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。&lt;/p&gt;

&lt;h3 id=&quot;获取资源锁&quot;&gt;获取资源（锁）&lt;/h3&gt;

&lt;p&gt;获取释放资源其实都是对state变量的修改，有的文章会管他叫锁，笔者更喜欢叫资源。
获取资源的方法有acquire()，acquiredShared()。先来看acquire()，该方法只工作于独占模式。&lt;/p&gt;

&lt;h4 id=&quot;acquire独占模式获取资源&quot;&gt;acquire()–独占模式获取资源&lt;/h4&gt;

&lt;p&gt;aquire()：以独占模式获取资源，忽略中断（ReentrantLock.lock()中调用了这个方法）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Acquires in exclusive mode, ignoring interrupts. 
//Implemented by invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success. 
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
            // addWaiter 是采用CAS的操作，把独占的节点加入等待队列
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之前也提到了AQS使用了模板方法模式，其实tryAcuire()方法就是一个钩子方法。在AQS中，此方法会抛出UnsupportedOperationException，所以需要子类去实现。tryAcquire(arg)返回false，其实就是获取锁失败的情况。这时候就调用：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)&lt;/p&gt;

&lt;p&gt;addWaiter()：将当前线程插入至队尾，返回在等待队列中的节点（就是处理了它的前驱后继）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Node addWaiter(Node mode) {
        //把当前线程封装为node,指定资源访问模式
        Node node = new Node(Thread.currentThread(), mode);

        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        //如果tail不为空,把node插入末尾
        if (pred != null) {
            node.prev = pred;
            //此时可能有其他线程插入,所以使用CAS重新判断tail
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        //如果tail为空，说明队列还没有初始化，执行enq()
        enq(node);
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAS设置队尾：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long tailOffset;
 tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));

    private final boolean compareAndSetTail(Node expect, Node update) {
        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;enq()：将节点插入队尾，失败则自旋，直到成功。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))// tail=new Node()
                	 //初始化竟然是一个new Node()
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {//tail = node;
                    t.next = node; // t 这个时候还是原来的那个代表tail的节点
                    return t;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;addWorker 分析完毕后，就是acquireQueued。&lt;/p&gt;

&lt;p&gt;acquireQueued()：自旋方式获取资源并判断是否需要被挂起。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            //还是自旋尝试获取锁资源
            for (;;) {
                final Node p = node.predecessor();
                //如果节点的前驱是队列的头节点并且能拿到资源
                //成功后则返回中断位结束
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                //shouldParkAfterFailedAcquire(Node, Node)检测当前节点是否应该park()
                //parkAndCheckInterrupt()用于中断当前节点中的线程
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;shouldParkAfterFailedAcquire()：判断当前节点是否应该被挂起。趁机梳理等待的节点，如果pre在初始状态下，则设置为SIGNAL状态，如果有CANCELED状态，则直接的删除，跳过。等等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            //前驱节点的状态是SIGNAL，说明前驱节点释放资源后会通知自己
            //此时当前节点可以安全的park()，因此返回true
            return true;
        if (ws &amp;gt; 0) {
            //前驱节点的状态是CANCLLED，说明前置节点已经放弃获取资源了
            //此时一直往前找，直到找到最近的一个处于正常等待状态的节点
            //并排在它后面，返回false
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &amp;gt; 0);
            pred.next = node;
        } else {
            //前驱节点的状态是0或PROPGATE，则利用CAS将前置节点的状态置
            //为SIGNAL，让它释放资源后通知自己
            //如果前置节点刚释放资源，状态就不是SIGNAL了，这时就会失败
            // 返回false
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;parkAndCheckInterrupt()：若确定有必要park，才会执行此方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private final boolean parkAndCheckInterrupt() {
        //使用LockSupport，挂起当前线程
        LockSupport.park(this);
        return Thread.interrupted();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;selfInterrupt()：对当前线程产生一个中断请求。能走到这个方法，说明acquireQueued()返回true，就进行自我中断。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里，获取资源的流程就走完了，接下来总结一下。
aquire的步骤：
1）tryAcquire()尝试获取资源。&lt;/p&gt;

&lt;p&gt;2）如果获取失败，则通过addWaiter(Node.EXCLUSIVE), arg)方法把当前线程添加到等待队列队尾，并标记为独占模式。&lt;/p&gt;

&lt;p&gt;3）插入等待队列后，并没有放弃获取资源，acquireQueued()自旋尝试获取资源。根据前置节点状态状态判断是否应该继续获取资源。如果前驱是头结点，继续尝试获取资源；&lt;/p&gt;

&lt;p&gt;4）在每一次自旋获取资源过程中，失败后调用shouldParkAfterFailedAcquire(Node, Node)检测当前节点是否应该park()。若返回true，则调用parkAndCheckInterrupt()中断当前节点中的线程。若返回false，则接着自旋获取资源。当acquireQueued(Node,int)返回true，则将当前线程中断；false则说明拿到资源了。&lt;/p&gt;

&lt;p&gt;5）在进行是否需要挂起的判断中，如果前置节点是SIGNAL状态，就挂起，返回true。如果前置节点状态为CANCELLED，就一直往前找，直到找到最近的一个处于正常等待状态的节点，并排在它后面，返回false，acquireQueed()接着自旋尝试，回到3）。&lt;/p&gt;

&lt;p&gt;6）前置节点处于其他状态，利用CAS将前置节点状态置为SIGNAL。当前置节点刚释放资源，状态就不是SIGNAL了，导致失败，返回false。但凡返回false，就导致acquireQueed()接着自旋尝试。&lt;/p&gt;

&lt;p&gt;7）最终当tryAcquire(int)返回false，acquireQueued(Node,int)返回true，调用selfInterrupt()，中断当前线程。&lt;/p&gt;

&lt;p&gt;上面的步骤说的不够清晰，需要一张图来进行表示，但是没有趁手的工具啊。&lt;/p&gt;

&lt;p&gt;tryAcquire 比较好理解，addWorker也容易理解，关键在于acquireQueued，排队等待的worker，并不是一直等待着，而是无限的循环去抢锁：抢到了则退出，抢不到，需要更新状态，park，这个逻辑就是shouldParkAfterFailedAcquire(Node, Node)。&lt;/p&gt;

&lt;p&gt;3.2 acquireShared()–共享模式获取资源
接下来简单说下共享模式下获取资源的流程。
acquireShared()：以共享模式获取对象，忽略中断。先是tryAcquireShared(int)尝试直接去获取资源，如果成功，acquireShared(int)就结束了；否则，调用doAcquireShared(Node)将线程加入等待队列，直到获取到资源为止。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void acquireShared(int arg) {
    //模板方法模式，tryAcquireShared由子类实现
    //想看的话推荐读写锁的源码，这里就不细述了
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireShared(arg);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;doAcquireShared()：实现上和acquire()方法差不多，就是多判断了是否还有剩余资源，唤醒后继节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void doAcquireShared(int arg) {
    //将线程加入等待队列，设置为共享模式
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        //自旋尝试获取资源
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    //设置头节点，且如果还有剩余资源，唤醒后继节点获取资源
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //是否需要被挂起
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.3 hasQueuedPredecessors()–公平锁在tryAqcuire()时调用
这里补充一个方法，ReentrantLock如果是公平锁的话，会调用AQS中的这个方法，算是后续文章的铺垫吧。&lt;/p&gt;

&lt;p&gt;boolean hasQueuedPredecessors()：判断当前线程是否位于CLH同步队列中的第一个。如果是则返回flase，否则返回true。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean hasQueuedPredecessors() {
    //判断当前节点在等待队列中是否为头节点的后继节点（头节点不存储数据），
    //如果不是，则说明有线程比当前线程更早的请求资源，
    //根据公平性，当前线程请求资源失败。
    //如果当前节点没有前驱节点的话，才有做后面的逻辑判断的必要性
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &amp;amp;&amp;amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.4 doAcquireNanos()–独占模式下在规定时间内获取锁
这个方法在ReentrantLock.tryLock()过程中被调用。&lt;/p&gt;

&lt;p&gt;doAcquireNanos()：这个方法只工作于独占模式，自旋获取资源超时后则返回false；如果有必要挂起且未超时则挂起。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private boolean doAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout &amp;lt;= 0L)
        return false;
    //计算截至时间
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            //获取锁成功后，出队
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; 
                failed = false;
                return true;
            }
            //重新计算超时时间
            nanosTimeout = deadline - System.nanoTime();
            //超时则返回false
            if (nanosTimeout &amp;lt;= 0L)
                return false;
            //否则判断是否需要被阻塞，阻塞规定时间
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                nanosTimeout &amp;gt; spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.5 doAcquireInterruptibly–获取锁时响应中断&lt;/p&gt;

&lt;p&gt;这个方法在ReentrantLock.lockInterruptibly()过程中被调用。
doAcquireInterruptibly()：独占模式下在获取锁时会阻塞，但是能响应中断请求。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    //添加到等待队列，包装成Node
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            //自旋，直到前驱节点等待状态为SIGNAL，检查中断标志
            //符合条件则阻塞当前线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                //当前线程被阻塞后，会中断
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;四、释放资源（锁）
同样的，释放资源也分为释放独占锁资源（release()）和共享锁(releaseShared())资源。
先来看对于独占锁的释放。&lt;/p&gt;

&lt;p&gt;4.1 release()–独占模式释放资源&lt;/p&gt;

&lt;p&gt;release()：工作于独占模式，首先调用子类的tryRelease()方法释放锁,然后唤醒后继节点,在唤醒的过程中,需要判断后继节点是否满足情况,如果后继节点不为空且不是作废状态,则唤醒这个后继节点,否则从tail节点向前寻找合适的节点,如果找到,则唤醒。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;unparkSuccessor()：尝试找到下一位继承人，就是确定下一个获取资源的线程，唤醒指定节点的后继节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void unparkSuccessor(Node node) {
    //如果状态为负说明是除CANCEL以外的状态，
    //尝试在等待信号时清除。
    int ws = node.waitStatus;
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    //下一个节点为空或CANCELLED状态
    //则从队尾往前找，找到正常状态的节点作为之后的继承人
    //也就是下一个能拿到资源的节点
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    //此时找到继承人了，那么就唤醒它
    if (s != null)
        LockSupport.unpark(s.thread);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.2 releaseShared()–共享模式释放资源
releaseShared()：在释放一部分资源后就可以通知其他线程获取资源。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;doReleaseShared()：把当前结点的状态由SIGNAL设置为PROPAGATE状态。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void doReleaseShared() {

    for (;;) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    //将自旋尝试修改等待状态为0
                    continue;
                //唤醒下一个被阻塞的节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;amp;&amp;amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                //设置为PROPAGATE状态
                continue;               
        }
        //上面代码块执行过程中如果head变更了，就接着循环尝试
        if (h == head)
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;五、内部类-ConditionObject&lt;/p&gt;

&lt;p&gt;ConditionObject实现了Condition接口。用于线程间的通信，能够把锁粒度减小。重点是await()和signal()。这个内部类还维护了一个condition队列，而且Node.nextWaiter就是用来将condition连接起来的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //condition队头
    private transient Node firstWaiter;
    //condition队尾
    private transient Node lastWaiter;
    //发生了中断，但在后续不抛出中断异常，而是“补上”这次中断
    private static final int REINTERRUPT =  1;
    //发生了中断，且在后续需要抛出中断异常
    private static final int THROW_IE    = -1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.1 await()–阻塞等待方法&lt;/p&gt;

&lt;p&gt;5.1.1 await的流程&lt;/p&gt;

&lt;p&gt;await()：当前线程处于阻塞状态，直到调用signal()或中断才能被唤醒。&lt;/p&gt;

&lt;p&gt;1）将当前线程封装成node且等待状态为CONDITION。
2）释放当前线程持有的所有资源，让下一个线程能获取资源。
3）加入到条件队列后，则阻塞当前线程，等待被唤醒。
4）如果是因signal被唤醒，则节点会从条件队列转移到等待队列；如果是因中断被唤醒，则记录中断状态。两种情况都会跳出循环。
5）若是因signal被唤醒，就自旋获取资源；否则处理中断异常。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public final void await() throws InterruptedException {
        //如果被中断，就处理中断异常
        if (Thread.interrupted())
            throw new InterruptedException();
        //初始化链表的功能，设置当前线程为链尾
        Node node = addConditionWaiter();
        //释放当前节点持有的所有资源
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        //如果当前线程不在等待队列中，
        //说明此时一定在条件队列里，将其阻塞。
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            //说明中断状态发生变化
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        //当前线程执行了signal方法会经过这个，也就是重新将当前线程加入同步队列中
        if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        //删除条件队列中不满足要求的元素
        if (node.nextWaiter != null) 
            unlinkCancelledWaiters();
        //处理被中断的情况
        if (interruptMode != 0)
            //这里是个难点，具体的实现我自己也有点不理解
            //就把知道的都写出来
            //如果是THROW_IE，说明signal之前发生中断
            //如果是REINTERRUPT，signal之后中断，
            //所以成功获取资源后会调用selfInterrupt()
            reportInterruptAfterWait(interruptMode);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;addConditionWaiter()：将当前线程封装成节点，添加到条件队列尾部，并返回当前节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private Node addConditionWaiter() {
        Node t = lastWaiter;
        // 判断队尾元素，如果非条件等待状态则清理出去
        if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            //可能t之前引用的节点被删除了，所以要重新引用
            t = lastWaiter;
        }
        //这个节点就表示当前线程
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        //说明条件按队列中没有元素
        if (t == null)
            firstWaiter = node;
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;unlinkCancelledWaiters()：遍历一遍条件队列，删除非CONDITION状态的节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void unlinkCancelledWaiters() {
        Node t = firstWaiter;
        //记录在循环中上一个waitStatus有效的节点
        Node trail = null;
        while (t != null) {
            Node next = t.nextWaiter;
            //再次判断等待状态，保证节点都是CONDITION状态
            //确保当前节点无效后删除引用
            if (t.waitStatus != Node.CONDITION) {
                t.nextWaiter = null;
                if (trail == null)
                    firstWaiter = next;
                else
                    //否则就直接加到队尾的后面
                    trail.nextWaiter = next;
                if (next == null)
                    lastWaiter = trail;
            }
            else
                //记录有效的节点并向后遍历
                trail = t;
            t = next;
        }
    } 5.1.2 await中关于中断的处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过对上面代码的观察，我们知道await()调用了checkInterruptWhileWaiting()。
关于中断这一块，我自己看的也比较迷，就把一些自己能理解的地方标注一下。
checkInterruptWhileWaiting()：判断在阻塞过程中是否被中断。如果返回THROW_IE，则表示线程在调用signal()之前中断的；如果返回REINTERRUPT，则表明线程在调用signal()之后中断；如果返回0则表示没有被中断。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;transferAfterCancelledWait()：线程是否因为中断从park中唤醒。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean transferAfterCancelledWait(Node node) {
    //如果修改成功，暂且认为中断发生后，signal()被调用
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        //true表示中断先于signal发生
        return true;
    }
    //~~不理解~~
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
} 5.2.1 signal()--唤醒condition队列中的线程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;signal()：唤醒一个被阻塞的线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public final void signal() {
        //判断当前线程是否为资源的持有者
        //这也是必须在lock()与unlock()代码中间执行的原因
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        //开始唤醒条件队列的第一个节点
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;doSignal()：将条件队列的头节点从条件队列转移到等待队列，并且，将该节点从条件队列删除。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void doSignal(Node first) {
        do {
            //后续的等待条件为空，说明condition队列中只有一个节点
            if ( (firstWaiter = first.nextWaiter) == null)
                lastWaiter = null;
            first.nextWaiter = null;
            //transferForSignal()是真正唤醒头节点的地方
        } while (!transferForSignal(first) &amp;amp;&amp;amp;
                 (first = firstWaiter) != null);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;transferForSignal()：将节点放入等待队列并唤醒。并不需要在条件队列中移除，因为条件队列每次插入时都会把状态不为CONDITION的节点清理出去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean transferForSignal(Node node) {
    //当前节点等待状态改变失败，则说明当前节点不是CONDITION
    //状态，那就不能进行接下来的操作，返回false
    //0是正常状态
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    //放入等待队列队尾中，并返回之前队列的前一个节点
    Node p = enq(node);
    int ws = p.waitStatus;
    //如果节点没有被取消，或更改状态失败，则唤醒被阻塞的线程
    if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.2.2 signalAll()–唤醒condition队列中所有线程
signalAll()本质上还是调用了doSignalAll()
doSignalAll()：遍历条件队列，插入到等待队列中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void doSignalAll(Node first) {
        lastWaiter = firstWaiter = null;
        do {
            Node next = first.nextWaiter;
            first.nextWaiter = null;
            transferForSignal(first);
            first = next;
        } while (first != null);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.3 awaitNanos()–超时机制
这里补充一个方法awaitNanos()，是我看阻塞队列源码中遇到的。
awaitNanos()：轮询检查线程是否在同步线程上，如果在则退出自旋。否则检查是否已超过解除挂起时间，如果超过，则退出挂起，否则继续挂起线程到等待解除挂起。退出挂起之后，采用自旋的方式竞争锁。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public final long awaitNanos(long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        int interruptMode = 0;
        //采用自旋的方式检查是否已在等待队列当中
        while (!isOnSyncQueue(node)) {
            //如果挂起超过一定的时间，则退出
            if (nanosTimeout &amp;lt;= 0L) {
                transferAfterCancelledWait(node);
                break;
            }
            //继续挂起线程
            if (nanosTimeout &amp;gt;= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        //采用自旋的方式竞争锁
        if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return deadline - System.nanoTime();
    } 总结 关于AQS我觉得比较重要的就是获取资源和释放资源的方法，里面用到了大量的CAS操作和自旋。AQS里面维护了两个队列，一个是等待队列（CHL），还有一个是条件队列（condition）。 acquire()尝试获取资源，如果获取失败，将线程插入等待队列。插入后，并没有放弃获取资源，而是根据前置节点状态状态判断是否应该继续获取资源。如果前置节点是头结点，继续尝试获取资源；如果前置节点是SIGNAL状态，就中断当前线程，否则继续尝试获取资源。直到当前线程被阻塞或者获取到资源，结束。 release()释放资源，需要唤醒后继节点,判断后继节点是否满足情况。如果后继节点不为空且不是作废状态,则唤醒这个后继节点；否则从尾部往前面找适合的节点，找到则唤醒。 调用await()，线程会进入条件队列，等待被唤醒，唤醒后以自旋方式获取资源或处理中断异常；调用signal()，线程会插入到等待队列，唤醒被阻塞的线程。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如有不当之处，欢迎指出~&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/17/concurrent-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/17/concurrent-3/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
  </channel>
</rss>
