<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 23 Sep 2019 09:50:02 +0800</pubDate>
    <lastBuildDate>Mon, 23 Sep 2019 09:50:02 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Leetcode:48. Rotate Image</title>
        <description>&lt;p&gt;问题的描述为：
You are given an n x n 2D matrix representing an image.&lt;/p&gt;

&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 3     7 8 9     7 4 1
4 5 6  =&amp;gt; 4 5 6  =&amp;gt; 8 5 2
7 8 9     1 2 3     9 6 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void rotate(int[][] matrix) {
    int s = 0, e = matrix.length - 1;
    while(s &amp;lt; e){
        int[] temp = matrix[s];
        matrix[s] = matrix[e];
        matrix[e] = temp;
        s++; e--;
    }

    for(int i = 0; i &amp;lt; matrix.length; i++){
        for(int j = i+1; j &amp;lt; matrix[i].length; j++){
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/25/leetcode48/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/25/leetcode48/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：5.Atomic 原子类，LockSupport支持类</title>
        <description>&lt;p&gt;在并发的场景下，除了常常使用的锁之类外，还有一些并发底层的支持类，例如：Atomic原子类和LockSupport，还有一个就是时常能见到，但是总感觉名字怪怪的：Unsafe等。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先我们来看Atomic原子类，自己把它分为三类的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;基础类型：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference之类的。&lt;/li&gt;
  &lt;li&gt;数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray之类的。&lt;/li&gt;
  &lt;li&gt;成员变成之类的：AtomicIntegerFiledUpdate等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们先从基础类说明：AtomicBoolean有三个主要的成员变量：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
      try {
         valueOffset = unsafe.objectFieldOffset
            (AtomicBoolean.class.getDeclaredField(&quot;value&quot;));
      } catch (Exception ex) { throw new Error(ex); }
  }

private volatile int value;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要的方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean get() {
     return value != 0;
}

public final boolean compareAndSet(boolean expect, boolean update) {
    int e = expect ? 1 : 0;
    int u = update ? 1 : 0;
    return unsafe.compareAndSwapInt(this, valueOffset, e, u);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现的原理就是，通过Unsafe，拿到Volatile修饰的成员变量value的内存地址，然后通过Unsafe的
compareAndSet方法来设置value的值。&lt;/p&gt;

&lt;p&gt;其他的基础类，基本就是这种模式的实现。&lt;/p&gt;

&lt;p&gt;AtomicIntegerArray 的实现的源码，也是操作内存地址，但是因为是数组，所以有了些许的变化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AtomicIntegerArray：

private static final int base = unsafe.arrayBaseOffset(int[].class);
 private static final int shift;
 private final int[] array;

 static {
  int scale = unsafe.arrayIndexScale(int[].class);
  if ((scale &amp;amp; (scale - 1)) != 0)
   throw new Error(&quot;data type scale not a power of two&quot;);
  shift = 31 - Integer.numberOfLeadingZeros(scale);
 }

 private long checkedByteOffset(int i) {
  if (i &amp;lt; 0 || i &amp;gt;= array.length)
   throw new IndexOutOfBoundsException(&quot;index &quot; + i);

  return byteOffset(i);
 }

 private static long byteOffset(int i) {
  return ((long) i &amp;lt;&amp;lt; shift) + base;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们看一个具体的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean compareAndSet(int i, int expect, int update) {
  return compareAndSetRaw(checkedByteOffset(i), expect, update);
 }

 private boolean compareAndSetRaw(long offset, int expect, int update) {
  return unsafe.compareAndSwapInt(array, offset, expect, update);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;checkedByteOffset 就是根据i，确实能够&lt;code class=&quot;highlighter-rouge&quot;&gt;array[i]&lt;/code&gt; 对应的内存地址： &lt;code class=&quot;highlighter-rouge&quot;&gt;((long) i &amp;lt;&amp;lt; shift) + base&lt;/code&gt;
其中shift 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;31 - Integer.numberOfLeadingZeros(unsafe.arrayIndexScale(int[].class))&lt;/code&gt;
就看计算公式，就让我们想起来数组的基础地址 + i* 每一个元素所占的步长的算法。&lt;/p&gt;

&lt;p&gt;这也是其他的数组类原子类的基本操作了。&lt;/p&gt;

</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/24/concurrent-7/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/24/concurrent-7/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:42  container water</title>
        <description>&lt;p&gt;问题的描述为：
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!

Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：主要在于观察图形的规律，有两种情况，一中为凹，一种为凸 ，但是这样的判断代码写起来非常的复杂。可以换另外的一种思路，观察总体的情况。&lt;/p&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int trap(int[] height) {

  int n = height.length;

  int[] left = new int[n];
  int[] right = new int[n];

  int leftMax = Integer.MIN_VALUE;
  int rightMax = Integer.MIN_VALUE;
  // construct left max (including self) array
  for (int i = 0; i &amp;lt; n; i++) {
   if (height[i] &amp;gt; leftMax) {
    leftMax = height[i];
   }
   left[i] = leftMax;
  }

  // construct right max (including self) array 
  for (int i = n - 1; i &amp;gt;= 0; i--) {
   if (height[i] &amp;gt; rightMax) {
    rightMax = height[i];
   }
   right[i] = rightMax;
  }

  int water = 0;

  // water trapped  
  for (int i = 0; i &amp;lt; n; i++) {

   int min = Math.min(left[i], right[i]);

   water += (min - height[i]);
  }

  return water;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/24/leetcode42/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/24/leetcode42/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:41  firstMissingPositive</title>
        <description>&lt;p&gt;数组的下标是一种天然的资源，有序，有界。在某些特殊的问题下，可以做为一种辅助信息。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;问题的描述为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an unsorted integer array, find the smallest missing positive integer.
 Example 1:
 Input: [1,2,0]
 Output: 3
 Example 2:
 Input: [3,4,-1,1]
 Output: 2
 Example 3:
 Input: [7,8,9,11,12]
 Output: 1
 Note:
 Your algorithm should run in O(n) time and uses constant extra space.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Your algorithm should run in O(n) time and uses constant extra space.
这里面的uses constant extra space 和 O(n) 也算是一种提示吧。&lt;/p&gt;

&lt;p&gt;具体的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int firstMissingPositive_(int[] A) {
  int i = 0;
  while (i &amp;lt; A.length) {
   if (A[i] == i + 1 || A[i] &amp;lt;= 0 || A[i] &amp;gt; A.length)
    i++;
   else if (A[A[i] - 1] != A[i])
    swap(A, i, A[i] - 1);
   else
    i++;
  }
  i = 0;
  while (i &amp;lt; A.length &amp;amp;&amp;amp; A[i] == i + 1)
   i++;
  return i + 1;
 }

 private void swap(int[] A, int i, int j) {
  int temp = A[i];
  A[i] = A[j];
  A[j] = temp;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/24/leetcode41/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/24/leetcode41/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：4. 阻塞队列</title>
        <description>&lt;p&gt;阻塞队列的接口为： BlockingQueue&lt;E&gt; 这块是已经陌生但是以前比较梳理的内容，写出来在熟悉一下。&lt;/E&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;blockingqueue-的操作方法&quot;&gt;BlockingQueue 的操作方法&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/queue/q1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图中所示：
add(e),当队列满了以后，抛出IllegalStateException。
offer(e),当队列满了以后,返回false。
put(e),当队列满了以后,会被阻塞。
put(e,time,unit):false if the specified waiting time elapses before space is available&lt;/p&gt;

&lt;h3 id=&quot;blockingqueue常用的四个实现类&quot;&gt;BlockingQueue常用的四个实现类&lt;/h3&gt;

&lt;p&gt;ArrayBlockingQueue：规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的.&lt;/p&gt;

&lt;p&gt;LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的
BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的&lt;/p&gt;

&lt;p&gt;PriorityBlockingQueue：类似于LinkedBlockQueue,但其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序.&lt;/p&gt;

&lt;p&gt;SynchronousQueue：特殊的BlockingQueue,对其的操作必须是放和取交替完成的.&lt;/p&gt;

&lt;h3 id=&quot;arrayblockingqueue-主要实现的逻辑&quot;&gt;ArrayBlockingQueue&lt;E&gt; 主要实现的逻辑&lt;/E&gt;&lt;/h3&gt;

&lt;p&gt;我们还可以先回看一下ArrayQueue的实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 成员变量

private int capacity;
private T[] queue;
private int head;
private int tail;

// 有点意思的是构造函数 capacity+1 
public ArrayQueue(int capacity) {
    this.capacity = capacity + 1;
    this.queue = newArray(capacity + 1);
    this.head = 0;
    this.tail = 0;
}
// 添加方法，采用的是tail+1 取余capacity 的方法，这也就是构建capacity+1的原因
 public boolean add(T o) {
  queue[tail] = o;
  int newtail = (tail + 1) % capacity;
  if (newtail == head)
   throw new IndexOutOfBoundsException(&quot;Queue full&quot;);
  tail = newtail;
  return true; // we did add something
 }

//删除的方法，采用的是 head+1 取余capacity 的方法，都是+1取余的操作
public T remove(int i) {
  if (i != 0)
   throw new IllegalArgumentException(&quot;Can only remove head of queue&quot;);
  if (head == tail)
   throw new IndexOutOfBoundsException(&quot;Queue empty&quot;);
  T removed = queue[head];
  queue[head] = null;
  head = (head + 1) % capacity;
  return removed;
 }

 public T get(int i) {
  int size = size();
  if (i &amp;lt; 0 || i &amp;gt;= size) {
   final String msg = &quot;Index &quot; + i + &quot;, queue size &quot; + size;
   throw new IndexOutOfBoundsException(msg);
  }
  int index = (head + i) % capacity;
  return queue[index];
 }

// 判定大小的时候，采用的是tail-head 的方法
 public int size() {
  // Can't use % here because it's not mod: -3 % 2 is -1, not +1.
  int diff = tail - head;
  if (diff &amp;lt; 0)
   diff += capacity;
  return diff;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们再看BlockingQueue的方法的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // ArrayBlockingQueue 的成员变量：

 /** The queued items */
 final Object[] items;

 /** items index for next take, poll, peek or remove */
 int takeIndex;

 /** items index for next put, offer, or add */
 int putIndex;

 /** Number of elements in the queue */
 int count;

 /** Main lock guarding all access */
 final ReentrantLock lock;

 /** Condition for waiting takes */
 private final Condition notEmpty;

 /** Condition for waiting puts */
 private final Condition notFull;

 public ArrayBlockingQueue(int capacity, boolean fair) {
  if (capacity &amp;lt;= 0)
   throw new IllegalArgumentException();
  this.items = new Object[capacity];
  lock = new ReentrantLock(fair);
  notEmpty = lock.newCondition();
  notFull = lock.newCondition();
 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的方法的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean add(E e) {
  return super.add(e);
 }

/**
实现的方式：
public boolean add(E e) {
   if (offer(e))
        return true;
   else
       throw new IllegalStateException(&quot;Queue full&quot;);
} 
*/
 public boolean offer(E e) {
  checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
   if (count == items.length)
    return false;
   else {
    // 保证lock的前提下，调用这个方法
    // 保证了队列不满，如果满了，直接在try方法中就已经返回
    enqueue(e);
    return true;
   }
  } finally {
   lock.unlock();
  }
 }
 /**
  * ① 已经拥有锁的前提下调用
  * ② 满的时候，putIndex直接设置为0，从头开始（这里面的putIndex为0，标识已经满了）
  * */
 private void enqueue(E x) {
  final Object[] items = this.items;
  items[putIndex] = x;
  if (++putIndex == items.length)
   putIndex = 0;
  count++;
  notEmpty.signal();
 }
 
 public void put(E e) throws InterruptedException {
  checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
   while (count == items.length)
    notFull.await();
   enqueue(e);
  } finally {
   lock.unlock();
  }
 }
 
 //相对应的四个方法：remove() poll()
 public E remove() {
  E x = poll();
  if (x != null)
      return x;
  else
      throw new NoSuchElementException();
}
public E poll() {
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
   return (count == 0) ? null : dequeue();
  } finally {
   lock.unlock();
  }
 }
private E dequeue() {
 final Object[] items = this.items;
 @SuppressWarnings(&quot;unchecked&quot;)
 E x = (E) items[takeIndex];
 items[takeIndex] = null;
 if (++takeIndex == items.length)
  takeIndex = 0;
 count--;
 if (itrs != null)
  itrs.elementDequeued();
 notFull.signal();
 return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LinkedBlockingQueue 的实现的源码，对比ArrayBlockingQueue，实现的框架上面，基本相同。当时具体的数据处理是不一样的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public boolean add(E e) {
  addLast(e);
  return true;
 }

 public void addLast(E e) {
  if (!offerLast(e))
   throw new IllegalStateException(&quot;Deque full&quot;);
 }

 public boolean offerLast(E e) {
  if (e == null)
   throw new NullPointerException();
  Node&amp;lt;E&amp;gt; node = new Node&amp;lt;E&amp;gt;(e);
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
   return linkLast(node);
  } finally {
   lock.unlock();
  }
 }

 private boolean linkLast(Node&amp;lt;E&amp;gt; node) {
  // assert lock.isHeldByCurrentThread();
  if (count &amp;gt;= capacity)
   return false;

  Node&amp;lt;E&amp;gt; l = last;
  node.prev = l;
  last = node;
  if (first == null)
   first = node;
  else
   l.next = node;

  ++count;
  notEmpty.signal();
  return true;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里面中的信号，使用到了Condition，Condition的建立是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lock = new ReentrantLock(fair);
  notEmpty = lock.newCondition();
  notFull = lock.newCondition();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ReentrantLock 的 newCondition的方法是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ReentrantLock.newCondition() {
  return sync.newCondition();
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;还是原来的：Sync 实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final ConditionObject newCondition() {
   return new ConditionObject();
  }
返回的是AQS的一个内部类ConditionObject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ConditionObject 为AQS专门实现的一个类，具体我们只看两个关键的方法，在BlockingQueue中，使用的比较的多。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void await() throws InterruptedException {
   if (Thread.interrupted())
    throw new InterruptedException();
   Node node = addConditionWaiter();
   // ！！！当调用await的时候，就已经释放了拥有的锁！！
   int savedState = fullyRelease(node);
   int interruptMode = 0;
   while (!isOnSyncQueue(node)) {
    LockSupport.park(this);
    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
     break;
   }
   if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
    interruptMode = REINTERRUPT;
   if (node.nextWaiter != null) // clean up if cancelled
    unlinkCancelledWaiters();
   if (interruptMode != 0)
    reportInterruptAfterWait(interruptMode);
  }


  // 增加到等待的队列里面
  private Node addConditionWaiter() {
   Node t = lastWaiter;
   // If lastWaiter is cancelled, clean out.
   if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
    unlinkCancelledWaiters();
    t = lastWaiter;
   }
   Node node = new Node(Thread.currentThread(), Node.CONDITION);
   if (t == null)
    firstWaiter = node;
   else
    t.nextWaiter = node;
   lastWaiter = node;
   return node;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void signal() {
   if (!isHeldExclusively())
    throw new IllegalMonitorStateException();
   Node first = firstWaiter;
   if (first != null)
    doSignal(first);
  }
  
  private void doSignal(Node first) {
   do {
    if ((firstWaiter = first.nextWaiter) == null)
     lastWaiter = null;
    first.nextWaiter = null;
   } while (!transferForSignal(first) &amp;amp;&amp;amp; (first = firstWaiter) != null);
  }
  
  final boolean transferForSignal(Node node) {
   /*
    * If cannot change waitStatus, the node has been cancelled.
    */
   if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
    return false;

   /*
    * Splice onto queue and try to set waitStatus of predecessor to
    * indicate that thread is (probably) waiting. If cancelled or
    * attempt to set waitStatus fails, wake up to resync (in which
    * case the waitStatus can be transiently and harmlessly wrong).
    */
   Node p = enq(node);
   int ws = p.waitStatus;
   if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
    LockSupport.unpark(node.thread);
   return true;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/23/concurrent-6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/23/concurrent-6/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>Leetcode:39,40,78,90,46,47,131</title>
        <description>&lt;p&gt;LeetCode 39. Combination Sum&lt;/p&gt;

&lt;p&gt;回溯算法是通过一步一步（通常是用递归）构建可能”解”，
并且回溯不可能”解”来求所有或者部分解决方案的通用算法。
其中“回溯”的具体意思就是将不可能解或者部分解的候选尽早的舍弃掉，
“解”需要满足一定的限制条件（constraint satisfaction）&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;回溯算法一般的通解：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALGORITHM try(v1,...,vi)  // 这里的V1.....V2携带的参数说明 “可能解”  
   // 入口处验证是否是全局解，如果是，直接返回。 
   // 实际编程中也需要查看是否是无效解，如果是，也是直接返回
   IF (v1,...,vi) is a solution THEN RETURN (v1,...,vi)  
   FOR each v DO  // 对于每一个可能的解，进行查看
      // 下面的含义是形成一个可能解 进行递归
      IF (v1,...,vi,v) is acceptable vector  THEN 
        sol = try(v1,...,vi,v) 
        IF sol != () THEN RETURN sol 
        // 这个地方其实需要增加“回溯” 处理，实际编程中通常是函数参数的变化
      END 
   END 
   RETURN () 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;题目1：78. Subsets&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list , List&amp;lt;Integer&amp;gt; tempList, int [] nums, int start){
    list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    for(int i = start; i &amp;lt; nums.length; i++){
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果值：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Subsets II&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;描述：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of integers that might contain duplicates, nums, 
return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int start){
    list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    for(int i = start; i &amp;lt; nums.length; i++){
        if(i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; // skip duplicates
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Permutations
描述：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of distinct integers, 
return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
   List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
   // Arrays.sort(nums); // not necessary
   backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums);
   return list;
}


private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums){
   if(tempList.size() == nums.length){
      list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
   } else{
      for(int i = 0; i &amp;lt; nums.length; i++){ 
         if(tempList.contains(nums[i])) continue; // element already exists, skip
         tempList.add(nums[i]);
         backtrack(list, tempList, nums);
         tempList.remove(tempList.size() - 1);
      }
   }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Permutations II&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of numbers that might contain duplicates, 
return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, new boolean[nums.length]);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, boolean [] used){
    if(tempList.size() == nums.length){
        list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    } else{
        for(int i = 0; i &amp;lt; nums.length; i++){
            if(used[i] || i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] &amp;amp;&amp;amp; !used[i - 1]) continue;
            used[i] = true; 
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, used);
            used[i] = false; 
            tempList.remove(tempList.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;39  Combination Sum&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a set of candidate numbers (candidates) (without duplicates) and 
a target number (target), find all unique combinations in candidates where 
the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] nums, int target) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, target, 0);
    return list;
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int remain, int start){
    if(remain &amp;lt; 0) return;
    else if(remain == 0) list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    else{ 
        for(int i = start; i &amp;lt; nums.length; i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements
            tempList.remove(tempList.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Combination Sum II&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] nums, int target) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Arrays.sort(nums);
    backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums, target, 0);
    return list;
    
}

private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums, int remain, int start){
    if(remain &amp;lt; 0) return;
    else if(remain == 0) list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
    else{
        for(int i = start; i &amp;lt; nums.length; i++){
            if(i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; // skip duplicates
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i + 1);
            tempList.remove(tempList.size() - 1); 
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Palindrome Partitioning&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: &quot;aab&quot;
Output:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
   List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
   backtrack(list, new ArrayList&amp;lt;&amp;gt;(), s, 0);
   return list;
}

public void backtrack(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list, List&amp;lt;String&amp;gt; tempList, String s, int start){
   if(start == s.length())
      list.add(new ArrayList&amp;lt;&amp;gt;(tempList));
   else{
      for(int i = start; i &amp;lt; s.length(); i++){
         if(isPalindrome(s, start, i)){
            tempList.add(s.substring(start, i + 1));
            backtrack(list, tempList, s, i + 1);
            tempList.remove(tempList.size() - 1);
         }
      }
   }
}

public boolean isPalindrome(String s, int low, int high){
   while(low &amp;lt; high)
      if(s.charAt(low++) != s.charAt(high--)) return false;
   return true;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/23/leetcode39/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/23/leetcode39/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>并发知识梳理：4. 读写锁等其他的类型的锁的支持</title>
        <description>&lt;p&gt;ReentrantReadWriteLock 是在重入锁的基础上，添加读写的控制。主要关注的是共享锁的实现和理解上。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先还是复习一下重入锁的伪代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
ReentrantLock
public NonFairLock nonfairLock = new NonFairLock();
lock(){
	nonfairLock.lock()
}

// 获取锁的过程
nonfairLock.lock(){
	if(cas(state,0,1)){
		setExcludeThread(Thread.currentThread());
	}else{
		if(!tryAcqure(1) &amp;amp;&amp;amp; acquireQueued(addWaiter(Node.excluse),arg))
			selfInterrupt();
	}
}

nonfairLock.tryAcquire(int acquire){
	int c = getState();
	if(c == 0) {
		if(cas(state,0,1){
			setExcludeThread(Thread.currentThread());
			return true;
		}
	}else if(Thread.currentThread() == getExclude){
		int nextc = c+acquire;
		if(nextc &amp;lt; 0) {
			throw new Error(lock too large);
		}
		setstate(nextc);
		return true;
	}
	return false;
}

Node addWaiter(){ // 把Thread放到一个Node节点中，组成等待的链条
	 Node node = new Node(Thread.currentThread(), mode);
	 addTail(node)
	 return node;
}
acquireQueued(Node node) {// 更新等待链条的状态，释放锁的时候，可以调用tryAcquire
	interrupted = false;
	for(;;){
		if(head == node.pre &amp;amp;&amp;amp; tryAcquire()){
			 setHead(node); // head = node;
       p.next = null; // help GC
       failed = false;
       return interrupted;
		}
		
		if(shouldParkAfterAcqiureFailed(p,node) &amp;amp;&amp;amp; parkAndChectInterrupt()){
			interrupted = true;
		}
	}
}

//释放锁的过程
unlock(){
	nonfairLock.release(1);
}

nonfairLock.release(1){
	if(tryRealse(1)){
		If(head != null &amp;amp;&amp;amp; h.state != 0){
			unparkSuccessor(head) // unpark head的下一个节点，head中不包含thread
		}
	}
}

nonfairLock.tryRelease(1){
	int c = getState  - 1;
	if(Thread.concurrent != getExcluseThread) {
		throw Error( not state )
	}
	 boolean free = false;
	if(c == 0) {
		setExcluseThread(null)
		free = true
	}
	
	setState(c);
	return free;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;读写锁的控制，更加的复杂，我们只是大致的梳理出来重要的逻辑框架，并不扣具体的细节。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CachedData {
 Object data;
 volatile boolean cacheValid;
 final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

 void processCachedData() {
  rwl.readLock().lock();
  if (!cacheValid) {
   // Must release read lock before acquiring write lock
   rwl.readLock().unlock();
   rwl.writeLock().lock();
   try {
    // Recheck state because another thread might have
    // acquired write lock and changed state before we did.
    if (!cacheValid) {
     data = &quot;use data &quot;;
     cacheValid = true;
    }
    // Downgrade by acquiring read lock before releasing write lock
    rwl.readLock().lock();
   } finally {
    rwl.writeLock().unlock(); // Unlock write, still hold read
   }
  }

  try {
   //       use(data);
  } finally {
   rwl.readLock().unlock();
  }
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从官方的示例代码中，我们可以知道ReentrantReadWriteLock（以下简写为RRW）有两个锁类型，读锁：ReadLock（RL）和写锁：WriteLock (WL)
从代码中也能初见端倪：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们首先看读锁：RL&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RL.lock(){
    sync.acquireShared(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还是原来的熟悉的配方，使用内部类：Sync来实现。Sync继承AQS的框架&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AQS.acquireShared(int arg) {
        if (tryAcquireShared(arg) &amp;lt; 0)
            doAcquireShared(arg);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先就是共享锁定加锁的过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sync.tryAcquireShared(int unused) {

            Thread current = Thread.currentThread();
            int c = getState();
            // 如果被独占锁占据 直接返回-1
            if (exclusiveCount(c) != 0 &amp;amp;&amp;amp; // exclusiveCount(c) c的后16位标识独占锁
                getExclusiveOwnerThread() != current)
                return -1;

            int r = sharedCount(c); // sharedCount(c) c的前16位标识的是共享锁

            //readerShouldBlock()：第一个排队的线程是否为独占节点
            if (!readerShouldBlock() &amp;amp;&amp;amp; r &amp;lt; MAX_COUNT &amp;amp;&amp;amp; compareAndSetState(c, c + SHARED_UNIT)) {
                // 条件表示为：第一个等待的线程不是独占节点，并且CAS成功
                if (r == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                }
                //返回1
                return 1;
            }

            return fullTryAcquireShared(current); // 增加了无限的循环
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;doAcquireShared 类似于重入锁里面的 addWaiter和 更新节点状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r &amp;gt;= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再来看解锁的过程,这次释放的是共享锁&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RL.unlock() {
            sync.releaseShared(1);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样的Sync的实现AQS的框架：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AQS.releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;熟悉的配方，但是不是熟悉的过程了。共享锁在释放的过程中，不再是线程安全的单个线程的调用，而是多个线程调用了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sync.tryReleaseShared(int unused) {
   Thread current = Thread.currentThread();
   // 首先是普通成员变量 firstReader 的更新操作
   if (firstReader == current) {
    // assert firstReaderHoldCount &amp;gt; 0;
    if (firstReaderHoldCount == 1)
     firstReader = null;
    else
     firstReaderHoldCount--;
   } else {
    HoldCounter rh = cachedHoldCounter;
    if (rh == null || rh.tid != getThreadId(current))
     rh = readHolds.get();
    int count = rh.count;
    if (count &amp;lt;= 1) {
     readHolds.remove();
     if (count &amp;lt;= 0)
      throw unmatchedUnlockException();
    }
    --rh.count;
   }
   // 再次就是无限循环的状态更新，最后的结果是 nextc 是否为0
   for (;;) {
    int c = getState();
    int nextc = c - SHARED_UNIT;
    if (compareAndSetState(c, nextc))
     // Releasing the read lock has no effect on readers,
     // but it may allow waiting writers to proceed if
     // both read and write locks are now free.
     return nextc == 0;
   }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;doReleaseShared 和重入锁的释放过程，基本类似。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void doReleaseShared() {
  for (;;) {
   Node h = head;
   if (h != null &amp;amp;&amp;amp; h != tail) {
    int ws = h.waitStatus;
    if (ws == Node.SIGNAL) {
     if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
      continue; // loop to recheck cases
     unparkSuccessor(h);
    } else if (ws == 0 &amp;amp;&amp;amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
     continue; // loop on failed CAS
   }
   if (h == head) // loop if head changed
    break;
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 22 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/22/concurrent-5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/22/concurrent-5/</guid>
        
        <category>Concurrent</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 34.Find First and Last Position of Element in Sorted Array </title>
        <description>&lt;p&gt;LeetCode 34. Find First and Last Position of Element in Sorted Array&lt;/p&gt;

&lt;p&gt;如果使用O(n)的遍历，根本就不会有什么难度了，但是题目中已经明确的标注了：Sorted Array，那么就不行了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;那就使用二分查找出第一个值，最后一个值。原本的思路。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：首先是按照思路来的，一种类似作弊的思路，前后加减0.5&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int[] searchRange(int[] nums, int target) {
        double left = target - 0.5, right = target + 0.5;
        int l = bs(nums, left), r = bs(nums, right);
        if(l == r) return new int[]{-1, -1};
        return new int[]{l, r-1};
}
    
public int bs(int[] nums, double target) {
        int l = 0, h = nums.length-1;
        while(l &amp;lt;= h){
            int m = l + (h - l)/2;
            if(target &amp;gt; nums[m]) l = m+1;
            else h = m-1;
        }
        return l;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正规的思路分析：&lt;/p&gt;

&lt;p&gt;The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:&lt;/p&gt;

&lt;p&gt;First let’s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:&lt;/p&gt;

&lt;p&gt;If A[mid] &amp;lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration)
If A[mid] &amp;gt; target, it means the range must begins on the left of mid (j = mid-1)
If A[mid] = target, then the range must begins on the left of or at mid (j= mid)
Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:&lt;/p&gt;

&lt;p&gt;2*. If A[mid] &amp;gt;= target, j = mid;&lt;/p&gt;

&lt;p&gt;Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &amp;lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why?&lt;/p&gt;

&lt;p&gt;No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:&lt;/p&gt;

&lt;p&gt;case 1: [5 7] (A[i] = target &amp;lt; A[j])
case 2: [5 3] (A[i] = target &amp;gt; A[j])
case 3: [5 5] (A[i] = target = A[j])
case 4: [3 5] (A[j] = target &amp;gt; A[i])
case 5: [3 7] (A[i] &amp;lt; target &amp;lt; A[j])
case 6: [3 4] (A[i] &amp;lt; A[j] &amp;lt; target)
case 7: [6 7] (target &amp;lt; A[i] &amp;lt; A[j])
For case 1, 2 and 3, if we follow the above rule, since mid = i =&amp;gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.&lt;/p&gt;

&lt;p&gt;For case 4, since A[mid] &amp;lt; target, then set i = mid+1. The loop terminates and both i and j point to 5.&lt;/p&gt;

&lt;p&gt;For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.&lt;/p&gt;

&lt;p&gt;In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;&lt;/p&gt;

&lt;p&gt;For the right of the range, we can use a similar idea. Again we can come up with several rules:&lt;/p&gt;

&lt;p&gt;If A[mid] &amp;gt; target, then the range must begins on the left of mid (j = mid-1)
If A[mid] &amp;lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration)
If A[mid] = target, then the range must begins on the right of or at mid (i= mid)
Again, we can merge condition 2 and 3 into:&lt;/p&gt;

&lt;p&gt;2* If A[mid] &amp;lt;= target, then i = mid;
However, the terminate condition on longer works this time. Consider the following case:&lt;/p&gt;

&lt;p&gt;[5 7], target = 5
Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!&lt;/p&gt;

&lt;p&gt;The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:&lt;/p&gt;

&lt;p&gt;mid = (i+j)/2+1
Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won’t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1.&lt;/p&gt;

&lt;p&gt;All this reasoning boils down to the following simple code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
vector&amp;lt;int&amp;gt; searchRange(int A[], int n, int target) {
    int i = 0, j = n - 1;
    vector&amp;lt;int&amp;gt; ret(2, -1);
    // Search for the left one
    while (i &amp;lt; j)
    {
        int mid = (i + j) /2;
        if (A[mid] &amp;lt; target) i = mid + 1;
        else j = mid;
    }
    if (A[i]!=target) return ret;
    else ret[0] = i;
    
    // Search for the right one
    j = n-1;  // We don't have to set i to 0 the second time.
    while (i &amp;lt; j)
    {
        int mid = (i + j) /2 + 1;	// Make mid biased to the right
        if (A[mid] &amp;gt; target) j = mid - 1;  
        else i = mid;				// So that this won't make the search range stuck.
    }
    ret[1] = j;
    return ret; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 22 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/22/leetcode34/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/22/leetcode34/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 33. Search in Rotated Sorted Array</title>
        <description>&lt;p&gt;LeetCode 33. Search in Rotated Sorted Array&lt;/p&gt;

&lt;p&gt;从根本上面说，这个数据很有意思，只是正常的数据进行的一次转换，我们需要的就是怎么转换回来，或者说在经典的算法中，下标计算的时候，怎么能够不受这次转换的影响。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;既然是有一段数据被翻转回到了数据的开头，那我们怎么能够比较巧妙的翻转回去尼？

i = (i + k) % n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int search(int A[], int n, int target) {
  int lo = 0, hi = n - 1;
  //！！！寻找折点的算法也是折半查找！！！
  while (lo &amp;lt; hi) {
   int mid = (lo + hi) / 2;
   if (A[mid] &amp;gt; A[hi])
    lo = mid + 1;
   else
    hi = mid;
  }


  int rot = lo;
  lo = 0;
  hi = n - 1;

  while (lo &amp;lt;= hi) {
   int mid = (lo + hi) / 2;
   //最关键的一句，说明了，这个题目看数据的方式
   int realmid = (mid + rot) % n;
   if (A[realmid] == target)
    return realmid;
   if (A[realmid] &amp;lt; target)
    lo = mid + 1;
   else
    hi = mid - 1;
  }
  return -1;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode33/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode33/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode 32. Longest Valid Parentheses</title>
        <description>&lt;p&gt;LeetCode 32. Longest Valid Parentheses
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: &quot;(()&quot;
Output: 2
Explanation: The longest valid parentheses substring is &quot;()&quot;
Example 2:

Input: &quot;)()())&quot;
Output: 4
Explanation: The longest valid parentheses substring is &quot;()()&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 1. 首先理解题意是关键的步骤：挑选可以使用的括号规则，如下的规则
 * 
 * ()(() 计算值为2
 * ()()) 计算值为4
 * 
 * 2. 理解了题意之后，就是梳理具体的逻辑
 * 
 * 采用栈的的数据结构，来匹配右括号与左括号的匹配的规则
 * 左括号则入栈，右括号需要处理的逻辑是：
 * 匹配或者不匹配的情况
 *   如果是匹配的情况，那么需要把匹配的左括号出栈，然后根据出栈后的情况：
 *   如果还有内容，没有匹配完呢，直接的更新数据。
 *   如果栈内没有了内容，需要计算最大的长度。
 * 
 * 	 如果是不匹配的情况，右括号不匹配的情况，就是直接的丢弃。判断这个时候的栈内元素为空，并且更新最大长度的开始的值。
 * 			
 * */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int longestValidParentheses_copy(String s) {
  int n = s.length(), longest = 0;
  //记录遍历过程中s的下标的值
  Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;Integer&amp;gt;();
  
  for (int i = 0; i &amp;lt; n; i++) {
      if (s.charAt(i) == '(') {
       st.push(i);
      }else {
          if (!st.empty() &amp;amp;&amp;amp; s.charAt(st.peek()) == '(') {
           st.pop();
          }else {
           st.push(i);
          }
      }
  }
  
  if (st.empty()) longest = n;
  else {
      int a = n, b = 0;
      while (!st.empty()) {
          b = st.peek(); st.pop();
          longest = Math.max(longest, a-b-1);
          a = b;
      }
      longest = Math.max(longest, a);
  }
  return longest;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方案，可以比较清晰的看到，解题的思路，但是可能清晰的看到优化的空间，因为后面遍历stack的过程，可以融合在第一次遍历s的过程中。就如思路中所描述的那样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int longestValidParentheses(String s) {
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;();
        int max=0;
        // 匹配开始的节点
        int left = -1;//设想是(),匹配结束的i应该是1，则1-（-1） = 2 
        for(int j=0;j&amp;lt;s.length();j++){
            if(s.charAt(j)=='(') stack.push(j);
            else {
                if (stack.isEmpty()) left=j;
                else{
                    stack.pop();
                    if(stack.isEmpty()) max=Math.max(max,j-left);
                    else max=Math.max(max,j-stack.peek());
                }
            }
        }
        return max;
    }

System.out.println(longestValidParentheses(&quot;()(()&quot;)); //2
System.out.println(longestValidParentheses(&quot;)()())&quot;));//4
System.out.println(longestValidParentheses1(&quot;()(()&quot;)); //2
System.out.println(longestValidParentheses1(&quot;)()())&quot;));//4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/21/leetcode32/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/21/leetcode32/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
  </channel>
</rss>
