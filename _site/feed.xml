<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 06 Sep 2019 20:38:24 +0800</pubDate>
    <lastBuildDate>Fri, 06 Sep 2019 20:38:24 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>JDK7的新特性1 ForkJoinPool</title>
        <description>&lt;p&gt;JDK7的一个新特性：ForkJoinPool 很值得一说。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;ForkJoinPool&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/14/jdk-day1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/14/jdk-day1/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>LeetCode16，17</title>
        <description>&lt;p&gt;LeetCode 第16，17题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 16. 3Sum Closest&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3Sum 变形题目，使用绝对值表示离目标值的远和近
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int threeSumClosest_copy(int[] num,int target) {
	int result = num[0]+num[1]+num[num.length-1];
	Arrays.parallelSort(num);
	int small = num[0]+num[1]+num[2];
	if(small &amp;gt;= target) return small;
	int big = num[num.length-3]+num[num.length-2]+num[num.length-1];
	if(big &amp;lt;= target) return big;

	for (int i = 0; i &amp;lt; num.length - 2; i++) {
    int start = i + 1, end = num.length - 1;
    while (start &amp;lt; end) {
        int sum = num[i] + num[start] + num[end];
        if (sum &amp;gt; target) {
            end--;
        } else {
            start++;
        }
        if (Math.abs(sum - target) &amp;lt; Math.abs(result - target)) {
            result = sum;
        }
    }
 }
 return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode 17. Letter Combinations of a Phone Number&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing digits from 2-9 inclusive,
return all possible letter combinations
that the number could represent.

A mapping of digit to letters
(just like on the telephone buttons)
is given below.
 Note that 1 does not map to any letters.

Example:

Input: &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;,
&quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;集合和排序的变种
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; letterCombinations(String digits) {
	LinkedList&amp;lt;String&amp;gt; ans = new LinkedList&amp;lt;String&amp;gt;();
	if(digits.isEmpty()) return ans;
	String[] mapping = new String[] {&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
	ans.add(&quot;&quot;);
	for(int i =0; i&amp;lt;digits.length();i++){
		int x = Character.getNumericValue(digits.charAt(i));
		while(ans.peek().length()==i){
			String t = ans.remove();
			for(char s : mapping[x].toCharArray())
				ans.add(t+s);
		}
	}
	return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里使用了迭代的思路，但是用的非常的优雅，首先是遍历给出的digits每一位的数字，
然后利用队列或者栈的先进先出的原则，循环的遍历已经组合完成的数组，添加上后来的数据，比较的巧妙和优雅。&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day4/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode14,15</title>
        <description>&lt;p&gt;LeetCode 第14,15题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 14. Longest Common Prefix&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string &quot;&quot;.

Example 1:

Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
Example 2:

Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
Note:

All given inputs are in lowercase letters a-z.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;遍历寻找即可
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public String longestCommonPrefix_copy(String[] strs) {
  if(strs == null || strs.length == 0) return &quot;&quot;;
  if(strs.length == 1) return strs[0];
  int from = 0;boolean flag = true;
  int end = strs[0].length();
  String tmp = strs[0];
  for(;from &amp;lt; end &amp;amp;&amp;amp; flag;from++) {
    for(int j = 1;j&amp;lt;strs.length;j++) {
      if(from &amp;gt;= strs[j].length() || strs[j].charAt(from) != tmp.charAt(from)) {
        flag=false;
        from = from-1;
        break;
      }
    }
  }

  return tmp.substring(0, from);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode:15. 3Sum&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先是排序，拍好了续，才能够使用“双指针的方法”，最后注意相等的值的处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/***
 * 关键在于nums的先排序
 * 然后两头堵的方式，from =0，end = length-1 ， 中间的sum = sumvalue- (from+end)
 * 循环的条件是先确定匹配值i（0 到 length-1），然后去（i+1，i+2，。。。length-1 中寻找from 和 end）
 */
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {
	List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
	Arrays.sort(nums);
	for (int i = 0; i &amp;lt; nums.length - 2; i++) {
		if (i == 0 || (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] != nums[i - 1])) {
			int from = i + 1;
			int end = nums.length - 1;
			int sumt = 0 - nums[i];
			while (from &amp;lt; end) {
				int temp = nums[from] + nums[end];
				if (sumt == temp) {
					res.add(Arrays.asList(nums[i], nums[from], nums[end]));

					while (from &amp;lt; end &amp;amp;&amp;amp; from + 1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[from] == nums[from + 1])
						from++;
					while (from &amp;lt; end &amp;amp;&amp;amp; end + 1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[end] == nums[end + 1])
						end--;

					from++;
					end--;
				} else if (sumt &amp;lt; temp) {
					end--;
				} else {
					from++;
				}
			}
	}
}
	return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day3/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode12,13</title>
        <description>&lt;p&gt;LeetCode 第12,13题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;第12题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: &quot;III&quot;
Example 2:

Input: 4
Output: &quot;IV&quot;
Example 3:

Input: 9
Output: &quot;IX&quot;
Example 4:

Input: 58
Output: &quot;LVIII&quot;
Explanation: L = 50, V = 5, III = 3.
Example 5:

Input: 1994
Output: &quot;MCMXCIV&quot;
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;阿拉伯数字到古罗马数字的转化，最关键的是确定数字的范围，但是这里有一个小技巧，如果是100，那么M的值为0个，应该怎么在代码中优雅的表述尼？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static String intToRoman(int num) {  

        //1000-3000
        String M[] = {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};
        //100-900
        String C[] = {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};
        //10-90
        String X[] = {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
        //0-9
        String I[] = {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
        // is so beautiful
        return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第13题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: &quot;III&quot;
Output: 3
Example 2:

Input: &quot;IV&quot;
Output: 4
Example 3:

Input: &quot;IX&quot;
Output: 9
Example 4:

Input: &quot;LVIII&quot;
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 5:

Input: &quot;MCMXCIV&quot;
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;古罗马数字到的阿拉伯数字转化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int romanToInt(String s) {

  if(s == null || s.length() == 0) return 0;
	int len = s.length();
	HashMap&amp;lt;Character,Integer&amp;gt; map = new HashMap&amp;lt;Character,Integer&amp;gt;();
	 map.put('I',1);
	 map.put('V',5);
	 map.put('X',10);
	 map.put('L',50);
	 map.put('C',100);
	 map.put('D',500);
	 map.put('M',1000);

	 int result = map.get(s.charAt(len -1));
	 int pivot = result;
	 for(int i = len -2; i&amp;gt;= 0;i--){
			 int curr = map.get(s.charAt(i));
			 if(curr &amp;gt;=  pivot){
			      result += curr;
			 }else{
			       result -= curr;
			 }
	 		 pivot = curr;
	 }
	return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode10</title>
        <description>&lt;p&gt;LeetCode 第10题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
Example 2:

Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.
Example 3:

Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
Example 4:

Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.
Example 5:

Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  首先确定是动态规划的匹配性的问题

  其次，确定问题的分解dp[i][j] 标识的是if s.substring(0,i) is valid for pattern p.substring(0,j) 这步是最困难的点。

  最后确定dp[i][j] 和 dp[i-1][j-1] 等之间的转移条件：
  if(p[j] == s[i]) dp[i][j] = dp[i-1][j-1];//①

  If(p[j]== '.')   dp[i][j] = dp[i-1][j-1];//②

  if(p[j]== '*') 情况比较的复杂了，分开进行讨论：//③
    if( p[j-1] != s[i]) dp[i][j] = dp[i][j-2],举例说明的话，ab* 只能是匹配的a，不能是ac

    if( p[j-1] == s[i] or p[j-1] == '.')
      dp[i][j] = dp[i-1][j] // a* 匹配 aaaa
      or dp[i][j] = dp[i][j-1] // a* 匹配 a
      or dp[i][j] = dp[i][j-2] // a* 匹配 empty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isMatch(String s, String p) {
        if(s == null || p == null) {
            return false;
        }
        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];
        state[0][0] = true;
        // no need to initialize state[i][0] as false  initialize state[0][j]
        //应用的条件是③
        for (int j = 1; j &amp;lt; state[0].length; j++) {
            if (p.charAt(j - 1) == '*') {
                if (state[0][j - 1] || (j &amp;gt; 1 &amp;amp;&amp;amp; state[0][j - 2])) {
                    state[0][j] = true;
                }
            }
        }
        // 索引的范围是从1到length，标识的是0 标识的是null，第一个字符的下标是1，所以当前值对应的字符中的下标为i-1，j-1
        for (int i = 1; i &amp;lt; state.length; i++) {
            for (int j = 1; j &amp;lt; state[0].length; j++) {
                // 上面说明的转移条件①和②
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    state[i][j] = state[i - 1][j - 1];
                }
                // 上面说明的转移条件③
                if (p.charAt(j - 1) == '*') {
                    //这个就是标识 ，不适用③的前两个条件的内容：cb 匹配 cba*
                    if (s.charAt(i - 1) != p.charAt(j - 2) &amp;amp;&amp;amp; p.charAt(j - 2) != '.') {
                        state[i][j] = state[i][j - 2];
                    } else {
                        //③中条件的完美的展示
                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];
                    }
                }
            }
        }
        return state[s.length()][p.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode11</title>
        <description>&lt;p&gt;LeetCode 第11题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;题目描述：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given n non-negative integers a1, a2, ..., an ,
where each represents a point at coordinate (i, ai).
n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).
Find two lines, which together with x-axis forms a container,
 such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].
In this case, the max area of water (blue section)
the container can contain is 49.     

Example:
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路清晰，这道题和原来的不同:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    y
    ^
    |
    |     a2
    |     |  a3          an
    |  a1 |  |     a5    |
    |  |  |  |  a4 |     |
    |  |  |  |  |  | ..  |
    ---------------------------&amp;gt;
   0   1  2  3  4  5 ..  n     x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只是为了寻找两个位置i,j 组成的桶，能够形成一个最大的容器，而不是这个题目：https://leetcode.com/problems/trapping-rain-water/&lt;/p&gt;

&lt;p&gt;这就是一个“双指针”移动的问题。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int max(int[] A) {  

    int S = 0, i = 0, j = A.length -1;
    while (i &amp;lt; j) {
        S = Math.max(S, (j - i) * Math.min(A[i], A[j]));
        if (A[i] &amp;lt; A[j]) i++; else j--;
    }
    return S;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2-3/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode09</title>
        <description>&lt;p&gt;LeetCode 第09题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不转化为String类型，就直接的翻转过来比较两个值是否一样即可。
注意翻转过程中的integer 越界问题，是不需要考虑的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isPalindrome(int num) {
		if (num &amp;lt; 0 || (x!=0 &amp;amp;&amp;amp; x%10==0)) {
			return false;
		}
		int sum = num;
		int temp = 0;
		while (sum != 0) {
			temp = temp * 10 + sum % 10;
			sum = sum / 10;
		}
		return temp == num;
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2-2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>JDK8的新特性2</title>
        <description>&lt;p&gt;JDK8的新特性：Stream&lt;/p&gt;

&lt;p&gt;第 1 部分: java.util.stream 库简介&lt;br /&gt;
第 2 部分: 使用流执行聚合&lt;br /&gt;
第 3 部分: Streams 的幕后原理&lt;br /&gt;
第 4 部分: 从并发到并行&lt;br /&gt;
第 5 部分: 并行流性能&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; myList =
    Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);

myList
    .stream()
    .filter(s -&amp;gt; s.startsWith(&quot;c&quot;))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);
// C1
// C2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Stream和其它集合类的区别在于：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;其它集合类主要关注与有限数量的数据的访问和有效管理(增删改)，而Stream并没有提供访问和管理元素的方式，而是通过声明数据源的方式，利用可计算的操作在数据源上执行，当然BaseStream.iterator() 和 BaseStream.spliterator()操作提供了遍历元素的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不知道如何的使用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;)
    .stream()
    .findFirst()
    .ifPresent(System.out::println);  // a1

long sum = ints.stream().mapToInt(Integer::intValue).sum();;


Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;)
    .map(s -&amp;gt; s.substring(1))
    .mapToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println);  // 3

Stream.of(1.0, 2.0, 3.0)
        .mapToInt(Double::intValue)
        .mapToObj(i -&amp;gt; &quot;a&quot; + i)
        .forEach(System.out::println);

    // a1
    // a2
    // a3

Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
        .filter(s -&amp;gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 11 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/11/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/11/day2/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>JDK8的新特性1</title>
        <description>&lt;p&gt;JDK8的新特性：
  1.Default Methods for Interfaces&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Lambda exxpressions&lt;/li&gt;
  &lt;li&gt;一些常见的Lamdba的使用方式
&lt;!--more--&gt;
JDK8的第一个新特性，接口中可以通过default关键字来定义方法的默认行为。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Formula {
    double calculate(int a);
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);// 4.0     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JDK8的第二个特性就是Lambda表达式。为了替换匿名的类，Java8支持了一个更加短的语法糖：lambda表达式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&amp;lt;String&amp;gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});

//lambda 表达式
Collections.sort(names,(String a,String b)-&amp;gt;{
  return b.compareTo(a);
});

// lambda short
Collections.sort(names,(String a,String b)-&amp;gt; b.compareTo(a));

//lambda shorter
Collections.sort(names,(a,b)-&amp;gt; b.compareTo(a));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如图所示，那么什么是functional interface？
functional interface 函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。这种类型的接口也称为SAM接口，即Single Abstract Method interfaces。&lt;/p&gt;

&lt;p&gt;1.函数式接口里允许定义默认方法：
2.函数式接口里允许定义静态方法：
3.函数式接口里允许定义java.lang.Object里的public方法，代码类似：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FunctionalInterface
	interface Converter&amp;lt;F, T&amp;gt; {
	    T convert(F from);
	    boolean equals(Object obj);

	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;4.函数式接口里允许子接口继承多个父接口，但每个父接口中都只能存在一个抽象方法，且必须的相同的抽象方法。代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface PConverter1&amp;lt;F, T&amp;gt; {
   T convert(F from);
}

interface PConverter2&amp;lt;F, T&amp;gt; {
   T convert(F from);
}

@FunctionalInterface
interface Converter&amp;lt;F, T&amp;gt; extends PConverter1, PConverter2{
    boolean equals(Object obj);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，Java 8 enables you to pass references of methods or constructors via the :: keyword. The above example shows how to reference a static method. But we can also reference object methods:
Java8 支持:: 操作，代表着一种对方法的调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//举例1：静态方法的使用
Converter&amp;lt;String, Integer&amp;gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123

//举例2：普通方法的使用
class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}
Something something = new Something();
Converter&amp;lt;String, String&amp;gt; converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;

//举例3：new 方法的使用

class Person {
    String firstName;
    Person() {}

    Person(String firstName) {
        this.firstName = firstName;
    }
}

interface PersonFactory&amp;lt;P extends Person&amp;gt; {
    P create(String firstName);
}

//总感觉这样写的话，会被打死！首先省掉了一个匿名的实现PersonFactory的匿名类，然后省掉了匿名类调用create的方法，最终直接写的是create方法的实现，Person的构建方法。

PersonFactory&amp;lt;Person&amp;gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接触了Lamdba的使用方式，经常会在 Google Guava 的jar中使用的一些常见的lamdba用法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; s.length() &amp;gt; 0;
predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false
Predicate&amp;lt;Boolean&amp;gt; nonNull = Objects::nonNull;
Predicate&amp;lt;Boolean&amp;gt; isNull = Objects::isNull;
Predicate&amp;lt;String&amp;gt; isEmpty = String::isEmpty;
Predicate&amp;lt;String&amp;gt; isNotEmpty = isEmpty.negate();

Function&amp;lt;String, Integer&amp;gt; toInteger = Integer::valueOf;
Function&amp;lt;String, String&amp;gt; backToString = toInteger.andThen(String::valueOf);
backToString.apply(&quot;123&quot;);     // &quot;123&quot;


Supplier&amp;lt;Person&amp;gt; personSupplier = Person::new;
personSupplier.get();   // new Person

Consumer&amp;lt;Person&amp;gt; greeter = (p) -&amp;gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));

Comparator&amp;lt;Person&amp;gt; comparator = (p1, p2) -&amp;gt; p1.firstName.compareTo(p2.firstName);
Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);
comparator.compare(p1, p2);             // &amp;gt; 0
comparator.reversed().compare(p1, p2);  // &amp;lt; 0


Optional&amp;lt;String&amp;gt; optional = Optional.of(&quot;bam&quot;);
optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;
optional.ifPresent((s) -&amp;gt; System.out.println(s.charAt(0)));     // &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/10/jdk-day0/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/10/jdk-day0/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>树形数据结构</title>
        <description>&lt;p&gt;B+，B树
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;The image below helps show the differences between B+ trees and B trees.
Advantages of B+ trees:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Because B+ trees don’t have data associated with interior nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node.&lt;/li&gt;
  &lt;li&gt;The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.
Advantage of B trees:&lt;/li&gt;
  &lt;li&gt;Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 09 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/09/datastruct/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/09/datastruct/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
  </channel>
</rss>
