<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 05 Sep 2019 10:26:27 +0800</pubDate>
    <lastBuildDate>Thu, 05 Sep 2019 10:26:27 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>LeetCode10</title>
        <description>&lt;p&gt;LeetCode 第10题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
Example 2:

Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.
Example 3:

Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
Example 4:

Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.
Example 5:

Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  首先确定是动态规划的匹配性的问题

  其次，确定问题的分解dp[i][j] 标识的是if s.substring(0,i) is valid for pattern p.substring(0,j) 这步是最困难的点。

  最后确定dp[i][j] 和 dp[i-1][j-1] 等之间的转移条件：
  if(p[j] == s[i]) dp[i][j] = dp[i-1][j-1];//①

  If(p[j]== '.')   dp[i][j] = dp[i-1][j-1];//②

  if(p[j]== '*') 情况比较的复杂了，分开进行讨论：//③
    if( p[j-1] != s[i]) dp[i][j] = dp[i][j-2],举例说明的话，ab* 只能是匹配的a，不能是ac

    if( p[j-1] == s[i] or p[j-1] == '.')
      dp[i][j] = dp[i-1][j] // a* 匹配 aaaa
      or dp[i][j] = dp[i][j-1] // a* 匹配 a
      or dp[i][j] = dp[i][j-2] // a* 匹配 empty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isMatch(String s, String p) {
        if(s == null || p == null) {
            return false;
        }
        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];
        state[0][0] = true;
        // no need to initialize state[i][0] as false  initialize state[0][j]
        //应用的条件是③
        for (int j = 1; j &amp;lt; state[0].length; j++) {
            if (p.charAt(j - 1) == '*') {
                if (state[0][j - 1] || (j &amp;gt; 1 &amp;amp;&amp;amp; state[0][j - 2])) {
                    state[0][j] = true;
                }
            }
        }
        // 索引的范围是从1到length，标识的是0 标识的是null，第一个字符的下标是1，所以当前值对应的字符中的下标为i-1，j-1
        for (int i = 1; i &amp;lt; state.length; i++) {
            for (int j = 1; j &amp;lt; state[0].length; j++) {
                // 上面说明的转移条件①和②
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    state[i][j] = state[i - 1][j - 1];
                }
                // 上面说明的转移条件③
                if (p.charAt(j - 1) == '*') {
                    //这个就是标识 ，不适用③的前两个条件的内容：cb 匹配 cba*
                    if (s.charAt(i - 1) != p.charAt(j - 2) &amp;amp;&amp;amp; p.charAt(j - 2) != '.') {
                        state[i][j] = state[i][j - 2];
                    } else {
                        //③中条件的完美的展示
                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];
                    }
                }
            }
        }
        return state[s.length()][p.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode08</title>
        <description>&lt;p&gt;LeetCode 第08题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

Note:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.
Example 1:

Input: &quot;42&quot;
Output: 42
Example 2:

Input: &quot;   -42&quot;
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
Example 3:

Input: &quot;4193 with words&quot;
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
Example 4:

Input: &quot;words and 987&quot;
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.
Example 5:

Input: &quot;-91283472332&quot;
Output: -2147483648
Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意异常情况的处理，注意越界
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public int myAtoi(String str) {
        if(str == null || str.isEmpty()) return 0;
        str = str.trim();
        int index = 0;
        int res = 0;
        int fh = 1;
        while(i &amp;lt; str.length()){
          char temp = str.charAt(i);
			    if (str.charAt(i) == '-' &amp;amp;&amp;amp; i == 0) {
				        fh = -1;
				        i++;
				        continue;
			    }else if (str.charAt(i) == '+' &amp;amp;&amp;amp; i == 0) {
                fh = 1;
			          i++;
			      	continue;
			    }else if(temp &amp;gt;= '0' &amp;amp;&amp;amp; temp &amp;lt;= '9'){
            int ctmp = Character.digit(str.chatAt(i),10);
            if(Integer.MAX_VALUE/10 &amp;lt; res || Integer.MAX_VALUE/10 == total &amp;amp;&amp;amp; Integer.MAX_VALUE %10 &amp;lt; ctmp){
              return fh == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }else{
              value =ctmp +value *10
            }  
          }else{
            break;
          }
          i++;  
        }
        return fh*res;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2-3/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode09</title>
        <description>&lt;p&gt;LeetCode 第09题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不转化为String类型，就直接的翻转过来比较两个值是否一样即可。
注意翻转过程中的integer 越界问题，是不需要考虑的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isPalindrome(int num) {
		if (num &amp;lt; 0 || (x!=0 &amp;amp;&amp;amp; x%10==0)) {
			return false;
		}
		int sum = num;
		int temp = 0;
		while (sum != 0) {
			temp = temp * 10 + sum % 10;
			sum = sum / 10;
		}
		return temp == num;
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2-2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>JDK8的新特性2</title>
        <description>&lt;p&gt;JDK8的新特性：Stream&lt;/p&gt;

&lt;p&gt;第 1 部分: java.util.stream 库简介&lt;br /&gt;
第 2 部分: 使用流执行聚合&lt;br /&gt;
第 3 部分: Streams 的幕后原理&lt;br /&gt;
第 4 部分: 从并发到并行&lt;br /&gt;
第 5 部分: 并行流性能&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int totalSalesFromNY
    = txns.stream()
          .filter(t -&amp;gt; t.getSeller().getAddr().getState().equals(&quot;NY&quot;))
          .mapToInt(t -&amp;gt; t.getAmount())
          .sum();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 11 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/11/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/11/day2/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>JDK8的新特性1</title>
        <description>&lt;p&gt;JDK8的新特性：
  1.Default Methods for Interfaces&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Lambda exxpressions&lt;/li&gt;
  &lt;li&gt;一些常见的Lamdba的使用方式
&lt;!--more--&gt;
JDK8的第一个新特性，接口中可以通过default关键字来定义方法的默认行为。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Formula {
    double calculate(int a);
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);// 4.0     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JDK8的第二个特性就是Lambda表达式。为了替换匿名的类，Java8支持了一个更加短的语法糖：lambda表达式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&amp;lt;String&amp;gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});

//lambda 表达式
Collections.sort(names,(String a,String b)-&amp;gt;{
  return b.compareTo(a);
});

// lambda short
Collections.sort(names,(String a,String b)-&amp;gt; b.compareTo(a));

//lambda shorter
Collections.sort(names,(a,b)-&amp;gt; b.compareTo(a));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如图所示，那么什么是functional interface？
functional interface 函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。这种类型的接口也称为SAM接口，即Single Abstract Method interfaces。&lt;/p&gt;

&lt;p&gt;1.函数式接口里允许定义默认方法：
2.函数式接口里允许定义静态方法：
3.函数式接口里允许定义java.lang.Object里的public方法，代码类似：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FunctionalInterface
	interface Converter&amp;lt;F, T&amp;gt; {
	    T convert(F from);
	    boolean equals(Object obj);

	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;4.函数式接口里允许子接口继承多个父接口，但每个父接口中都只能存在一个抽象方法，且必须的相同的抽象方法。代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface PConverter1&amp;lt;F, T&amp;gt; {
   T convert(F from);
}

interface PConverter2&amp;lt;F, T&amp;gt; {
   T convert(F from);
}

@FunctionalInterface
interface Converter&amp;lt;F, T&amp;gt; extends PConverter1, PConverter2{
    boolean equals(Object obj);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，Java 8 enables you to pass references of methods or constructors via the :: keyword. The above example shows how to reference a static method. But we can also reference object methods:
Java8 支持:: 操作，代表着一种对方法的调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//举例1：静态方法的使用
Converter&amp;lt;String, Integer&amp;gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123

//举例2：普通方法的使用
class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}
Something something = new Something();
Converter&amp;lt;String, String&amp;gt; converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;

//举例3：new 方法的使用

class Person {
    String firstName;
    Person() {}

    Person(String firstName) {
        this.firstName = firstName;
    }
}

interface PersonFactory&amp;lt;P extends Person&amp;gt; {
    P create(String firstName);
}

//总感觉这样写的话，会被打死！首先省掉了一个匿名的实现PersonFactory的匿名类，然后省掉了匿名类调用create的方法，最终直接写的是create方法的实现，Person的构建方法。

PersonFactory&amp;lt;Person&amp;gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接触了Lamdba的使用方式，经常会在 Google Guava 的jar中使用的一些常见的lamdba用法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; s.length() &amp;gt; 0;
predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false
Predicate&amp;lt;Boolean&amp;gt; nonNull = Objects::nonNull;
Predicate&amp;lt;Boolean&amp;gt; isNull = Objects::isNull;
Predicate&amp;lt;String&amp;gt; isEmpty = String::isEmpty;
Predicate&amp;lt;String&amp;gt; isNotEmpty = isEmpty.negate();

Function&amp;lt;String, Integer&amp;gt; toInteger = Integer::valueOf;
Function&amp;lt;String, String&amp;gt; backToString = toInteger.andThen(String::valueOf);
backToString.apply(&quot;123&quot;);     // &quot;123&quot;


Supplier&amp;lt;Person&amp;gt; personSupplier = Person::new;
personSupplier.get();   // new Person

Consumer&amp;lt;Person&amp;gt; greeter = (p) -&amp;gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));

Comparator&amp;lt;Person&amp;gt; comparator = (p1, p2) -&amp;gt; p1.firstName.compareTo(p2.firstName);
Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);
comparator.compare(p1, p2);             // &amp;gt; 0
comparator.reversed().compare(p1, p2);  // &amp;lt; 0


Optional&amp;lt;String&amp;gt; optional = Optional.of(&quot;bam&quot;);
optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;
optional.ifPresent((s) -&amp;gt; System.out.println(s.charAt(0)));     // &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/10/day0/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/10/day0/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>树形数据结构</title>
        <description>&lt;p&gt;B+，B树
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;The image below helps show the differences between B+ trees and B trees.
Advantages of B+ trees:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Because B+ trees don’t have data associated with interior nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node.&lt;/li&gt;
  &lt;li&gt;The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.
Advantage of B trees:&lt;/li&gt;
  &lt;li&gt;Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 09 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/09/datastruct/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/09/datastruct/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>编码编不下去了怎么办？</title>
        <description>&lt;p&gt;How to program when you don’t feel like it
  不想干的时候怎么办？
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;I recently well and truly “hit the wall” when it came to coding.
Every time I sat down to code, I felt stuck, like I wasn’t making any progress at all.
I was tired, de-motivated and dealing with headaches.
我很累，没有动力去处理头痛问题。
Any will to code I had previously had seemed completely gone and
when I finally got around to programming I only did the bare minimum.最低限度。&lt;/p&gt;

&lt;p&gt;Here I was on day 52 of my 100 days of code and I didn’t want to break my streak,
but there was nothing but frustration every time I sat down to program.
After a few days of this, I decided it wasn’t a sustainable solution, it was costing me more than than I was gaining.
Something had to change.
Here are some things that helped get me back on track.&lt;/p&gt;

&lt;p&gt;If you find yourself completely and utterly stuck on whatever you’re working with, don’t try to force it.
You’re more likely to produce a mess that you will dread having to work with next time and
you end up in a self reinforcing loop of shitty days.&lt;/p&gt;

&lt;p&gt;Maybe you’ve been putting off this cool tutorial or
there’s a few easy challenges on websites such as hackerrank, codewars or kattis that you can do.
It doesn’t really matter what you do, but it needs to be easy and quick.
It will boost your confidence in your programming skills and give you some much needed wins.
它将增强您对编程技巧的信心，并为您提供一些急需的胜利。&lt;/p&gt;

&lt;p&gt;You can also go back to the documentation or
see if you can find some tutorials on your problem.
Sometimes you need to go back to basic and maybe do a few exercises on the concepts involved in your project.
回头查看教程或者基础的内容&lt;/p&gt;

&lt;p&gt;Stay here until you feel comfortable cracking on with the thing that was causing you trouble.
If you find yourself easily distracted, try using the pomodoro technique.
It’s basically 25 min of focused work and a 5 minute break you repeat until you have reached your goal .
可以尝试番茄工作法&lt;/p&gt;

&lt;p&gt;The most important thing is progress, especially if it is for something like 100DaysOfCode,
but just learning in general.
Not every day is going to be equally good, but you decide how bad a bad day is.
So on bad days, stick to small achievable goals.
Gain that confidence and motivation back.
重要的是保持confidence和motivation&lt;/p&gt;

&lt;p&gt;It took me a few days of solving progressively more difficult problems in the programming language I know best,
before I felt like going back to my project. It took me 15 minutes to find and fix something that had caused me trouble for 3 days. 😅&lt;/p&gt;

&lt;p&gt;Hope some of these tips were helpful. Feel free to reach out on Twitter or comment with feedback, it’s much appreciated.
Thank you for reading ❤️&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/07/netty/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/07/netty/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（五）红黑树的删除</title>
        <description>&lt;p&gt;红黑树的删除逻辑和HashMap中的删除逻辑，是有不同的，因为在HashMap中需要维护next的属性，以便于在tree转为linkedlist的时候，比较的方便。&lt;/p&gt;

&lt;p&gt;所以我们先从普通的红黑树的删除逻辑说起。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;红黑树的删除操作&quot;&gt;红黑树的删除操作&lt;/h3&gt;

&lt;p&gt;删除操作首先需要做的也是BST（二叉搜索树）的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置（当前节点右子树的最左节点）。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。&lt;/p&gt;

&lt;p&gt;删除修复操作在遇到被删除的节点是红色节点（从2-3树的逻辑上面来看，红色节点直接删除即可，剩下的部分直接的补到红色节点相连的黑色节点即可）或者到达root节点时，修复操作完毕。&lt;/p&gt;

&lt;p&gt;删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条（经过的黑色节点是一致的约束）。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。&lt;/p&gt;

&lt;p&gt;删除操作的总体思想是从&lt;strong&gt;兄弟节点借调黑色节点&lt;/strong&gt;使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。&lt;/p&gt;

&lt;p&gt;删除修复操作分为四种情况(删除黑节点后)：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;待删除的节点的兄弟节点是红色的节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;情况1&quot;&gt;情况1&lt;/h4&gt;

&lt;p&gt;case1 由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。&lt;/p&gt;

&lt;p&gt;case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。&lt;/p&gt;

&lt;p&gt;之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p1.jpg)&quot; alt=&quot;图1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况2&quot;&gt;情况2&lt;/h4&gt;

&lt;p&gt;case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。&lt;/p&gt;

&lt;p&gt;case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p2.jpg)&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况3&quot;&gt;情况3&lt;/h4&gt;

&lt;p&gt;case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。&lt;/p&gt;

&lt;p&gt;之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p3.jpg)&quot; alt=&quot;图3&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况4&quot;&gt;情况4&lt;/h4&gt;

&lt;p&gt;Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。&lt;/p&gt;

&lt;p&gt;Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;![图1](https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/p4.jpg)&quot; alt=&quot;图4&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;删除操作的总结&quot;&gt;删除操作的总结&lt;/h4&gt;

&lt;p&gt;红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。&lt;/p&gt;

&lt;p&gt;对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。&lt;/p&gt;

&lt;p&gt;对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。&lt;/p&gt;

&lt;p&gt;具体的代码为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** From CLR */
	private void fixAfterDeletion(Node x) {
		while (x != root &amp;amp;&amp;amp; colorOf(x) == BLACK) {
			if (x == leftOf(parentOf(x))) {
				Node uncle = rightOf(parentOf(x));

				if (colorOf(uncle) == RED) {
					setColor(uncle, BLACK);
					setColor(parentOf(x), RED);
					rotateLeft(parentOf(x));
					uncle = rightOf(parentOf(x));
				}

				if (colorOf(leftOf(uncle)) == BLACK &amp;amp;&amp;amp; colorOf(rightOf(uncle)) == BLACK) {
					setColor(uncle, RED);
					x = parentOf(x);
				} else {
					if (colorOf(rightOf(uncle)) == BLACK) {
						setColor(leftOf(uncle), BLACK);
						setColor(uncle, RED);
						rotateRight(uncle);
						uncle = rightOf(parentOf(x));
					}
					setColor(uncle, colorOf(parentOf(x)));
					setColor(parentOf(x), BLACK);
					setColor(rightOf(uncle), BLACK);
					rotateLeft(parentOf(x));
					x = root;
				}
			} else { // symmetric
				assert x == rightOf((parentOf(x)));
				Node brother = leftOf(parentOf(x));

				if (colorOf(brother) == RED) {
					setColor(brother, BLACK);
					setColor(parentOf(x), RED);
					rotateRight(parentOf(x));
					brother = leftOf(parentOf(x));
				}

				if (colorOf(rightOf(brother)) == BLACK &amp;amp;&amp;amp; colorOf(leftOf(brother)) == BLACK) {
					setColor(brother, RED);
					x = parentOf(x);
				} else {
					if (colorOf(leftOf(brother)) == BLACK) {
						setColor(rightOf(brother), BLACK);
						setColor(brother, RED);
						rotateLeft(brother);
						brother = leftOf(parentOf(x));
					}
					setColor(brother, colorOf(parentOf(x)));
					setColor(parentOf(x), BLACK);
					setColor(leftOf(brother), BLACK);
					rotateRight(parentOf(x));
					x = root;
				}
			}
		}

		setColor(x, BLACK);
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 06 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/06/hashmap/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/06/hashmap/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（四）红黑树的插入</title>
        <description>&lt;p&gt;理解了2-3树和红黑树的对应的关系，再去梳理红黑树的插入和删除操作，就会更加的容易理解和记忆一点。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;红黑树的插入操作&quot;&gt;红黑树的插入操作&lt;/h3&gt;

&lt;h4 id=&quot;情况1&quot;&gt;情况1&lt;/h4&gt;

&lt;p&gt;当为Null树的时候，插入第一个节点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;节点设置为根节点，设置为黑色，如下图所示：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt1.jpg&quot; alt=&quot;图1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;情况2&quot;&gt;情况2&lt;/h4&gt;
&lt;p&gt;存在父节点的情况下，插入节点，分为两种情况：2-3树上面就是有2节点形成3节点的过程。
  2.1 插入的是左节点，也就是比父节点要小，直接的插入即可,但是需要考虑着色的问题。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt2.jpg&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.2 如果插入的节点比父节点大，就需要变换顺序，外加改变颜色了，如下图：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt3.jpg&quot; alt=&quot;图3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中的坐旋转，使用文字描述为：&lt;/p&gt;

&lt;p&gt;左旋： 右节点（right）和其父节点（right-parent）进行交换，交换的过程中，right-parent 的右分支被强制的叉开，所以把right的左孩子（right-left）放到了right-parent 的右分支，然后把right-parent 放到了right的左孩子上。&lt;/p&gt;

&lt;p&gt;图片的描述为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt4.jpg&quot; alt=&quot;图4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码描述为：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** From CLR
 *  旋转节点：为 p.right
 *  方法的输入的参数为 旋转子树的根节点，可以理解为图中的node节点
 * */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rotateLeft&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// p的右节点即是旋转上升的节点，然后旋转上升后，该节点的左节点为P，原来的左节点，这是为p的右节点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 设置循转节点的父节点，以及P原来父节点的指向的设置&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//旋转节点为右节点，原来的左孩子设置为P&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;情况3&quot;&gt;情况3&lt;/h4&gt;
&lt;p&gt;在父节点存在的情况下，如果左孩子的左孩子一直插入的情况下，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt5.jpg&quot; alt=&quot;图5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候就是右旋的操作，具体的文字描述为：&lt;/p&gt;

&lt;p&gt;右旋： 左节点（left）和其父节点（left-parent）进行交换，交换的过程中，left-parent 的左分支被强制的叉开，所以把left的右孩子（left-right）放到了left-parent 的左分支，然后把left-parent 放到了left的左孩子上。&lt;/p&gt;

&lt;p&gt;具体的图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt6.jpg&quot; alt=&quot;图6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的代码示例为：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** From CLR
	 * 该方法的参数，并不是被旋转的节点，而是调整子树的根节点，可以理解为图中的node节点
	 * */&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rotateRight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// p的左节点设置为 原来左节点的右子树&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;c1&quot;&gt;// 旋转过程中父节点的设置，上升节点的父节点以及原来父节点的指向的设置&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;c1&quot;&gt;// 最后右节点和p旋转后父节点的设置&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;情况4&quot;&gt;情况4：&lt;/h4&gt;
&lt;p&gt;特殊的情况下，如：红色的右节点下插入左孩子，或者红色的左节点下，插入右孩子。
具体的情况的一种如下图所示：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt7.jpg&quot; alt=&quot;图7&quot; /&gt;
针对这种情况，第一步我们可以通过一次左旋转，变成我们熟悉的情况3.具体的操作如下图所示：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt8.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入的情况总结&quot;&gt;插入的情况总结&lt;/h3&gt;

&lt;p&gt;具体的操作分为三种：左旋，右旋，变色
具体的情况如下图所示：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/tt9.jpg&quot; alt=&quot;图9&quot; /&gt;
具体的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int put(K key) {
		Node t = root;
		if (t == null) {
			root = new Node(key, null);
			size = 1;
			modCount++;
			return 1;
		}

		Node parent = findParent(key);
		if (parent != null) {
			int cmp = this.comparator != null ? this.comparator.compare(key, parent.key)
					: ((Comparable&amp;lt;? super K&amp;gt;) key).compareTo(parent.key);
			Node e = new Node(key, parent);
			if (cmp &amp;lt; 0)
				parent.left = e;
			else
				parent.right = e;
			fixAfterInsertion(e);
			size++;
			modCount++;
			return 1;
		} else {
			return -1;
		}
	}

  private void fixAfterInsertion(Node x) {
		x.color = RED;
		// x 为null，x为root的第一个节点，直接的跳走
		/**
		 * 如果x parent 节点为黑，那么x 为红，直接的跳过即可。
		 * */
		while (x != null &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color == RED) {
			if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
				Node uncle = rightOf(parentOf(parentOf(x)));
				if (colorOf(uncle) == RED) {
					// 图三
					setColor(parentOf(x), BLACK);
					setColor(uncle, BLACK);
					setColor(parentOf(parentOf(x)), RED);
					x = parentOf(parentOf(x));
				} else {
					// uncle 节点为黑或者uncle 节点为null
					if (x == rightOf(parentOf(x))) {
						x = parentOf(x);
						/**
						 * 这个操作，非常的有意思，按照左旋方法的定义，参数应该是旋转子树的根节点，但是这个传入的是旋转节点
						 * 然后，就变成了：x右节点和x交换位置，并且在交换位置的过程中，x有右节点变为了左节点。
						 * 图②
						 * */
						rotateLeft(x);
					}
					// 调整颜色，当前节点为红色节点，是定死的。所以把父节点设为黑，爷节节点设置为红
					setColor(parentOf(x), BLACK);
					setColor(parentOf(parentOf(x)), RED);
					// x 为left节点，进行右旋
					// 图①
					rotateRight(parentOf(parentOf(x)));
				}
			} else {
				Node uncle = leftOf(parentOf(parentOf(x)));
				if (colorOf(uncle) == RED) {
					setColor(parentOf(x), BLACK);
					setColor(uncle, BLACK);
					setColor(parentOf(parentOf(x)), RED);
					x = parentOf(parentOf(x));
				} else {
					if (x == leftOf(parentOf(x))) {
						x = parentOf(x);
						rotateRight(x);
					}
					setColor(parentOf(x), BLACK);
					setColor(parentOf(parentOf(x)), RED);
					rotateLeft(parentOf(parentOf(x)));
				}
			}
		}
		root.color = BLACK;
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/05/hashmap/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/05/hashmap/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>沉下心来分析HashMap的源码（三）学习红黑树</title>
        <description>&lt;p&gt;HashMap的源码在JDK 1.8后引入了红黑树，但是看到红黑树的定义：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个节点或者是红色，或者是黑色&lt;/li&gt;
  &lt;li&gt;根节点是黑色&lt;/li&gt;
  &lt;li&gt;每一个叶子节点(最后的空节点)是黑色的&lt;/li&gt;
  &lt;li&gt;如果一个节点是红色的，那么它的孩子节点都是黑色的&lt;/li&gt;
  &lt;li&gt;从任意一个节点到叶子节点，经过的黑色节点是一样的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完全的不清楚为什么这么定义，以及这么定义的原因是什么。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;先导&quot;&gt;先导&lt;/h3&gt;

&lt;p&gt;先说红黑树的由来，是为了查找的平衡，从二叉查找树说起。&lt;/p&gt;

&lt;p&gt;二叉查找树：从根节点开始，左节点的值小于根节点，右节点的值大于右节点。并且每一颗子树都满足这个条件，所以便于查找：查找的时候，只需要比对就能够瞬速的找到所在子树，继而找到对应的节点。但是二叉查找树有一个缺点就是：容易偏向一侧，我们向往的二叉查找树是图一，结果却有很多图二的情况。
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t1.jpg&quot; alt=&quot;图1&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t2.jpg&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;平衡树2-3树&quot;&gt;平衡树：2-3树&lt;/h3&gt;
&lt;p&gt;在这种需求下，平衡树的概念就应运而生了。红黑树就是一种平衡树，它可以保证二叉树基本符合我们预料的那种平衡的结构，但是理解红黑树之前，必须先了解另一种树，叫2-3树，红黑树背后的逻辑就是它。&lt;/p&gt;

&lt;p&gt;2-3树：2-3树满足二分搜索树的性质。不同的是在2-3树中，存在两种节点。一种是有两个叶子节点的，我们称作“2节点” 如图3；另一种是有三个叶子节点的，我们称作“3节点”，如图4，图5展示的是一个完整的2-3 树，满足从根节点到任意一个叶子节点的高度都是相同的。
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t3.jpg&quot; alt=&quot;图3&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t4.jpg&quot; alt=&quot;图4&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t5.jpg&quot; alt=&quot;图5&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-3树如何保持平衡&quot;&gt;2-3树如何保持平衡&lt;/h3&gt;

&lt;p&gt;2-3树平衡的保持，主要依赖两个操作：拆分和合并。其中拆分主要发生在3节点插入时候，如下图6，图7完整的展示可一个查分的过程：
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t6.jpg&quot; alt=&quot;图6&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t7.jpg&quot; alt=&quot;图7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拆分的过程主要是形成了一个4节点（类似于2节点，3节点的概念），(4 7 9) 这个节点，然后通过4节点的中间状态查分为三个2节点. &lt;br /&gt;
但是在图7的第二步，拆分过后的2-3树已经不满足：从根节点到任意的叶子节点的高度是完全一致的平衡性，所以我们需要合并的操作，如图7中的第三步。&lt;/p&gt;

&lt;p&gt;如果合并过程中，出现了四节点，那么我们再次的查分，这两个操作可以混合使用，如图8.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t8.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-3树和红黑树的关系&quot;&gt;2-3树和红黑树的关系&lt;/h3&gt;

&lt;p&gt;对于2-3树中的“2节点”，对应于红黑树中的“黑节点”，即相当于普通二分搜索树中的一个节点。&lt;/p&gt;

&lt;p&gt;对于2-3树中的“3节点”，相当于普通二分搜索树中的两个节点融合在一起，我们如何来描述这种融合在一起的两个节点之间的关系呢？&lt;/p&gt;

&lt;p&gt;其实很简单，如果我们将连接这两个节点的边涂成红色，就可以表示这两个节点是融合的关系，即2-3树中的一个“3节点”。&lt;/p&gt;

&lt;p&gt;对于树这种数据结构，我们在定义的时候通常都是针对节点进行定义，并没有对节点之间的边进行定义，我们如何来表示这条被涂成红色的边呢？&lt;/p&gt;

&lt;p&gt;大家都知道，对于树中的任意一个节点，都是只有一个父亲节点，所以与其父节点相连接的边可以用该节点进行表示。那么我们就可以将这两个节点中较小的节点（作为左子树的节点）涂成红色，就可以很好地表示这两个节点融合的关系了。&lt;/p&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t9.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后一颗2-3树的就可以转化为一颗红黑树了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AndiHappy/blogimage/master/post/2019/t10.jpg&quot; alt=&quot;图8&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;再次的分析红黑树的性质&quot;&gt;再次的分析红黑树的性质&lt;/h3&gt;

&lt;p&gt;讨论了2-3树与红黑树之间的关系，我们再回过头来看一下红黑树的5条定义和性质，会发现很好理解了。&lt;/p&gt;

&lt;p&gt;1.每个节点或者是红色，或者是黑色
这条定义很好理解，在此不做解释。&lt;/p&gt;

&lt;p&gt;2.根节点是黑色&lt;/p&gt;

&lt;p&gt;根据之前说过的，红色的节点对应于2-3树中“3节点”中较小的那个节点，拆成两个“2节点”的话则是一个左子树的节点，即&lt;strong&gt;红色的节点总是可以和其父节点进行融合&lt;/strong&gt;，所以红色节点一定有父节点，显然根节点不能是红色，所以根节点是黑色。&lt;/p&gt;

&lt;p&gt;3.每一个叶子节点(最后的空节点)是黑色的&lt;/p&gt;

&lt;p&gt;这条性质和第2条是对应的。对于叶子节点（最后的空节点），一颗空树的根节点也为黑色，所以与其说第三条是一条性质，不如说也是一个定义。&lt;/p&gt;

&lt;p&gt;4.如果一个节点是红色的，那么它的孩子节点都是黑色的&lt;/p&gt;

&lt;p&gt;根据上面2-3树与红黑树两种节点的对比图，我们很容易看到，红色节点的两个子树，对应2-3树中的话，要么是一个“2节点”，要么是一个“3节点”，而不管是“2节点”还是“3节点”，相连的第一个节点都是黑色的，所以说红色节点的孩子节点都是黑色的。&lt;/p&gt;

&lt;p&gt;5.从任意一个节点到叶子节点，经过的黑色节点是一样的&lt;/p&gt;

&lt;p&gt;根据2-3树与红黑树的关系对比图，可以发现，红黑树中一个黑色节点对应2-3树中一整个节点（“2节点”或“3节点”），而2-3树是完全平衡的树，从根节点到任意路径的叶子节点，经过的节点个数都是相同的，对应红黑树中，即从任意节点到叶子节点，经过的黑色节点是一样的。&lt;/p&gt;

&lt;p&gt;对比2-3树总结起来，其实也就两条。其中一条是关于着色的：每个节点都有颜色，非红即黑。根节点，叶子节点为黑色。红色节点的孩子节点为黑色。另外一条是关于2-3树的平衡性的。即是到每一个叶子节点是平衡的，对应的红黑树，也就是经过的黑色节点是一样的。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/04/hashmap0/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/04/hashmap0/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
  </channel>
</rss>
