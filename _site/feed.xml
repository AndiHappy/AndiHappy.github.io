<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 07 Sep 2019 00:03:28 +0800</pubDate>
    <lastBuildDate>Sat, 07 Sep 2019 00:03:28 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>JDK7的新特性1 ForkJoinPool</title>
        <description>&lt;p&gt;JDK7的一个新特性：ForkJoinPool 很值得一说。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;ForkJoinPool&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/14/jdk-day1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/14/jdk-day1/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>LeetCode18, 19</title>
        <description>&lt;p&gt;LeetCode 第18，19题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 18. 4Sum&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:

Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3Sum 变形题目，同一个思路
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) {
      List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
    List&amp;lt;Integer&amp;gt; l;
    Arrays.sort(nums);
    int len = nums.length;
    for (int i = 0; i &amp;lt; len - 3; i++) {
      // 相同直接返回
      if (i != 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue;
      // 最小值如果大于target，直接的返回
      if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &amp;gt; target) break;
      // 此值和最大的三个值相加，小于target 直接的返回
      if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 2] &amp;lt; target) continue;

      for (int j = i + 1; j &amp;lt; len - 2; j++) {
        // 相同直接返回
        if (j != i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue;
        // 最小值如果大于target，直接的返回
        if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &amp;gt; target) break;
        // 此值和最大的三个值相加，小于target 直接的返回
        if (nums[i] + nums[j] + nums[len - 1] + nums[len - 2] &amp;lt; target) continue;

        int head = j + 1, end = len - 1;
        while (head &amp;lt; end) {
          int tempt = nums[i] + nums[j] + nums[head] + nums[end];
          if (tempt == target) {
            l = new ArrayList&amp;lt;Integer&amp;gt;();
            l.add(nums[i]);
            l.add(nums[j]);
            l.add(nums[head]);
            l.add(nums[end]);
            list.add(l);
            head++;
			end--;
            while (head &amp;lt; end &amp;amp;&amp;amp; nums[head] == nums[head - 1]) {
              head++;
            }
			while (head &amp;lt; end &amp;amp;&amp;amp; nums[end] == nums[end+1]) {
              end--;
            }
          } else if (tempt &amp;gt; target)
            end--;
          else
            head++;
        }
      }
    }
    return list; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode 19. Remove Nth Node From End of List&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.

After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;简单题目，注意链表的表头的处理，下标的处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode removeNthFromEnd(ListNode head, int n) {
    
    ListNode start = new ListNode(0);
    ListNode slow = start, fast = start;
    slow.next = head;
    
    //Move fast in front so that the gap between slow and fast becomes n
    for(int i=1; i&amp;lt;=n+1; i++)   {
        fast = fast.next;
    }
    //Move fast to the end, maintaining the gap
    while(fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    //Skip the desired node
    slow.next = slow.next.next;
    return start.next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/14/day4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/14/day4/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode16，17</title>
        <description>&lt;p&gt;LeetCode 第16，17题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 16. 3Sum Closest&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3Sum 变形题目，使用绝对值表示离目标值的远和近
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int threeSumClosest_copy(int[] num,int target) {
	int result = num[0]+num[1]+num[num.length-1];
	Arrays.parallelSort(num);
	int small = num[0]+num[1]+num[2];
	if(small &amp;gt;= target) return small;
	int big = num[num.length-3]+num[num.length-2]+num[num.length-1];
	if(big &amp;lt;= target) return big;

	for (int i = 0; i &amp;lt; num.length - 2; i++) {
    int start = i + 1, end = num.length - 1;
    while (start &amp;lt; end) {
        int sum = num[i] + num[start] + num[end];
        if (sum &amp;gt; target) {
            end--;
        } else {
            start++;
        }
        if (Math.abs(sum - target) &amp;lt; Math.abs(result - target)) {
            result = sum;
        }
    }
 }
 return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode 17. Letter Combinations of a Phone Number&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a string containing digits from 2-9 inclusive,
return all possible letter combinations
that the number could represent.

A mapping of digit to letters
(just like on the telephone buttons)
is given below.
 Note that 1 does not map to any letters.

Example:

Input: &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;,
&quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;集合和排序的变种
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; letterCombinations(String digits) {
	LinkedList&amp;lt;String&amp;gt; ans = new LinkedList&amp;lt;String&amp;gt;();
	if(digits.isEmpty()) return ans;
	String[] mapping = new String[] {&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
	ans.add(&quot;&quot;);
	for(int i =0; i&amp;lt;digits.length();i++){
		int x = Character.getNumericValue(digits.charAt(i));
		while(ans.peek().length()==i){
			String t = ans.remove();
			for(char s : mapping[x].toCharArray())
				ans.add(t+s);
		}
	}
	return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里使用了迭代的思路，但是用的非常的优雅，首先是遍历给出的digits每一位的数字，
然后利用队列或者栈的先进先出的原则，循环的遍历已经组合完成的数组，添加上后来的数据，比较的巧妙和优雅。&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day4/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day4/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode14,15</title>
        <description>&lt;p&gt;LeetCode 第14,15题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;LeetCode 14. Longest Common Prefix&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string &quot;&quot;.

Example 1:

Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
Example 2:

Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
Note:

All given inputs are in lowercase letters a-z.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;遍历寻找即可
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public String longestCommonPrefix_copy(String[] strs) {
  if(strs == null || strs.length == 0) return &quot;&quot;;
  if(strs.length == 1) return strs[0];
  int from = 0;boolean flag = true;
  int end = strs[0].length();
  String tmp = strs[0];
  for(;from &amp;lt; end &amp;amp;&amp;amp; flag;from++) {
    for(int j = 1;j&amp;lt;strs.length;j++) {
      if(from &amp;gt;= strs[j].length() || strs[j].charAt(from) != tmp.charAt(from)) {
        flag=false;
        from = from-1;
        break;
      }
    }
  }

  return tmp.substring(0, from);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LeetCode:15. 3Sum&lt;/p&gt;

&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先是排序，拍好了续，才能够使用“双指针的方法”，最后注意相等的值的处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/***
 * 关键在于nums的先排序
 * 然后两头堵的方式，from =0，end = length-1 ， 中间的sum = sumvalue- (from+end)
 * 循环的条件是先确定匹配值i（0 到 length-1），然后去（i+1，i+2，。。。length-1 中寻找from 和 end）
 */
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {
	List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
	Arrays.sort(nums);
	for (int i = 0; i &amp;lt; nums.length - 2; i++) {
		if (i == 0 || (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] != nums[i - 1])) {
			int from = i + 1;
			int end = nums.length - 1;
			int sumt = 0 - nums[i];
			while (from &amp;lt; end) {
				int temp = nums[from] + nums[end];
				if (sumt == temp) {
					res.add(Arrays.asList(nums[i], nums[from], nums[end]));

					while (from &amp;lt; end &amp;amp;&amp;amp; from + 1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[from] == nums[from + 1])
						from++;
					while (from &amp;lt; end &amp;amp;&amp;amp; end + 1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[end] == nums[end + 1])
						end--;

					from++;
					end--;
				} else if (sumt &amp;lt; temp) {
					end--;
				} else {
					from++;
				}
			}
	}
}
	return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day3/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode12,13</title>
        <description>&lt;p&gt;LeetCode 第12,13题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;第12题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: &quot;III&quot;
Example 2:

Input: 4
Output: &quot;IV&quot;
Example 3:

Input: 9
Output: &quot;IX&quot;
Example 4:

Input: 58
Output: &quot;LVIII&quot;
Explanation: L = 50, V = 5, III = 3.
Example 5:

Input: 1994
Output: &quot;MCMXCIV&quot;
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;阿拉伯数字到古罗马数字的转化，最关键的是确定数字的范围，但是这里有一个小技巧，如果是100，那么M的值为0个，应该怎么在代码中优雅的表述尼？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static String intToRoman(int num) {  

        //1000-3000
        String M[] = {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};
        //100-900
        String C[] = {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};
        //10-90
        String X[] = {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
        //0-9
        String I[] = {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
        // is so beautiful
        return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第13题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: &quot;III&quot;
Output: 3
Example 2:

Input: &quot;IV&quot;
Output: 4
Example 3:

Input: &quot;IX&quot;
Output: 9
Example 4:

Input: &quot;LVIII&quot;
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 5:

Input: &quot;MCMXCIV&quot;
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;古罗马数字到的阿拉伯数字转化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int romanToInt(String s) {

  if(s == null || s.length() == 0) return 0;
	int len = s.length();
	HashMap&amp;lt;Character,Integer&amp;gt; map = new HashMap&amp;lt;Character,Integer&amp;gt;();
	 map.put('I',1);
	 map.put('V',5);
	 map.put('X',10);
	 map.put('L',50);
	 map.put('C',100);
	 map.put('D',500);
	 map.put('M',1000);

	 int result = map.get(s.charAt(len -1));
	 int pivot = result;
	 for(int i = len -2; i&amp;gt;= 0;i--){
			 int curr = map.get(s.charAt(i));
			 if(curr &amp;gt;=  pivot){
			      result += curr;
			 }else{
			       result -= curr;
			 }
	 		 pivot = curr;
	 }
	return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/13/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/13/day2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode10</title>
        <description>&lt;p&gt;LeetCode 第10题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
Example 2:

Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.
Example 3:

Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
Example 4:

Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.
Example 5:

Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  首先确定是动态规划的匹配性的问题

  其次，确定问题的分解dp[i][j] 标识的是if s.substring(0,i) is valid for pattern p.substring(0,j) 这步是最困难的点。

  最后确定dp[i][j] 和 dp[i-1][j-1] 等之间的转移条件：
  if(p[j] == s[i]) dp[i][j] = dp[i-1][j-1];//①

  If(p[j]== '.')   dp[i][j] = dp[i-1][j-1];//②

  if(p[j]== '*') 情况比较的复杂了，分开进行讨论：//③
    if( p[j-1] != s[i]) dp[i][j] = dp[i][j-2],举例说明的话，ab* 只能是匹配的a，不能是ac

    if( p[j-1] == s[i] or p[j-1] == '.')
      dp[i][j] = dp[i-1][j] // a* 匹配 aaaa
      or dp[i][j] = dp[i][j-1] // a* 匹配 a
      or dp[i][j] = dp[i][j-2] // a* 匹配 empty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isMatch(String s, String p) {
        if(s == null || p == null) {
            return false;
        }
        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];
        state[0][0] = true;
        // no need to initialize state[i][0] as false  initialize state[0][j]
        //应用的条件是③
        for (int j = 1; j &amp;lt; state[0].length; j++) {
            if (p.charAt(j - 1) == '*') {
                if (state[0][j - 1] || (j &amp;gt; 1 &amp;amp;&amp;amp; state[0][j - 2])) {
                    state[0][j] = true;
                }
            }
        }
        // 索引的范围是从1到length，标识的是0 标识的是null，第一个字符的下标是1，所以当前值对应的字符中的下标为i-1，j-1
        for (int i = 1; i &amp;lt; state.length; i++) {
            for (int j = 1; j &amp;lt; state[0].length; j++) {
                // 上面说明的转移条件①和②
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    state[i][j] = state[i - 1][j - 1];
                }
                // 上面说明的转移条件③
                if (p.charAt(j - 1) == '*') {
                    //这个就是标识 ，不适用③的前两个条件的内容：cb 匹配 cba*
                    if (s.charAt(i - 1) != p.charAt(j - 2) &amp;amp;&amp;amp; p.charAt(j - 2) != '.') {
                        state[i][j] = state[i][j - 2];
                    } else {
                        //③中条件的完美的展示
                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];
                    }
                }
            }
        }
        return state[s.length()][p.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode11</title>
        <description>&lt;p&gt;LeetCode 第11题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;题目描述：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given n non-negative integers a1, a2, ..., an ,
where each represents a point at coordinate (i, ai).
n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).
Find two lines, which together with x-axis forms a container,
 such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].
In this case, the max area of water (blue section)
the container can contain is 49.     

Example:
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路清晰，这道题和原来的不同:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    y
    ^
    |
    |     a2
    |     |  a3          an
    |  a1 |  |     a5    |
    |  |  |  |  a4 |     |
    |  |  |  |  |  | ..  |
    ---------------------------&amp;gt;
   0   1  2  3  4  5 ..  n     x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只是为了寻找两个位置i,j 组成的桶，能够形成一个最大的容器，而不是这个题目：https://leetcode.com/problems/trapping-rain-water/&lt;/p&gt;

&lt;p&gt;这就是一个“双指针”移动的问题。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int max(int[] A) {  

    int S = 0, i = 0, j = A.length -1;
    while (i &amp;lt; j) {
        S = Math.max(S, (j - i) * Math.min(A[i], A[j]));
        if (A[i] &amp;lt; A[j]) i++; else j--;
    }
    return S;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2-3/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>LeetCode09</title>
        <description>&lt;p&gt;LeetCode 第09题的分析和总结&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;题目描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不转化为String类型，就直接的翻转过来比较两个值是否一样即可。
注意翻转过程中的integer 越界问题，是不需要考虑的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isPalindrome(int num) {
		if (num &amp;lt; 0 || (x!=0 &amp;amp;&amp;amp; x%10==0)) {
			return false;
		}
		int sum = num;
		int temp = 0;
		while (sum != 0) {
			temp = temp * 10 + sum % 10;
			sum = sum / 10;
		}
		return temp == num;
	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/12/day2-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/12/day2-2/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>JDK8的新特性2</title>
        <description>&lt;p&gt;JDK8的新特性：Stream&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; myList =
    Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);

myList
    .stream()
    .filter(s -&amp;gt; s.startsWith(&quot;c&quot;))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);
// C1
// C2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;stream和其它集合类的区别在于&quot;&gt;Stream和其它集合类的区别在于：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;其它集合类主要关注与有限数量的数据的&lt;strong&gt;访问和有效管理&lt;/strong&gt;(增删改)，而Stream并没有提供访问和管理元素的方式，而是通过声明数据源的方式，利用可计算的操作在数据源上执行，当然BaseStream.iterator() 和 BaseStream.spliterator()操作提供了遍历元素的方法。&lt;/p&gt;

  &lt;p&gt;集合关注的是有限元素的访问和管理，Stream关注的是数据源形成的操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;stream的定义&quot;&gt;Stream的定义：&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A sequence of elements supporting sequential and parallel aggregate operations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;stream的使用&quot;&gt;Stream的使用&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Lists是Guava中的一个工具类
List&amp;lt;Integer&amp;gt; nums = Lists.newArrayList(1,null,3,4,null,6);
nums.stream().filter(num -&amp;gt; num != null).count();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;针对上面的代码，进行Stream拆解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img04.taobaocdn.com/imgextra/i4/90219132/T2ycFgXQ8XXXXXXXXX_!!90219132.jpg&quot; alt=&quot;图片地址&quot; /&gt;&lt;/p&gt;

&lt;p&gt;红色框中的语句是一个Stream的生命开始的地方，负责创建一个Stream实例； &lt;br /&gt;
绿色框中的语句是赋予Stream灵魂的地方，把一个Stream转换成另外一个Stream，红框的语句生成的是一个包含所有nums变量的Stream，进过绿框的filter方法以后，重新生成了一个过滤掉原nums列表所有null以后的Stream； &lt;br /&gt;
蓝色框中的语句是丰收的地方，把Stream的里面包含的内容按照某种算法来汇聚成一个值，例子中是获取Stream中包含的元素个数。&lt;/p&gt;

&lt;h3 id=&quot;创建stream&quot;&gt;创建Stream&lt;/h3&gt;

&lt;p&gt;最常用的创建Stream有两种途径：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过Stream接口的静态工厂方法（注意：Java8里接口可以带静态方法）；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过Collection接口的默认方法（默认方法：Default method，也是Java8中的一个新特性，就是接口中的一个带有实现的方法, 前文中有说明）stream()，把一个Collection对象转换成Stream&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外使用Stream静态方法来创建Stream&lt;/p&gt;

&lt;p&gt;of方法：有两个overload方法，一个接受变长参数，一个接口单一值，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Stream&amp;lt;Integer&amp;gt; integerStream = Stream.of(1, 2, 3, 5);
Stream&amp;lt;String&amp;gt; stringStream = Stream.of(&quot;taobao&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;generator方法：生成一个无限长度的Stream，其元素的生成是通过给定的Supplier（这个接口可以看成一个对象的工厂，每次调用返回一个给定类型的对象）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Stream.generate(new Supplier&amp;lt;Double&amp;gt;() {
   	@Override
   	public Double get() {
		return Math.random();
	}
});
Stream.generate(() -&amp;gt; Math.random());
   Stream.generate(Math::random);
   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;iterate方法：也是生成无限长度的Stream，和generator不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Stream.iterate(1, item -&amp;gt; item + 1)
      .limit(10)
      .forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;转换stream&quot;&gt;转换Stream&lt;/h3&gt;

&lt;p&gt;从图中展示的我们知道，转换Stream主要是使用一些API。Stream接口中定义了几个常用的转换API，下面我们挑选几个常用的转换方法来解释。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;distinct: 对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法）&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; l = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;).distinct()
                       .collect(Collectors.toList());
System.out.println(l); //[a, b, c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;filter: 对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; l = IntStream.range(1,10)
        .filter( i -&amp;gt; i % 2 == 0)
        .boxed()
        .collect(Collectors.toList());
System.out.println(l); //[2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;map: 对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和mapToDouble。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; l = Stream.of('a','b','c')
        .map( c -&amp;gt; c.hashCode())
        .collect(Collectors.toList());
System.out.println(l); //[97, 98, 99]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;flatMap：和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ins = Arrays.asList(
				Arrays.asList(1, 2, 3, 4, 5), 
				Arrays.asList(1, 2, 3, 4, 5), 
				Arrays.asList(1, 2, 3, 4, 5));
		Stream&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; paras = ins.stream();
		IntStream value = paras.flatMapToInt(t-&amp;gt;{
		 return	t.stream().mapToInt(Integer::intValue);
		});
System.out.println(value.sum());

// 或者

String poetry = &quot;Where, before me, are the ages that have gone?\n&quot; +
        &quot;And where, behind me, are the coming generations?\n“;
Stream&amp;lt;String&amp;gt; lines = Arrays.stream(poetry.split(&quot;\n&quot;));

Stream&amp;lt;String&amp;gt; words = lines.flatMap(line -&amp;gt; Arrays.stream(line.split(&quot; &quot;)));
List&amp;lt;String&amp;gt; l = words.map( w -&amp;gt; {
    if (w.endsWith(&quot;,&quot;) || w.endsWith(&quot;.&quot;) || w.endsWith(&quot;?&quot;))
        return w.substring(0,w.length() -1).trim().toLowerCase();
    else
        return w.trim().toLowerCase();
}).distinct().sorted().collect(Collectors.toList());
System.out.println(l);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;limit方法指定数量的元素的流。对于串行流，这个方法是有效的，这是因为它只需返回前n个元素即可，但是对于有序的并行流，它可能花费相对较长的时间，如果你不在意有序，可以将有序并行流转换为无序的，可以提高性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; l = IntStream.range(1,100).limit(5)
        .boxed()
        .collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;peek方法方法会使用一个Consumer消费流中的元素，但是返回的流还是包含原来的流中的元素&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String[] arr = new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;};
Arrays.stream(arr)
        .peek(System.out::println) //a,b,c,d
        .count();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;sorted()将流中的元素按照自然排序方式进行排序，如果元素没有实现Comparable，则终点操作执行时会抛出java.lang.ClassCastException异常。&lt;/li&gt;
  &lt;li&gt;skip返回丢弃了前n个元素的流，如果流中的元素小于或者等于n，则返回空的流。&lt;/li&gt;
  &lt;li&gt;count方法返回流中的元素的数量&lt;/li&gt;
  &lt;li&gt;forEach遍历流的每一个元素，执行指定的action。它是一个终点操作，和peek方法不同。这个方法不担保按照流的encounter order顺序执行，如果对于有序流按照它的encounter order顺序执行，你可以使用forEachOrdered方法。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Stream.of(1,2,3,4,5).forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;findAny()返回任意一个元素，如果流为空，返回空的Optional，对于并行流来说，它只需要返回任意一个元素即可，所以性能可能要好于findFirst()，但是有可能多次执行的时候返回的结果不一样。
findFirst()返回第一个元素，如果流为空，返回空的Optional。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;toArray() 将流中的元素放入到一个数组中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;性能问题&quot;&gt;性能问题&lt;/h3&gt;

&lt;p&gt;在对于一个Stream进行多次转换操作，每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是一个for循环里把所有操作都做掉的N（转换的次数）倍吗？&lt;/p&gt;

&lt;p&gt;其实不是这样的，转换操作都是lazy的，多个转换操作只会在汇聚操作（见下节）的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。&lt;/p&gt;

&lt;h3 id=&quot;reduce-stream&quot;&gt;Reduce Stream&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. The streams classes have multiple forms of general reduction operations, called reduce() and collect(), as well as multiple specialized reduction forms such as sum(), max(), or count().&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单翻译一下：汇聚操作（也称为折叠）接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。Stream接口有一些通用的汇聚操作，比如reduce()和collect()；也有一些特定用途的汇聚操作，比如sum(),max()和count()。注意：sum方法不是所有的Stream对象都有的，只有IntStream、LongStream和DoubleStream是实例才有。&lt;/p&gt;

&lt;p&gt;下面会分两部分来介绍汇聚操作：&lt;/p&gt;

&lt;p&gt;可变汇聚：把输入的元素们累积到一个可变的容器中，比如Collection或者StringBuilder；&lt;/p&gt;

&lt;p&gt;其他汇聚：除去可变汇聚剩下的，一般都不是通过反复修改某个可变对象，而是通过把前一次的汇聚结果当成下一次的入参，反复如此。比如reduce，count，allMatch；&lt;/p&gt;

&lt;h4 id=&quot;可变汇聚&quot;&gt;可变汇聚&lt;/h4&gt;
&lt;p&gt;可变汇聚对应的只有一个方法：collect，正如其名字显示的，它可以把Stream中的要有元素收集到一个结果容器中（比如Collection）。先看一下最通用的collect方法的定义（还有其他override方法）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;R&amp;gt; R collect(
    Supplier&amp;lt;R&amp;gt; supplier,
    BiConsumer&amp;lt;R, ? super T&amp;gt; accumulator,
    BiConsumer&amp;lt;R, R&amp;gt; combiner
    );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先来看看这三个参数的含义：
Supplier supplier是一个工厂函数，用来生成一个新的容器；
BiConsumer accumulator也是一个函数，用来把Stream中的元素添加到结果容器中；
BiConsumer combiner还是一个函数，用来把中间状态的多个结果容器合并成为一个（并发的时候会用到）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9,10);

List&amp;lt;Integer&amp;gt; numsWithoutNull = nums.stream()
    .filter(num -&amp;gt; num != null)
    .collect(() -&amp;gt; new ArrayList&amp;lt;Integer&amp;gt;(),
            (list, item) -&amp;gt; list.add(item),
            (list1, list2) -&amp;gt; list1.addAll(list2));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码就是对一个元素是Integer类型的List，先过滤掉全部的null，然后把剩下的元素收集到一个新的List中。进一步看一下collect方法的三个参数，都是lambda形式的函数&lt;/p&gt;

&lt;p&gt;第一个函数生成一个新的ArrayList实例；
第二个函数接受两个参数，第一个是前面生成的ArrayList对象，二个是stream中包含的元素，函数体就是把stream中的元素加入ArrayList对象中。第二个函数被反复调用直到原stream的元素被消费完毕；
第三个函数也是接受两个参数，这两个都是ArrayList类型的，函数体就是把第二个ArrayList全部加入到第一个中；&lt;/p&gt;

&lt;p&gt;但是上面的collect方法调用也有点太复杂了，没关系！我们来看一下collect方法另外一个override的版本，其依赖&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html&quot;&gt;Collector&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super T, A, R&amp;gt; collector);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样清爽多了！Java8还给我们提供了Collector的工具类–&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html&quot;&gt;Collectors&lt;/a&gt;，其中已经定义了一些静态工厂方法，比如：&lt;/p&gt;

&lt;p&gt;Collectors.toCollection() 收集到Collection中, 
Collectors.toList()收集到List中
Collectors.toSet()收集到Set中。
这样的静态方法还有很多，这里就不一一介绍了，大家可以直接去看JavaDoc。下面看看使用Collectors对于代码的简化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; numsWithoutNull = nums.stream().filter(num -&amp;gt; num != null)
                    .collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;其他汇聚&quot;&gt;其他汇聚&lt;/h4&gt;

&lt;p&gt;reduce方法：reduce方法非常的通用，后面介绍的count，sum等都可以使用其实现。reduce方法有三个override的方法，本文介绍两个最常用的.先来看reduce方法的第一种形式，其方法定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接受一个BinaryOperator类型的参数，在使用的时候我们可以用lambda表达式来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; ints = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10);
System.out.println(&quot;ints sum is:&quot; + ints.stream().reduce((sum, item) -&amp;gt; sum + item).get());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到reduce方法接受一个函数，这个函数有两个参数，第一个参数是上次函数执行的返回值（也称为中间结果），第二个参数是stream中的元素，这个函数把这两个值相加，得到的和会被赋值给下次执行这个函数的第一个参数。要注意的是：&lt;strong&gt;第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素&lt;/strong&gt;。这个方法返回值类型是Optional，这是Java8防止出现NPE的一种可行方法，这里就简单的认为是一个容器，其中可能会包含0个或者1个对象。&lt;/p&gt;

&lt;p&gt;reduce方法还有一个很常用的变种：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个定义上上面已经介绍过的基本一致，不同的是：它允许用户提供一个循环计算的初始值，如果Stream为空，就直接返回该值。而且这个方法不会返回Optional，因为其不会出现null值。下面直接给出例子，就不再做说明了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; ints = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10);
System.out.println(&quot;ints sum is:&quot; + ints.stream().reduce(0, (sum, item) -&amp;gt; sum + item));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 11 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/11/day2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/11/day2/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>JDK8的新特性1</title>
        <description>&lt;p&gt;JDK8的新特性：
  1.Default Methods for Interfaces&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Lambda exxpressions&lt;/li&gt;
  &lt;li&gt;一些常见的Lamdba的使用方式
&lt;!--more--&gt;
JDK8的第一个新特性，接口中可以通过default关键字来定义方法的默认行为。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Formula {
    double calculate(int a);
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);// 4.0     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JDK8的第二个特性就是Lambda表达式。为了替换匿名的类，Java8支持了一个更加短的语法糖：lambda表达式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&amp;lt;String&amp;gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});

//lambda 表达式
Collections.sort(names,(String a,String b)-&amp;gt;{
  return b.compareTo(a);
});

// lambda short
Collections.sort(names,(String a,String b)-&amp;gt; b.compareTo(a));

//lambda shorter
Collections.sort(names,(a,b)-&amp;gt; b.compareTo(a));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如图所示，那么什么是functional interface？
functional interface 函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。这种类型的接口也称为SAM接口，即Single Abstract Method interfaces。&lt;/p&gt;

&lt;p&gt;1.函数式接口里允许定义默认方法：
2.函数式接口里允许定义静态方法：
3.函数式接口里允许定义java.lang.Object里的public方法，代码类似：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FunctionalInterface
	interface Converter&amp;lt;F, T&amp;gt; {
	    T convert(F from);
	    boolean equals(Object obj);

	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;4.函数式接口里允许子接口继承多个父接口，但每个父接口中都只能存在一个抽象方法，且必须的相同的抽象方法。代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface PConverter1&amp;lt;F, T&amp;gt; {
   T convert(F from);
}

interface PConverter2&amp;lt;F, T&amp;gt; {
   T convert(F from);
}

@FunctionalInterface
interface Converter&amp;lt;F, T&amp;gt; extends PConverter1, PConverter2{
    boolean equals(Object obj);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，Java 8 enables you to pass references of methods or constructors via the :: keyword. The above example shows how to reference a static method. But we can also reference object methods:
Java8 支持:: 操作，代表着一种对方法的调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//举例1：静态方法的使用
Converter&amp;lt;String, Integer&amp;gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123

//举例2：普通方法的使用
class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}
Something something = new Something();
Converter&amp;lt;String, String&amp;gt; converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;

//举例3：new 方法的使用

class Person {
    String firstName;
    Person() {}

    Person(String firstName) {
        this.firstName = firstName;
    }
}

interface PersonFactory&amp;lt;P extends Person&amp;gt; {
    P create(String firstName);
}

//总感觉这样写的话，会被打死！首先省掉了一个匿名的实现PersonFactory的匿名类，然后省掉了匿名类调用create的方法，最终直接写的是create方法的实现，Person的构建方法。

PersonFactory&amp;lt;Person&amp;gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接触了Lamdba的使用方式，经常会在 Google Guava 的jar中使用的一些常见的lamdba用法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; s.length() &amp;gt; 0;
predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false
Predicate&amp;lt;Boolean&amp;gt; nonNull = Objects::nonNull;
Predicate&amp;lt;Boolean&amp;gt; isNull = Objects::isNull;
Predicate&amp;lt;String&amp;gt; isEmpty = String::isEmpty;
Predicate&amp;lt;String&amp;gt; isNotEmpty = isEmpty.negate();

Function&amp;lt;String, Integer&amp;gt; toInteger = Integer::valueOf;
Function&amp;lt;String, String&amp;gt; backToString = toInteger.andThen(String::valueOf);
backToString.apply(&quot;123&quot;);     // &quot;123&quot;


Supplier&amp;lt;Person&amp;gt; personSupplier = Person::new;
personSupplier.get();   // new Person

Consumer&amp;lt;Person&amp;gt; greeter = (p) -&amp;gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));

Comparator&amp;lt;Person&amp;gt; comparator = (p1, p2) -&amp;gt; p1.firstName.compareTo(p2.firstName);
Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);
comparator.compare(p1, p2);             // &amp;gt; 0
comparator.reversed().compare(p1, p2);  // &amp;lt; 0


Optional&amp;lt;String&amp;gt; optional = Optional.of(&quot;bam&quot;);
optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;
optional.ifPresent((s) -&amp;gt; System.out.println(s.charAt(0)));     // &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/10/jdk-day0/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/10/jdk-day0/</guid>
        
        <category>JDK</category>
        
        
      </item>
    
  </channel>
</rss>
