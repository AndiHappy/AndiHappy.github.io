<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>飞翔的面包</title>
    <description>后台服务、微服务、架构、黑客与画家 | 飞翔的面包 JAVA Developer Andi Happy andiHappy | 这里是 飞翔的面包 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 27 Aug 2017 18:49:24 +0800</pubDate>
    <lastBuildDate>Sun, 27 Aug 2017 18:49:24 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>JDK并发框架的描述（一）</title>
        <description>&lt;p&gt;梳理JDK中并发编程的实现的原理，感觉很多东西还是非常的有意思的，例如锁的实现。我们首先说：重入锁，读写锁，还有一些扩展的锁的实现的基础：同步器（java.util.concurrent.locks.AbstractQueuedSynchronizer）
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;java.util.concurrent.locks.AbstractQueuedSynchronizer 为什么称之为实现锁的基础呢？  &lt;br /&gt;
这个我们需要从头说起。&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Aug 2017 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/concurrent/2017/08/26/concurrent/</link>
        <guid isPermaLink="true">http://localhost:4000/concurrent/2017/08/26/concurrent/</guid>
        
        <category>学习</category>
        
        
        <category>concurrent</category>
        
      </item>
    
      <item>
        <title>复习算法和数据结构（1）</title>
        <description>
</description>
        <pubDate>Fri, 18 Aug 2017 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2017/08/18/alg/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2017/08/18/alg/</guid>
        
        <category>温故而知新</category>
        
        
        <category>算法和数据结构</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(8)</title>
        <description>&lt;p&gt;BPMN中不仅规定了每一个图标代表的意义，例如：    &lt;br /&gt;
&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/4510bc77470bddd1b5c2f7e23d706d29.png&quot; alt=&quot;exclusivegateway的示意图&quot; /&gt;  &lt;br /&gt;
而且还规定了每一个每一图形的行为标准，在Activiti中动作行为封装在了ActivityBehavior中，在ActivityBehavior中，不仅封装的有行为，线上的条件的判断。  &lt;br /&gt;
&lt;!--more--&gt;
首先是ActivityBehavior的构建，采用的是简单工厂的设计模式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ActivityBehaviorFactory {

  public abstract NoneStartEventActivityBehavior createNoneStartEventActivityBehavior(StartEvent startEvent);

  public abstract EventSubProcessStartEventActivityBehavior createEventSubProcessStartEventActivityBehavior(StartEvent startEvent, String activityId);

  public abstract TaskActivityBehavior createTaskActivityBehavior(Task task);

  public abstract ManualTaskActivityBehavior createManualTaskActivityBehavior(ManualTask manualTask);

  public abstract ReceiveTaskActivityBehavior createReceiveTaskActivityBehavior(ReceiveTask receiveTask);

  public abstract UserTaskActivityBehavior createUserTaskActivityBehavior(UserTask userTask, TaskDefinition taskDefinition);

  public abstract ClassDelegate createClassDelegateServiceTask(ServiceTask serviceTask);

  public abstract ServiceTaskDelegateExpressionActivityBehavior createServiceTaskDelegateExpressionActivityBehavior(ServiceTask serviceTask);

  public abstract ServiceTaskExpressionActivityBehavior createServiceTaskExpressionActivityBehavior(ServiceTask serviceTask);

  public abstract WebServiceActivityBehavior createWebServiceActivityBehavior(ServiceTask serviceTask);

  public abstract WebServiceActivityBehavior createWebServiceActivityBehavior(SendTask sendTask);

  public abstract MailActivityBehavior createMailActivityBehavior(ServiceTask serviceTask);

  public abstract MailActivityBehavior createMailActivityBehavior(SendTask sendTask);

  // We do not want a hard dependency on the Mule module, hence we return ActivityBehavior and instantiate
  // the delegate instance using a string instead of the Class itself.
  public abstract ActivityBehavior createMuleActivityBehavior(ServiceTask serviceTask, BpmnModel bpmnModel);

  public abstract ActivityBehavior createMuleActivityBehavior(SendTask sendTask, BpmnModel bpmnModel);

  public abstract ActivityBehavior createCamelActivityBehavior(ServiceTask serviceTask, BpmnModel bpmnModel);

  public abstract ActivityBehavior createCamelActivityBehavior(SendTask sendTask, BpmnModel bpmnModel);

  public abstract ShellActivityBehavior createShellActivityBehavior(ServiceTask serviceTask);

  public abstract ActivityBehavior createBusinessRuleTaskActivityBehavior(BusinessRuleTask businessRuleTask);

  public abstract ScriptTaskActivityBehavior createScriptTaskActivityBehavior(ScriptTask scriptTask);

  public abstract ExclusiveGatewayActivityBehavior createExclusiveGatewayActivityBehavior(ExclusiveGateway exclusiveGateway);

  public abstract ParallelGatewayActivityBehavior createParallelGatewayActivityBehavior(ParallelGateway parallelGateway);

  public abstract InclusiveGatewayActivityBehavior createInclusiveGatewayActivityBehavior(InclusiveGateway inclusiveGateway);

  public abstract EventBasedGatewayActivityBehavior createEventBasedGatewayActivityBehavior(EventGateway eventGateway);

  public abstract SequentialMultiInstanceBehavior createSequentialMultiInstanceBehavior(ActivityImpl activity, AbstractBpmnActivityBehavior innerActivityBehavior);

  public abstract ParallelMultiInstanceBehavior createParallelMultiInstanceBehavior(ActivityImpl activity, AbstractBpmnActivityBehavior innerActivityBehavior);

  public abstract SubProcessActivityBehavior createSubprocActivityBehavior(SubProcess subProcess);

  public abstract CallActivityBehavior createCallActivityBehavior(CallActivity callActivity);

  public abstract TransactionActivityBehavior createTransactionActivityBehavior(Transaction transaction);

  public abstract IntermediateCatchEventActivityBehavior createIntermediateCatchEventActivityBehavior(IntermediateCatchEvent intermediateCatchEvent);

  public abstract IntermediateThrowNoneEventActivityBehavior createIntermediateThrowNoneEventActivityBehavior(ThrowEvent throwEvent);

  public abstract IntermediateThrowSignalEventActivityBehavior createIntermediateThrowSignalEventActivityBehavior(ThrowEvent throwEvent, Signal signal, EventSubscriptionDeclaration eventSubscriptionDeclaration);

  public abstract IntermediateThrowCompensationEventActivityBehavior createIntermediateThrowCompensationEventActivityBehavior(ThrowEvent throwEvent, CompensateEventDefinition compensateEventDefinition);

 ...........

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认的实现是：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultActivityBehaviorFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AbstractBehaviorFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ActivityBehaviorFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Start event&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXCEPTION_MAP_FIELD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mapExceptions&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NoneStartEventActivityBehavior&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createNoneStartEventActivityBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StartEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NoneStartEventActivityBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventSubProcessStartEventActivityBehavior&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createEventSubProcessStartEventActivityBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StartEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activityId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EventSubProcessStartEventActivityBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activityId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Task&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TaskActivityBehavior&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createTaskActivityBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TaskActivityBehavior&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...........&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 13 Aug 2017 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/13/activiti8/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/13/activiti8/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(7)</title>
        <description>&lt;p&gt;一个具体的流程启动以后，具体流程示意图：   &lt;br /&gt;
&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/4e87e67e31be5d65024bf07221129d16.png&quot; alt=&quot;简单会签流程示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;追踪流程的运转的情况，找到好玩的代码。  &lt;br /&gt;
&lt;!--more--&gt;
根据状态机的跳转的动作：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS_START = new AtomicOperationProcessStart
||
PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
||
ACTIVITY_EXECUTE = new AtomicOperationActivityExecute();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们看到第一个的开始节点的执行：      &lt;br /&gt;
&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/ed93f1f1941a9f0feba1f9c1b123b15b.png&quot; alt=&quot;开始节点的执行&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NoneStartEventActivityBehavior extends FlowNodeActivityBehavior {

  // Nothing to see here.
  // The default behaviour of the BpmnActivity is exactly what
  // a none start event should be doing.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;实现的在FlowNodeActivityBehavior中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected BpmnActivityBehavior bpmnActivityBehavior = new BpmnActivityBehavior();

 /**
  * Default behaviour: just leave the activity with no extra functionality.
  */
 public void execute(ActivityExecution execution) throws Exception {
   leave(execution);
 }

 /**
  * Default way of leaving a BPMN 2.0 activity: evaluate the conditions on the
  * outgoing sequence flow and take those that evaluate to true.
  */
 protected void leave(ActivityExecution execution) {
   bpmnActivityBehavior.performDefaultOutgoingBehavior(execution);
 }

 protected void leaveIgnoreConditions(ActivityExecution activityContext) {
   bpmnActivityBehavior.performIgnoreConditionsOutgoingBehavior(activityContext);
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认的bpmnActivityBehavior沿着默认的线达到下一个节点，是吗？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void performOutgoingBehavior(ActivityExecution execution,
         boolean checkConditions, boolean throwExceptionIfExecutionStuck, List&amp;lt;ActivityExecution&amp;gt; reusableExecutions) {

   if (log.isDebugEnabled()) {
     log.debug(&quot;Leaving activity '{}'&quot;, execution.getActivity().getId());
   }

   String defaultSequenceFlow = (String) execution.getActivity().getProperty(&quot;default&quot;);//说明①
   List&amp;lt;PvmTransition&amp;gt; transitionsToTake = new ArrayList&amp;lt;PvmTransition&amp;gt;();

   List&amp;lt;PvmTransition&amp;gt; outgoingTransitions = execution.getActivity().getOutgoingTransitions();
   for (PvmTransition outgoingTransition : outgoingTransitions) {
     Expression skipExpression = outgoingTransition.getSkipExpression();
    //如果不是蹦跳的skipExpression
     if (!SkipExpressionUtil.isSkipExpressionEnabled(execution, skipExpression)) {
       // 没有默认线或者出去的线不是默认线
       if (defaultSequenceFlow == null || !outgoingTransition.getId().equals(defaultSequenceFlow)) {
         Condition condition = (Condition) outgoingTransition.getProperty(BpmnParse.PROPERTYNAME_CONDITION);
         //线上没有条件或者，限定了不检查线上条件，或者线上条件符合要求
         if (condition == null || !checkConditions || condition.evaluate(outgoingTransition.getId(), execution)) {
           transitionsToTake.add(outgoingTransition);
         }
       }

     } else if (SkipExpressionUtil.shouldSkipFlowElement(execution, skipExpression)){
       transitionsToTake.add(outgoingTransition);
     }
   }
   //说明②
   if (transitionsToTake.size() == 1) {
     //只有一条线的时候，直接的走take逻辑
     execution.take(transitionsToTake.get(0));
   } else if (transitionsToTake.size() &amp;gt;= 1) {
     //有多条线的时候
     execution.inactivate();
     if (reusableExecutions == null || reusableExecutions.isEmpty()) {
       execution.takeAll(transitionsToTake, Arrays.asList(execution));
     } else {
       execution.takeAll(transitionsToTake, reusableExecutions);
     }

   } else {
    //没有满足条件出去的线，如果有默认的线
     if (defaultSequenceFlow != null) {
       PvmTransition defaultTransition = execution.getActivity().findOutgoingTransition(defaultSequenceFlow);
       if (defaultTransition != null) {
         execution.take(defaultTransition);
       } else {
         throw new ActivitiException(&quot;Default sequence flow '&quot; + defaultSequenceFlow + &quot;' could not be not found&quot;);
       }
     } else {
       //如果有补偿事件
       Object isForCompensation = execution.getActivity().getProperty(BpmnParse.PROPERTYNAME_IS_FOR_COMPENSATION);
       if(isForCompensation != null &amp;amp;&amp;amp; (Boolean) isForCompensation) {
         if (execution instanceof ExecutionEntity) {
           Context.getCommandContext().getHistoryManager().recordActivityEnd((ExecutionEntity) execution);
         }
         InterpretableExecution parentExecution = (InterpretableExecution) execution.getParent();
         ((InterpretableExecution)execution).remove();
         parentExecution.signal(&quot;compensationDone&quot;, null);

       } else {
         //暂停了，抛出错误
         if (log.isDebugEnabled()) {
           log.debug(&quot;No outgoing sequence flow found for {}. Ending execution.&quot;, execution.getActivity().getId());
         }
         execution.end();

         if (throwExceptionIfExecutionStuck) {
           throw new ActivitiException(&quot;No outgoing sequence flow of the inclusive gateway '&quot; + execution.getActivity().getId()
                 + &quot;' could be selected for continuing the process&quot;);
         }
       }

     }
   }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;流程定义节点之间的转移，是先找到满足条件的离开的线：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void take(PvmTransition transition) {
  	take(transition, true);
  }

  public void take(PvmTransition transition, boolean fireActivityCompletionEvent) {

  	if (fireActivityCompletionEvent) {
	  	fireActivityCompletedEvent();
  	}

    if (this.transition!=null) {
      throw new PvmException(&quot;already taking a transition&quot;);
    }
    if (transition==null) {
      throw new PvmException(&quot;transition is null&quot;);
    }
    setActivity((ActivityImpl)transition.getSource());
    setTransition((TransitionImpl) transition);
    performOperation(AtomicOperation.TRANSITION_NOTIFY_LISTENER_END);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;说的转移，只是同一个ExecutionEntity里面的 Activity修改了，Transition修改了，然后开始执行：TRANSITION_NOTIFY_LISTENER_END.  但是和我们想象的不一样，这里设置的Activiti是Transition的Source，也就是“刚刚执行结束”的活动定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/ea742aca518a53df8dbeb1f64c8c42c6.png&quot; alt=&quot;Execution设置activity&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS_START = new AtomicOperationProcessStart
||
PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
||
ACTIVITY_EXECUTE = new AtomicOperationActivityExecute();
||
TRANSITION_NOTIFY_LISTENER_END = new AtomicOperationTransitionNotifyListenerEnd();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行的过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public void execute(InterpretableExecution execution) {
    ScopeImpl scope = getScope(execution);
    List&amp;lt;ExecutionListener&amp;gt; exectionListeners = scope.getExecutionListeners(getEventName());
    int executionListenerIndex = execution.getExecutionListenerIndex();
    
    if (exectionListeners.size()&amp;gt;executionListenerIndex) {
      execution.setEventName(getEventName());
      execution.setEventSource(scope);
      ExecutionListener listener = exectionListeners.get(executionListenerIndex);
      try {
        listener.notify(execution);
      } catch (RuntimeException e) {
        throw e;
      } catch (Exception e) {
        throw new PvmException(&quot;couldn't execute event listener : &quot;+e.getMessage(), e);
      }
      execution.setExecutionListenerIndex(executionListenerIndex+1);
      execution.performOperation(this);//说明①

    } else {
      execution.setExecutionListenerIndex(0);
      execution.setEventName(null);
      execution.setEventSource(null);
      eventNotificationsCompleted(execution);
    }
  }
  
  @Override
  protected void eventNotificationsCompleted(InterpretableExecution execution) {
    execution.performOperation(TRANSITION_DESTROY_SCOPE);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明①: 这个是一个循环调用的，为了循环的发送监听事件
现在运行到了：TRANSITION_DESTROY_SCOPE&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;||
TRANSITION_DESTROY_SCOPE = new AtomicOperationTransitionDestroyScope();
public class AtomicOperationTransitionDestroyScope implements AtomicOperation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：TRANSITION_DESTROY_SCOPE直接实现了接口，没有像TRANSITION_NOTIFY_LISTENER_END一样，在抽象类的基础方面实现。这可能也是为什么有了接口，还有抽象类的原因？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void execute(InterpretableExecution execution) {
    InterpretableExecution propagatingExecution = null;

    ActivityImpl activity = (ActivityImpl) execution.getActivity();
    // if this transition is crossing a scope boundary
    if (activity.isScope()) {//当前的任务是否是一个包含的活动节点
      
      InterpretableExecution parentScopeInstance = null;
      // if this is a concurrent execution crossing a scope boundary
      if (execution.isConcurrent() &amp;amp;&amp;amp; !execution.isScope()) {
        // first remove the execution from the current root
        InterpretableExecution concurrentRoot = (InterpretableExecution) execution.getParent();
        parentScopeInstance = (InterpretableExecution) execution.getParent().getParent();

        log.debug(&quot;moving concurrent {} one scope up under {}&quot;, execution, parentScopeInstance);
        List&amp;lt;InterpretableExecution&amp;gt; parentScopeInstanceExecutions = (List&amp;lt;InterpretableExecution&amp;gt;) parentScopeInstance.getExecutions();
        List&amp;lt;InterpretableExecution&amp;gt; concurrentRootExecutions = (List&amp;lt;InterpretableExecution&amp;gt;) concurrentRoot.getExecutions();
        // if the parent scope had only one single scope child
        if (parentScopeInstanceExecutions.size()==1) {
          // it now becomes a concurrent execution
          parentScopeInstanceExecutions.get(0).setConcurrent(true);
        }
        
        concurrentRootExecutions.remove(execution);
        parentScopeInstanceExecutions.add(execution);
        execution.setParent(parentScopeInstance);
        execution.setActivity(activity);
        propagatingExecution = execution;
        
        // if there is only a single concurrent execution left
        // in the concurrent root, auto-prune it.  meaning, the 
        // last concurrent child execution data should be cloned into
        // the concurrent root.   
        if (concurrentRootExecutions.size()==1) {
          InterpretableExecution lastConcurrent = concurrentRootExecutions.get(0);
          if (lastConcurrent.isScope()) {
            lastConcurrent.setConcurrent(false);
            
          } else {
            log.debug(&quot;merging last concurrent {} into concurrent root {}&quot;, lastConcurrent, concurrentRoot);
            
            // We can't just merge the data of the lastConcurrent into the concurrentRoot.
            // This is because the concurrent root might be in a takeAll-loop.  So the 
            // concurrent execution is the one that will be receiving the take
            concurrentRoot.setActivity((ActivityImpl) lastConcurrent.getActivity());
            concurrentRoot.setActive(lastConcurrent.isActive());
            lastConcurrent.setReplacedBy(concurrentRoot);
            lastConcurrent.remove();
          }
        }

      } else if (execution.isConcurrent() &amp;amp;&amp;amp; execution.isScope()) {
        log.debug(&quot;scoped concurrent {} becomes concurrent and remains under {}&quot;, execution, execution.getParent());

        // TODO!
        execution.destroy();
        propagatingExecution = execution;
        
      } else {
        propagatingExecution = (InterpretableExecution) execution.getParent();
        propagatingExecution.setActivity((ActivityImpl) execution.getActivity());
        propagatingExecution.setTransition(execution.getTransition());
        propagatingExecution.setActive(true);
        log.debug(&quot;destroy scope: scoped {} continues as parent scope {}&quot;, execution, propagatingExecution);
        execution.destroy();
        execution.remove();
      }
      
    } else {
      propagatingExecution = execution;
    }
    
    // if there is another scope element that is ended
    // 父级别的元素，普通元素的父元素是流程定义ProcessDefinition
    ScopeImpl nextOuterScopeElement = activity.getParent();
    TransitionImpl transition = propagatingExecution.getTransition();
    // 目标节点
    ActivityImpl destination = transition.getDestination();
    //判断目标节点是否在父节点中，如果不在（考虑到子流程结束后的下一个元素是子流程以外的元素了）
    if (transitionLeavesNextOuterScope(nextOuterScopeElement, destination)) {
      propagatingExecution.setActivity((ActivityImpl) nextOuterScopeElement);
      //再次进入：TRANSITION_NOTIFY_LISTENER_END
      propagatingExecution.performOperation(TRANSITION_NOTIFY_LISTENER_END);
    } else {
    //进入：TRANSITION_NOTIFY_LISTENER_TAKE
      propagatingExecution.performOperation(TRANSITION_NOTIFY_LISTENER_TAKE);
    }
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从最后的逻辑，我们可以看到一个循环：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS_START = new AtomicOperationProcessStart
||
PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
||
ACTIVITY_EXECUTE = new AtomicOperationActivityExecute();
||
TRANSITION_NOTIFY_LISTENER_END = new AtomicOperationTransitionNotifyListenerEnd();
||
TRANSITION_DESTROY_SCOPE = new AtomicOperationTransitionDestroyScope();
||
TRANSITION_NOTIFY_LISTENER_TAKE，TRANSITION_NOTIFY_LISTENER_END（第二种情况就是再次的循环一次）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TRANSITION_NOTIFY_LISTENER_TAKE 这个就是对应线的逻辑了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TRANSITION_NOTIFY_LISTENER_TAKE = new AtomicOperationTransitionNotifyListenerTake();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
  public void execute(InterpretableExecution execution) {
    TransitionImpl transition = execution.getTransition();
    
    List&amp;lt;ExecutionListener&amp;gt; executionListeners = transition.getExecutionListeners();
    int executionListenerIndex = execution.getExecutionListenerIndex();
    
    if (executionListeners.size()&amp;gt;executionListenerIndex) {
      execution.setEventName(org.activiti.engine.impl.pvm.PvmEvent.EVENTNAME_TAKE);
      execution.setEventSource(transition);
      ExecutionListener listener = executionListeners.get(executionListenerIndex);
      try {
        listener.notify(execution);
      } catch (RuntimeException e) {
        throw e;
      } catch (Exception e) {
        throw new PvmException(&quot;couldn't execute event listener : &quot;+e.getMessage(), e);
      }
      execution.setExecutionListenerIndex(executionListenerIndex+1);
      execution.performOperation(this);
      //上面的这部分逻辑和抽象类里面的逻辑基本的一样
    } else {
    	if (log.isDebugEnabled()) {
    		log.debug(&quot;{} takes transition {}&quot;, execution, transition);
    	}
      execution.setExecutionListenerIndex(0);
      execution.setEventName(null);
      execution.setEventSource(null);

      ActivityImpl activity = (ActivityImpl) execution.getActivity();
      ActivityImpl nextScope = findNextScope(activity.getParent(), transition.getDestination());
      execution.setActivity(nextScope);//到这里ExecutionEntity的activity才再次的修改，但是Transition并没有修改
      
      // Firing event that transition is being taken     	。。。。。。。。      
      execution.performOperation(TRANSITION_CREATE_SCOPE);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后就到了：TRANSITION_CREATE_SCOPE&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TRANSITION_CREATE_SCOPE = new AtomicOperationTransitionCreateScope();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void execute(InterpretableExecution execution) {
    InterpretableExecution propagatingExecution = null;
    ActivityImpl activity = (ActivityImpl) execution.getActivity();
    if (activity.isScope()) {//activity扩展自Scope
      // 重新创建了一个Execution，称之为： propagatingExecution
      // 该propagatingExecution的Transition仍然是：(startevent1)--flow1--&amp;gt;(usertask1)
      //并不是Null
      propagatingExecution = (InterpretableExecution) execution.createExecution();
      propagatingExecution.setActivity(activity);
      propagatingExecution.setTransition(execution.getTransition());
      
      execution.setTransition(null);
      execution.setActivity(null);
      execution.setActive(false);
      // Execution的activity，Transition全部都是null
      log.debug(&quot;create scope: parent {} continues as execution {}&quot;, execution, propagatingExecution);
      propagatingExecution.initialize();

    } else {
      propagatingExecution = execution;
    }
   propagatingExecution.performOperation(AtomicOperation.TRANSITION_NOTIFY_LISTENER_START);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到了：AtomicOperation.TRANSITION_NOTIFY_LISTENER_START       &lt;br /&gt;
public class AtomicOperationTransitionNotifyListenerStart extends AbstractEventAtomicOperation   &lt;br /&gt;
扩展自抽象类：AbstractEventAtomicOperation    具体的执行的过程是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Override
  protected void eventNotificationsCompleted(InterpretableExecution execution) {
    TransitionImpl transition = execution.getTransition();
    ActivityImpl destination = null;
    if(transition == null) { // this is null after async cont. -&amp;gt; transition is not stored in execution
      destination = (ActivityImpl) execution.getActivity();
    } else {
      destination = transition.getDestination();
    }    
    ActivityImpl activity = (ActivityImpl) execution.getActivity();
    if (activity!=destination) {
      ActivityImpl nextScope = AtomicOperationTransitionNotifyListenerTake.findNextScope(activity, destination);
      execution.setActivity(nextScope);
      //进入了scope，创建scope
      execution.performOperation(TRANSITION_CREATE_SCOPE);
    } else {
      //在这个地方设置了Transition为null
      execution.setTransition(null);
      //终于设置了目标activity
      execution.setActivity(destination);
      execution.performOperation(ACTIVITY_EXECUTE);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;所以总体的循环就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS_START = new AtomicOperationProcessStart
||
PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
||
ACTIVITY_EXECUTE（执行） = new AtomicOperationActivityExecute();
||
TRANSITION_NOTIFY_LISTENER_END = new AtomicOperationTransitionNotifyListenerEnd();
||
TRANSITION_DESTROY_SCOPE = new AtomicOperationTransitionDestroyScope();
||
TRANSITION_NOTIFY_LISTENER_TAKE，TRANSITION_NOTIFY_LISTENER_END（第二种情况就是再次的循环一次）
||
TRANSITION_CREATE_SCOPE（创建） = new AtomicOperationTransitionCreateScope();
||
TRANSITION_NOTIFY_LISTENER_START = new AtomicOperationTransitionNotifyListenerStart();
||
TRANSITION_CREATE_SCOPE（再次创建），ACTIVITY_EXECUTE（再次进入）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个就是节点转移的全过程：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;转移的过程主要的逻辑点：
1.拿到目标节点（dedestination），Scope就是包含活动节点之类的元素（子流程）开始和结束的时候的处理。&lt;/strong&gt;       &lt;br /&gt;
&lt;strong&gt;2.转移过程中监听事件的发送。&lt;/strong&gt;          &lt;br /&gt;
&lt;strong&gt;3.节点的执行，根据各个节点的Behavior运行。&lt;/strong&gt;
选择那条线，以及流程定义中不同节点的判断全部的放在了Behavior中了&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 13 Aug 2017 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/13/activiti7/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/13/activiti7/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(6)</title>
        <description>&lt;p&gt;流程实力启动以后，任务的完成是一个比较重要的点，到底怎样才算完成了该节点对应的任务了，可以向下一节点推进了呢？&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;state Pattern：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The state pattern is a behavioral software design pattern that implements a state machine in an object-oriented way. With the state pattern, a state machine is implemented by implementing each individual state as a derived class of the state pattern interface, and implementing state transitions by invoking methods defined by the pattern’s superclass.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The state pattern can be interpreted as a strategy pattern which is able to switch the current strategy through invocations of methods defined in the pattern’s interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;状态模型和策略模型可以相互的转化&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This pattern is used in computer programming to encapsulate varying behavior for the same object based on its internal state. This can be a cleaner way for an object to change its behavior at runtime without resorting to large monolithic conditional statements[1]:395 and thus improve maintainability.[2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;启动的开始：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;processInstance.start();
//这里的ProcessInstance的类型是ExecutionEntity，不管是流程定义对应的流程实例，还是活动定义对应的活动实例，都是ExecutionEntity，仔细查看会发现，流程实例的ExecutionEntity和活动实例非常的相似

//流程实例启动
public void start() {
    if(startingExecution == null &amp;amp;&amp;amp; isProcessInstanceType()) {
      startingExecution = new StartingExecution(processDefinition.getInitial());
    }
    performOperation(AtomicOperation.PROCESS_START);
  }

  //活动实例启动
  performOperation(AtomicOperation.ACTIVITY_START);

  //最终都是
  public void performOperation(AtomicOperation executionOperation) {
    if (executionOperation.isAsync(this)) {
      scheduleAtomicOperationAsync(executionOperation);
    } else {
      performOperationSync(executionOperation);
    }    
  }

  protected void performOperationSync(AtomicOperation executionOperation) {
    Context
      .getCommandContext()
      .performOperation(executionOperation, this);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;AtomicOperation相当于定义了流程流转的动作，所有的流程的动作都在这个接口中定义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface AtomicOperation {
  AtomicOperation PROCESS_START = new AtomicOperationProcessStart();
  AtomicOperation PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
  AtomicOperation PROCESS_END = new AtomicOperationProcessEnd();
  AtomicOperation ACTIVITY_START = new AtomicOperationActivityStart();
  AtomicOperation ACTIVITY_EXECUTE = new AtomicOperationActivityExecute();
  AtomicOperation ACTIVITY_END = new AtomicOperationActivityEnd();
  AtomicOperation TRANSITION_NOTIFY_LISTENER_END = new AtomicOperationTransitionNotifyListenerEnd();
  AtomicOperation TRANSITION_DESTROY_SCOPE = new AtomicOperationTransitionDestroyScope();
  AtomicOperation TRANSITION_NOTIFY_LISTENER_TAKE = new AtomicOperationTransitionNotifyListenerTake();
  AtomicOperation TRANSITION_CREATE_SCOPE = new AtomicOperationTransitionCreateScope();
  AtomicOperation TRANSITION_NOTIFY_LISTENER_START = new AtomicOperationTransitionNotifyListenerStart();
  AtomicOperation DELETE_CASCADE = new AtomicOperationDeleteCascade();
  AtomicOperation DELETE_CASCADE_FIRE_ACTIVITY_END = new AtomicOperationDeleteCascadeFireActivityEnd();
  void execute(InterpretableExecution execution);
  boolean isAsync(InterpretableExecution execution);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;具体动作的跳转见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/f35c3abf0ee213b3aaff97904c008db5.png&quot; alt=&quot;流程运转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就拿流程实例启动来说：AtomicOperationProcessStart来说，首先是抽象类里面的，
void execute(InterpretableExecution execution);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public void execute(InterpretableExecution execution) {
 //首先是判断监听的逻辑
    ScopeImpl scope = getScope(execution);
    List&amp;lt;ExecutionListener&amp;gt; exectionListeners = scope.getExecutionListeners(getEventName());
    int executionListenerIndex = execution.getExecutionListenerIndex();
    if (exectionListeners.size()&amp;gt;executionListenerIndex) {
      execution.setEventName(getEventName());
      execution.setEventSource(scope);
      ExecutionListener listener = exectionListeners.get(executionListenerIndex);
      try {
        listener.notify(execution);
      } catch (RuntimeException e) {
        throw e;
      } catch (Exception e) {
        throw new PvmException(&quot;couldn't execute event listener : &quot;+e.getMessage(), e);
      }
      execution.setExecutionListenerIndex(executionListenerIndex+1);
      execution.performOperation(this);

    } else {
      execution.setExecutionListenerIndex(0);
      execution.setEventName(null);
      execution.setEventSource(null);
      eventNotificationsCompleted(execution);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后就是自己实现的eventNotificationsCompleted(execution);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @Override
  protected void eventNotificationsCompleted(InterpretableExecution execution) {
  //首先还是事件通知
  	if (Context.getProcessEngineConfiguration() != null &amp;amp;&amp;amp; Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {
  	  Map&amp;lt;String, Object&amp;gt; variablesMap = null;
  	  try {
  	    variablesMap = execution.getVariables();
  	  } catch (Throwable t) {
  	    // In some rare cases getting the execution variables can fail (JPA entity load failure for example)
  	    // We ignore the exception here, because it's only meant to include variables in the initialized event.
  	  }
    	Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
    			ActivitiEventBuilder.createEntityWithVariablesEvent(ActivitiEventType.ENTITY_INITIALIZED,
    			    execution, variablesMap, false));
      Context.getProcessEngineConfiguration().getEventDispatcher()
              .dispatchEvent(ActivitiEventBuilder.createProcessStartedEvent(execution, variablesMap, false));
    }
  	//找到开始节点，直接的跳转到PROCESS_START_INITIAL
    ProcessDefinitionImpl processDefinition = execution.getProcessDefinition();
    StartingExecution startingExecution = execution.getStartingExecution();
    List&amp;lt;ActivityImpl&amp;gt; initialActivityStack = processDefinition.getInitialActivityStack(startingExecution.getInitial());  
    execution.setActivity(initialActivityStack.get(0));
    execution.performOperation(PROCESS_START_INITIAL);//说明①
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;说明①：流程实例启动后，直接的跳转到：PROCESS_START_INITIAL，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AtomicOperation PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;执行的过程是,首先是：      &lt;code class=&quot;highlighter-rouge&quot;&gt;org.activiti.engine.impl.pvm.runtime.AbstractEventAtomicOperation.execute(InterpretableExecution)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后才是正式的逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Override
  protected void eventNotificationsCompleted(InterpretableExecution execution) {
    ActivityImpl activity = (ActivityImpl) execution.getActivity();

    ProcessDefinitionImpl processDefinition = execution.getProcessDefinition();

    StartingExecution startingExecution = execution.getStartingExecution();
    //如果开始节点是起始节点
    if (activity==startingExecution.getInitial()) {
      execution.disposeStartingExecution();
      //转移到ACTIVITY_EXECUTE，执行activity对应的逻辑
      execution.performOperation(ACTIVITY_EXECUTE);

    } else {
    //如果不是开始节点，循环的找到开始节点
      List&amp;lt;ActivityImpl&amp;gt; initialActivityStack = processDefinition.getInitialActivityStack(startingExecution.getInitial());
      int index = initialActivityStack.indexOf(activity);
      activity = initialActivityStack.get(index+1);

      InterpretableExecution executionToUse = null;
      if (activity.isScope()) {
        executionToUse = (InterpretableExecution) execution.getExecutions().get(0);
      } else {
        executionToUse = execution;
      }
      executionToUse.setActivity(activity);
      executionToUse.performOperation(PROCESS_START_INITIAL);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后就到了activity的执行的逻辑：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicOperation ACTIVITY_EXECUTE = new AtomicOperationActivityExecute();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体的执行的逻辑是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void execute(InterpretableExecution execution) {
    ActivityImpl activity = (ActivityImpl) execution.getActivity();

    ActivityBehavior activityBehavior = activity.getActivityBehavior();
    if (activityBehavior==null) {
      throw new PvmException(&quot;no behavior specified in &quot;+activity);
    }

    log.debug(&quot;{} executes {}: {}&quot;, execution, activity, activityBehavior.getClass().getName());

    try {
    	if(Context.getProcessEngineConfiguration() != null &amp;amp;&amp;amp; Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {
      	Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
      			ActivitiEventBuilder.createActivityEvent(ActivitiEventType.ACTIVITY_STARTED,
      					execution.getActivity().getId(),
      					(String) execution.getActivity().getProperty(&quot;name&quot;),
      					execution.getId(),
      					execution.getProcessInstanceId(),
      					execution.getProcessDefinitionId(),
      					(String) activity.getProperties().get(&quot;type&quot;),
      					activity.getActivityBehavior().getClass().getCanonicalName()));
      }

      activityBehavior.execute(execution);
    } catch (RuntimeException e) {
      throw e;
    } catch (Exception e) {
      LogMDC.putMDCExecution(execution);
      throw new PvmException(&quot;couldn't execute activity &amp;lt;&quot;+activity.getProperty(&quot;type&quot;)+&quot; id=\&quot;&quot;+activity.getId()+&quot;\&quot; ...&amp;gt;: &quot;+e.getMessage(), e);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;activity的行为活动就非常的多了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ActivityBehavior extends Serializable {
  void execute(ActivityExecution execution) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;比较熟悉activitybehavior：
&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/8045d4e96f4f675834525a7127f6bb58.png&quot; alt=&quot;熟悉的activitybehavior&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Aug 2017 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/13/activiti6/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/13/activiti6/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(5)</title>
        <description>&lt;p&gt;此次行文是从一个定义好的流程定义开始梳理，流程启动的过程中涉及到的事件通知模型，即观察者设计模式。这个也是普遍采用的事件通知模型。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先我们还是看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
           ActivitiEventBuilder.createEntityEvent(
           ActivitiEventType.ENTITY_CREATED, processInstance
           ));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在看一下观察者模式说明：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;subject,observers 这是观察者和被观察者两个角色，构成这个模式的主题&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It is mainly used to implement distributed event handling systems, in “event driven” software. Most modern languages such as Java and C# have built in “event” constructs which implement the observer pattern components, for easy programming and short code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The observer pattern is also a key part in the familiar model–view–controller (MVC) architectural pattern.[1] The observer pattern is implemented in numerous programming libraries and systems, including almost all GUI toolkits.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个设计模式很通用，从JDK里面支持的Event构造就知道了。&lt;/p&gt;

&lt;p&gt;我们看一下主要的支持的框架的Interface：  &lt;br /&gt;
主题的框架，实现增加（删除）观察者，通知观察者等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ActivitiEventDispatcher {
   void addEventListener(ActivitiEventListener listenerToAdd);
   void addEventListener(ActivitiEventListener listenerToAdd, ActivitiEventType... types);
   void removeEventListener(ActivitiEventListener listenerToRemove);
   void dispatchEvent(ActivitiEvent event);
   void setEnabled(boolean enabled);
   boolean isEnabled();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个会在引擎初始化的时候，初始化该接口对应的实现类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void initEventDispatcher() {
  	if(this.eventDispatcher == null) {
  		this.eventDispatcher = new ActivitiEventDispatcherImpl();
  	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个实现类中也有一个比较有意思的点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ActivitiEventDispatcherImpl implements ActivitiEventDispatcher
   //该类的成员变量
	protected ActivitiEventSupport eventSupport;
	protected boolean enabled = true;

public class ActivitiEventSupport
  //该类的成员变量，以及构造函数
	protected List&amp;lt;ActivitiEventListener&amp;gt; eventListeners;
	protected Map&amp;lt;ActivitiEventType, List&amp;lt;ActivitiEventListener&amp;gt;&amp;gt; typedListeners;
	public ActivitiEventSupport() {
		eventListeners = new CopyOnWriteArrayList&amp;lt;ActivitiEventListener&amp;gt;();//有意思的点①
		typedListeners = new HashMap&amp;lt;ActivitiEventType, List&amp;lt;ActivitiEventListener&amp;gt;&amp;gt;();
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明有意思的点①：为什么是CopyOnWriteArrayList？&lt;/p&gt;

&lt;p&gt;CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。&lt;/p&gt;

&lt;p&gt;　在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。
　
　&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;但是CopyOnWriteArrayList 在读的时候是不加锁的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public E get(int index) {
        return get(getArray(), index);
    }
    private E get(Object[] a, int index) {
        return (E) a[index];
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这也就导致了CopyOnWriteArrayList的APIDOC所说的那样：This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don’t want to synchronize traversals, yet need to preclude interference among concurrent threads.&lt;/p&gt;

&lt;p&gt;所以：CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。
在Activiti引擎中的场景可谓是恰到好处，因为在引擎中的CopyOnWrite的存储的内容是：ActivitiEventListener，都是需要事先定义好的，比如：流程启动的时候需要做哪些事情，流程结束的时候需要做哪些事情，这些需要自定义扩展逻辑的时候，都应该在引擎加载的时候完成ActivitiEventListener的定义，所以使用CopyOnWrite恰恰好！&lt;/p&gt;

&lt;p&gt;观察者模式中的观察者接口：需要监听的事件，以及监听消息的后续逻辑失败了，是否返回异常的接口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ActivitiEventListener {

	/**
	 * Called when an event has been fired
	 * @param event the event
	 */
	void onEvent(ActivitiEvent event);

	/**
	 * @return whether or not the current operation should fail when this listeners execution
	 * throws an exception.
	 */
	boolean isFailOnException();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;具体的调用逻辑在ActivitiEventSupport中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void dispatchEvent(ActivitiEvent event, ActivitiEventListener listener) {
		try {
			listener.onEvent(event);
		} catch (Throwable t) {
			if (listener.isFailOnException()) {
				throw new ActivitiException(&quot;Exception while executing event-listener&quot;, t);
			} else {
				// Ignore the exception and continue notifying remaining listeners. The
				// listener
				// explicitly states that the exception should not bubble up
				LOG.warn(&quot;Exception while executing event-listener, which was ignored&quot;, t);
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的事件的封装，也没有使用JDK的event支持类，activiti自己封装的ActivitiEventImpl&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ActivitiEventImpl implements ActivitiEvent
	protected ActivitiEventType type;
	protected String executionId;
	protected String processInstanceId;
	protected String processDefinitionId;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;感谢：http://ifeve.com/java-copy-on-write/&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Aug 2017 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/13/activit5/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/13/activit5/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(4)</title>
        <description>&lt;p&gt;此次行文是从一个定义好的流程定义开始梳理，然后到流程启动，生成一个流程实例，提交第一个任务，任务完成，实例完成，实例完结。学习其中的设计模式，学习框架的设计的理念。&lt;/p&gt;

&lt;!--more--&gt;
&lt;ol&gt;
  &lt;li&gt;首先是找到流程的定义：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProcessDefinition def = repositoryService.createProcessDefinitionQuery().processDefinitionId(
workFlowId).processDefinitionTenantId(orgId).singleResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有一个需要注意的问题，这种情况下查找的流程定义，ProcessDefinition没有进行解析彻底，只是数据库字段的映射。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/400f810b94ca69ac6171fc1c29bed382.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启动流程实例：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ProcessInstance ins = runtimeService
 .startProcessInstanceById(workFlowId, formId,variablesObject);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进入命令行：StartProcessInstanceCmd&lt;ProcessInstance&gt;，返回的是一个ProcessInstance,具体的代码是：&lt;/ProcessInstance&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ProcessInstance execute(CommandContext commandContext) {
// 找到部署管理器DeploymentManager
  DeploymentManager deploymentManager = commandContext
    .getProcessEngineConfiguration()//说明①
    .getDeploymentManager();

  // Find the process definition
  ProcessDefinitionEntity processDefinition = null;
  if (processDefinitionId != null) {
    processDefinition = deploymentManager.findDeployedProcessDefinitionById(processDefinitionId);//说明②
  }
  // .......
  //这个地方省略了依靠其他参变量寻找processDefiniton的代码

  // Do not start process a process instance if the process definition is suspended
  if (deploymentManager.isProcessDefinitionSuspended(processDefinition.getId())) {
    throw new ActivitiException(&quot;Cannot start process instance. Process definition &quot;
            + processDefinition.getName() + &quot; (id = &quot; + processDefinition.getId() + &quot;) is suspended&quot;);
  }

  // Start the process instance
  ExecutionEntity processInstance = processDefinition.createProcessInstance(businessKey);//说明③

  // now set the variables passed into the start command
  initializeVariables(processInstance);//说明④

  // now set processInstance name
  if (processInstanceName != null) {
    processInstance.setName(processInstanceName);
    commandContext.getHistoryManager().recordProcessInstanceNameChange(processInstance.getId(), processInstanceName);
  }

  processInstance.start();//说明⑤

  return processInstance;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明①：CommandContext,以及processEngineConfiguration 都是单例的模式，只不过从代码上面看，和一般的单例模式不太一样，找不到private的构造方法。&lt;/p&gt;

&lt;p&gt;说明②: 通过部署管理器寻找流程定义的过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;org.activiti.engine.impl.persistence.deploy.DeploymentManager.
findDeployedProcessDefinitionById(String)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;首先是到缓存中查找，如果缓存中没有，再到数据库中查找，这个缓存的大小，可以在引擎的配置文件中配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;property name=&quot;processDefinitionCacheLimit&quot; value=&quot;10&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过数据库查找的流程定义依然是没有完全解析的，具体的全部的解析的过程在什么地方呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ProcessDefinitionEntity resolveProcessDefinition(ProcessDefinitionEntity processDefinition) {
    String processDefinitionId = processDefinition.getId();
    String deploymentId = processDefinition.getDeploymentId();
    processDefinition = processDefinitionCache.get(processDefinitionId);
    if (processDefinition==null) {
      DeploymentEntity deployment = Context
        .getCommandContext()
        .getDeploymentEntityManager()
        .findDeploymentById(deploymentId);//在这个地方拿到具体的流程定义文件，resource红有值了。
      deployment.setNew(false);
      deploy(deployment, null);//具体的解析发生在这个过程中，activitis填充了解析的内容
      processDefinition = processDefinitionCache.get(processDefinitionId);

      if (processDefinition==null) {
        throw new ActivitiException(&quot;deployment '&quot;+deploymentId+&quot;' didn't put process definition '&quot;+processDefinitionId+&quot;' in the cache&quot;);
      }
    }
    return processDefinition;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明③：activiti中没有ProcessInstanceEntity，有的只是ExecutionEntity。创建ExecutionEntity的时候，把历史数据全部的创建，并且插入了数据库中。&lt;/p&gt;

&lt;p&gt;另外还有流程实例创建的事件广播出去，这个使用的是观察者模式，这个模式在activiti中可谓是到处都是，主要用于事件的通知，订阅之类的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 实例数据创建
 Context.getCommandContext().getHistoryManager()
      .recordProcessInstanceStart(processInstance);

      // 事件广播
      if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {
        Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
                ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, processInstance));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;说明④：关于流程实例中的变量Variables，需要单独拿出来说明一下。&lt;/p&gt;

&lt;p&gt;说明⑤：进入状态机的设计模式&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Aug 2017 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/10/activit4/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/10/activit4/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(3)</title>
        <description>&lt;p&gt;提到activiti的核心业务的组织方式，就不得不提到，BPMN规范中各个图形代表的意义，各个参数的设置等等纷杂的问题。
中间我们关注的是activiti对bpmn规范中各个图形对应的对象组织方式，以及其中的设计模式。更准确的说是继承，扩展和组合的使用定义。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先是：流程定义的解析，我们可以知道总体的模型对应的类是：BpmnModel，但是这个模式是怎么得到的？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BpmnXMLConverter converter = new BpmnXMLConverter();

bpmnModel = converter.convertToBpmnModel(streamSource, validateSchema, enableSafeBpmnXml, encoding);
//使用fasterxml 来解析xml
if (ELEMENT_DEFINITIONS.equals(xtr.getLocalName())) {
    definitionsParser.parse(xtr, model);
} else if (ELEMENT_RESOURCE.equals(xtr.getLocalName())) {
resourceParser.parse(xtr, model);
} else if (ELEMENT_SIGNAL.equals(xtr.getLocalName())) {
signalParser.parse(xtr, model);
} else if (ELEMENT_MESSAGE.equals(xtr.getLocalName())) {
          messageParser.parse(xtr, model);
}

//具体针对各个BPMN规范的解析
protected BpmnEdgeParser bpmnEdgeParser = new BpmnEdgeParser();
protected BpmnShapeParser bpmnShapeParser = new BpmnShapeParser();
protected DefinitionsParser definitionsParser = new DefinitionsParser();
protected DocumentationParser documentationParser = new DocumentationParser();
protected ExtensionElementsParser extensionElementsParser = new ExtensionElementsParser();
protected ImportParser importParser = new ImportParser();
protected InterfaceParser interfaceParser = new InterfaceParser();
protected ItemDefinitionParser itemDefinitionParser = new ItemDefinitionParser();
protected IOSpecificationParser ioSpecificationParser = new IOSpecificationParser();
protected DataStoreParser dataStoreParser = new DataStoreParser();
protected LaneParser laneParser = new LaneParser();
protected MessageParser messageParser = new MessageParser();
protected MessageFlowParser messageFlowParser = new MessageFlowParser();
protected MultiInstanceParser multiInstanceParser = new MultiInstanceParser();
protected ParticipantParser participantParser = new ParticipantParser();
protected PotentialStarterParser potentialStarterParser = new PotentialStarterParser();
protected ProcessParser processParser = new ProcessParser();
protected ResourceParser resourceParser = new ResourceParser();
protected SignalParser signalParser = new SignalParser();
protected SubProcessParser subProcessParser = new SubProcessParser();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们最后看一下，BpmnModel的组成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	protected Map&amp;lt;String, List&amp;lt;ExtensionAttribute&amp;gt;&amp;gt; definitionsAttributes =
new LinkedHashMap\&amp;lt;String, List&amp;lt;ExtensionAttribute&amp;gt;\&amp;gt;();
	protected List&amp;lt;Process&amp;gt; processes = new ArrayList&amp;lt;Process&amp;gt;();
	protected Map&amp;lt;String, GraphicInfo&amp;gt; locationMap = new LinkedHashMap&amp;lt;String, GraphicInfo&amp;gt;();
	protected Map&amp;lt;String, GraphicInfo&amp;gt; labelLocationMap = new LinkedHashMap&amp;lt;String, GraphicInfo&amp;gt;();
	protected Map&amp;lt;String, List&amp;lt;GraphicInfo&amp;gt;&amp;gt; flowLocationMap = new LinkedHashMap&amp;lt;String, List&amp;lt;GraphicInfo&amp;gt;&amp;gt;();
	protected List&amp;lt;Signal&amp;gt; signals = new ArrayList&amp;lt;Signal&amp;gt;();
	protected Map&amp;lt;String, MessageFlow&amp;gt; messageFlowMap = new LinkedHashMap&amp;lt;String, MessageFlow&amp;gt;();
	protected Map&amp;lt;String, Message&amp;gt; messageMap = new LinkedHashMap&amp;lt;String, Message&amp;gt;();
	protected Map&amp;lt;String, String&amp;gt; errorMap = new LinkedHashMap&amp;lt;String, String&amp;gt;();
	protected Map&amp;lt;String, ItemDefinition&amp;gt; itemDefinitionMap = new LinkedHashMap&amp;lt;String, ItemDefinition&amp;gt;();
	protected Map&amp;lt;String, DataStore&amp;gt; dataStoreMap = new LinkedHashMap&amp;lt;String, DataStore&amp;gt;();
	protected List&amp;lt;Pool&amp;gt; pools = new ArrayList&amp;lt;Pool&amp;gt;();
	protected List&amp;lt;Import&amp;gt; imports = new ArrayList&amp;lt;Import&amp;gt;();
	protected List&amp;lt;Interface&amp;gt; interfaces = new ArrayList&amp;lt;Interface&amp;gt;();
	protected List&amp;lt;Artifact&amp;gt; globalArtifacts = new ArrayList&amp;lt;Artifact&amp;gt;();
	protected List&amp;lt;Resource&amp;gt; resources = new ArrayList&amp;lt;Resource&amp;gt;();
	protected Map&amp;lt;String, String&amp;gt; namespaceMap = new LinkedHashMap&amp;lt;String, String&amp;gt;();
	protected String targetNamespace;
	protected List&amp;lt;String&amp;gt; userTaskFormTypes;
	protected List&amp;lt;String&amp;gt; startEventFormTypes;
	protected int nextFlowIdCounter = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;你会发现，在调试的时候老出现的Activity之类的并没有出现，那么BpmnModel和ProcessDefinitionImpl是怎么关联起来的呢？同样是在BpmnParse中，可以发现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public BpmnParse execute() {
  。。。。。。
// Validation successfull (or no validation)
createImports();
createItemDefinitions();
createMessages();
createOperations();
transformProcessDefinitions();
  。。。。。。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;具体的操作是在：org.activiti.engine.impl.bpmn.parser.BpmnParse.processDI()中，主要的代码是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Parse diagram interchange information
        ProcessDefinitionEntity processDefinition = getProcessDefinition(process.getId());
        if (processDefinition != null) {
          processDefinition.setGraphicalNotationDefined(true);
          for (String shapeId : bpmnModel.getLocationMap().keySet()) {
            if (processDefinition.findActivity(shapeId) != null) {
              createBPMNShape(shapeId, bpmnModel.getGraphicInfo(shapeId), processDefinition);
            }
          }

          for (String edgeId : bpmnModel.getFlowLocationMap().keySet()) {
            if (bpmnModel.getFlowElement(edgeId) != null) {
              createBPMNEdge(edgeId, bpmnModel.getFlowLocationGraphicInfo(edgeId));
            }
          }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从这里我们可以看出来：BpmnModel只要支持的Bpmn的规范，支持的是xml中定义的各个图形的对象，以及对象的属性。ProcessDefinitionEntity主要的是流程运转的过程中的对象，这点从类的命名上面也可以看出来。&lt;/p&gt;

&lt;p&gt;这里想说的是设计模式：组合模式（Composite pattern），以及解析过程中的工程模式（Abstract factory pattern）。&lt;/p&gt;

&lt;p&gt;组合模式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先是每一个元素都会含有实行，在activiti中属性抽象为一个接口，
所有的基础元素都会实现该接口：			
org.activiti.bpmn.model.HasExtensionAttribute     

public abstract class BaseElement implements HasExtensionAttributes
public abstract class FlowElement extends BaseElement implements HasExecutionListeners

BaseElement 被设计为抽象的类型，这个感觉基础元素，不会出现在xml定义中，也就符合了抽象类：不能被实例化的特性。

BaseElement的继承的体系，如附件所示：

其中我们比较属性的Usertask，Process的集成体系也如附件中体现：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/51a6be4efb9206b6a0326456e01e1a7f.png&quot; alt=&quot;baseElement的集成体系&quot; /&gt;
&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/9eed650ff7bdedacf4170f0d064bff0c.png&quot; alt=&quot;flowElement继承体系&quot; /&gt;&lt;/p&gt;

&lt;p&gt;单独的把FlowElement列出来，是因为抽象类FlowElement中有一个比较好玩的，也是比较重要的方法：
 public abstract FlowElement clone();&lt;/p&gt;

&lt;p&gt;可以直接的克隆一个元素出来，在后期的扩展中，这个是比较有用的一个方法，在继承体系，所有的元素都实现了这个方法，也就为了后面的扩展提供了基础。&lt;/p&gt;

&lt;p&gt;上面的BpmnModel就是典型的组合模式，但是在继承体系中，也是含有组合的，最容易理解的莫过于子流程的定义了，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class SubProcess extends Activity implements FlowElementsContainer {
  protected List&amp;lt;FlowElement&amp;gt; flowElementList = new ArrayList&amp;lt;FlowElement&amp;gt;();
  protected List&amp;lt;Artifact&amp;gt; artifactList = new ArrayList&amp;lt;Artifact&amp;gt;();
  protected List&amp;lt;ValuedDataObject&amp;gt; dataObjects = new ArrayList&amp;lt;ValuedDataObject&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在BPMN的解析的过程中，使用到了抽象工厂的类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface BpmnParseFactory {
  BpmnParse createBpmnParse(BpmnParser bpmnParser);
}   

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认的工程类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class DefaultBpmnParseFactory implements BpmnParseFactory {

  public BpmnParse createBpmnParse(BpmnParser bpmnParser) {
    return new BpmnParse(bpmnParser);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用的情况：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (bpmnParseFactory == null) {
      bpmnParseFactory = new DefaultBpmnParseFactory();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;个人感觉有点过度设计的感觉，但是为了扩展，也是无可厚非。&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Aug 2017 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/10/activit3/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/10/activit3/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(2.1)</title>
        <description>&lt;p&gt;activiti中Command的执行的过程，也是一个设计模式来进行控制的，就是责任链设计模式，或者：&lt;strong&gt;Interpreter pattern&lt;/strong&gt;.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;首先是启动的代码：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//调用方：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runtimeService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startProcessInstanceById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workFlowId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;formId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variablesObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;      

&lt;span class=&quot;c1&quot;&gt;//调用的入口：&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startProcessInstanceById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://7xtrwx.com1.z0.glb.clouddn.com/fab71e2707099d49e0c04456244c7258.png&quot; alt=&quot;debug页面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出：CommandExecutor 已经包含了执行所需要的全部的内容，我们看一下执行的代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
 public &amp;lt;T&amp;gt; T execute(Command&amp;lt;T&amp;gt; command) {
   return execute(defaultConfig, command);
 }

 @Override
  public &amp;lt;T&amp;gt; T execute(CommandConfig config, Command&amp;lt;T&amp;gt; command) {
    return first.execute(config, command);
  }
  //这里我们可以看到，执行的过程进入了某一个链中。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个链总共有三个类构成：    &lt;br /&gt;
org.activiti.engine.impl.interceptor.LogInterceptor     &lt;br /&gt;
org.activiti.engine.impl.interceptor.CommandContextInterceptor     &lt;br /&gt;
org.activiti.engine.impl.interceptor.CommandInvoker&lt;/p&gt;

&lt;p&gt;这三个类全部实现了接口：CommandInterceptor&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface CommandInterceptor {

  &amp;lt;T&amp;gt; T execute(CommandConfig config, Command&amp;lt;T&amp;gt; command);
  CommandInterceptor getNext();
  void setNext(CommandInterceptor next);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过这个代码的 setNext方法，这三个类构成了一个执行链，在引擎初始化的时候，能够发现这个执行链构造和初始化的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void initCommandInvoker() {
  if (commandInvoker==null) {
    commandInvoker = new CommandInvoker();//③
  }
}

protected void initCommandInterceptors() {
    if (commandInterceptors==null) {
      commandInterceptors = new ArrayList&amp;lt;CommandInterceptor&amp;gt;();
      if (customPreCommandInterceptors!=null) {
        commandInterceptors.addAll(customPreCommandInterceptors);
      }
      commandInterceptors.addAll(getDefaultCommandInterceptors());
      if (customPostCommandInterceptors!=null) {
        commandInterceptors.addAll(customPostCommandInterceptors);
      }
      commandInterceptors.add(commandInvoker);
    }
  }

protected Collection&amp;lt; ? extends CommandInterceptor&amp;gt; getDefaultCommandInterceptors() {
   List&amp;lt;CommandInterceptor&amp;gt; interceptors = new ArrayList&amp;lt;CommandInterceptor&amp;gt;();
   interceptors.add(new LogInterceptor());//①

   CommandInterceptor transactionInterceptor = createTransactionInterceptor();
   if (transactionInterceptor != null) {
     interceptors.add(transactionInterceptor);
   }

   interceptors.add(new CommandContextInterceptor(commandContextFactory, this));//②
   return interceptors;
 }

//初始化这条链
 protected CommandInterceptor initInterceptorChain(List&amp;lt;CommandInterceptor&amp;gt; chain) {
    if (chain==null || chain.isEmpty()) {
      throw new ActivitiException(&quot;invalid command interceptor chain configuration: &quot;+chain);
    }
    for (int i = 0; i &amp;lt; chain.size()-1; i++) {
      chain.get(i).setNext( chain.get(i+1) );
    }
    return chain.get(0);
  }

  // commandExecutor 初始化完成
  protected void initCommandExecutor() {
     if (commandExecutor==null) {
       CommandInterceptor first = initInterceptorChain(commandInterceptors);
       commandExecutor = new CommandExecutorImpl(getDefaultCommandConfig(), first);
     }
   }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个三个拦截链都做了什么呢？第一个就是日志记录，虽然个人感觉比较的无聊，但是也可能是一个扩展的示例：LogInterceptor&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommandConfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// do nothing here if we cannot log&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;--- starting {} --------------------------------------------------------&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSimpleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;--- {} finished --------------------------------------------------------&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSimpleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第二个链：CommandContextInterceptor 主要是构建命令运行的执行的环境：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommandConfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;CommandContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCommandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
   &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextReused&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// We need to check the exception, because the transaction can be in a rollback state,&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// and some other command is being fired to compensate (eg. decrementing job retries)&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isContextReusePossible&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandContextFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createCommandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    	
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
   &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Valid context found. Reusing it for the current command '{}'&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCanonicalName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;contextReused&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;// Push on stack&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCommandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setProcessEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextReused&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// Pop from stack&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;removeCommandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;removeProcessEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;removeBpmnOverrideContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从这个环境构造，可以看出来两个问题：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;context的组织方式，是根据Command进行的，并且Context是通过stack进行组织的。&lt;/li&gt;
  &lt;li&gt;既然context是根据stack组织的，说明有压栈，出栈的操作，也就说明Command之间存在嵌套的可能性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第三个链：CommandInvoker 命令行的执行：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommandConfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCommandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到最终执行的过程，还是到了每一个的command类中，这也是符合预期的。此例中最终进入StartProcessInstanceCmd类中，执行代码:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommandContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DeploymentManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deploymentManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandContext&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProcessEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeploymentManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Find the process definition&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ProcessDefinitionEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;processDefinition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deploymentManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findDeployedProcessDefinitionById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;。。。。。。。。&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Start the process instance&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ExecutionEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;。。。。。。。。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;processInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出来这个是 Interpreter pattern 和 Command Pattern 联合使用的一种情况，就目的而言，试分析一二：     &lt;br /&gt;
总结来自：&lt;/p&gt;

&lt;p&gt;1）一个产品或者一个项目，很少是一个人开发出来的，大多都涉及到协同工作。但是既然是一个框架，那么总体上面的需要有一个规范，利于大家的开发，利于大家的协调。这个就是架构的意义所在。 有了具体的架构的约束，加入一些基础的组件，基本上能够把实现的大体的过程规划出来，这样这个框架的整体的风格也就确定了。就像Activiti做的这样，明确以Command作为基本开发模型，辅之以Event-Listener，这样编程风格的整体性得到了保证。&lt;/p&gt;

&lt;p&gt;2）使用命令模式和责任链的好处 职责分离，解耦。有了Command，各个Service从角色上说只是一些协调者或者控制者，不需要知道具体怎么做，他只是把任务交给了各个命令。便于封装每一个的功能&lt;/p&gt;

&lt;p&gt;3）解耦之后，随之带来的一个好处，就是扩展或者说灵活性的增加，我们可以把自己扩展的动作按照同样的方式，封装成一个一个的command，更加的便于理解和别人的使用。大大的增加activiti的生态。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Aug 2017 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/10/activit20/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/10/activit20/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
      <item>
        <title>activiti和设计模式(2)</title>
        <description>&lt;p&gt;acititi每一个的server的实现的总体的逻辑实现，堪称是一个模板。一个设计模式的典型的案例，非常的值得学习。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;activity服务的实现，很有自己的特色，show code:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RuntimeServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RuntimeService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startProcessInstanceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startProcessInstanceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startProcessInstanceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startProcessInstanceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;……………&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里面有两个很引人注意的地方：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;commandExecutor 这个究竟是什么东西？&lt;/li&gt;
  &lt;li&gt;XXXXXCmd 的类型&lt;br /&gt;
  其实这都是 命令行模式 的实现类，不过activiti里面命令行模式和普通的命令行模式还有点差别的，具体的我们后面会说到。首先看命令行模式：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;In object-oriented programming, the command pattern is a behavioral design pattern in which &lt;strong&gt;an object is used to encapsulate all information needed to perform an action or trigger an event at a later time.&lt;/strong&gt; This information includes the method name, the object that owns the method and values for the method parameters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;命令行主要针对的是一个动作或者触发的封装&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Four terms always associated with the command pattern are command, receiver, invoker and client.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A command object knows about receiver and invokes a method of the receiver. Values for parameters of the receiver method are stored in the command,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;the receiver object to execute these methods is also stored in the command object by aggregation. The receiver then does the work when the execute() method in command is called.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;An invoker object knows how to execute a command, and optionally does bookkeeping about the command execution. The invoker does not know anything about a concrete command, it knows only about command interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Invoker object(s), command objects and receiver objects are held by a client object, the client decides which receiver objects it assigns to the command objects, and which commands it assigns to the invoker. The client decides which commands to execute at which points. To execute a command, it passes the command object to the invoker object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;共有四部分：command 命令，receiver 接受方，invoker 执行方，client，客户端也就是调用方。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Using command objects makes it easier to construct general components that need to delegate, sequence or execute method calls at a time of their choosing without the need to know the class of the method or the method parameters. Using an invoker object allows bookkeeping about command executions to be conveniently performed, as well as implementing different modes for commands, which are managed by the invoker object, without the need for the client to be aware of the existence of bookkeeping or modes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们来看一下，RunTimeService的实现：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RuntimeServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RuntimeService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startProcessInstanceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceImpl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessEngineConfigurationImpl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessEngineConfigurationImpl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;processEngineConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processEngineConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CommandExecutor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CommandExecutor&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCommandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setCommandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommandExecutor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;commandExecutor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以分析命令行模式的四个角色：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端，Client ，即RuntimeServiceImpl，包含了命令行，接收方。确定了调用的入口：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Autowired
  public RuntimeService runtimeService;
  ProcessInstance ins = runtimeService.startProcessInstanceById(workFlowId, formId,variablesObject);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;命令行，这个比较的明显,StartProcessInstanceCmd类，就像上面所说的：&lt;strong&gt;Values for parameters of the receiver method are stored in the command&lt;/strong&gt; 代码：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tenantId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processInstanceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartProcessInstanceCmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;processDefinitionKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;processDefinitionId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processDefinitionId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;businessKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;businessKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的是命令行接口：Command&lt;T&gt;&lt;/T&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommandContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;剩下两个是：Invoker，和receiver 不是很好的区分，但是我们从RuntimeServiceImpl里面的类名称，可以探究一二：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected CommandExecutor commandExecutor;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出来：ComandExecutor 是执行者，另外我们从receiver的定义中：&lt;/p&gt;

&lt;p&gt;the receiver object to execute these methods is also stored in the command object by aggregation. The receiver then does the work when the execute() method in command is called.&lt;/p&gt;

&lt;p&gt;也能够看出来：CommandContext 是 receiver .&lt;/p&gt;

&lt;p&gt;下面让我们梳理一下，具体的执行的过程，也说明一下activiti的命令行模式的特殊的地方：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;准备工作：receiver已经在引擎中配置完毕了:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 初始化引擎的时候，初始化了CommandContextFactory工厂类
  protected void initCommandContextFactory() {
  if (commandContextFactory==null) {
   commandContextFactory = new CommandContextFactory();
  }
  commandContextFactory.setProcessEngineConfiguration(this);
  }
  //在factory中，可以根据command直接的创建CommandContext
  public CommandContext createCommandContext(Command&amp;lt;?&amp;gt; cmd) {
  return new CommandContext(cmd, processEngineConfiguration);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;0.1 执行者也是在命令行初始化之前完成的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** this will be initialized during the configurationComplete() */
 protected CommandExecutor commandExecutor;

 // 执行者的设计，就是一个链式拦截器
 protected void initCommandExecutor() {
    if (commandExecutor==null) {
      CommandInterceptor first = initInterceptorChain(commandInterceptors);
      commandExecutor = new CommandExecutorImpl(getDefaultCommandConfig(), first);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以现在只剩下，建立命令行了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new StartProcessInstanceCmd&amp;lt;ProcessInstance&amp;gt;(processDefinitionKey, null, null, null)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的执行的过程是： 一个命令是怎么在 client,receiver,invoker 之间运转的，明天分析&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Aug 2017 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/activiti-desigen-pattern/2017/08/08/activit2/</link>
        <guid isPermaLink="true">http://localhost:4000/activiti-desigen-pattern/2017/08/08/activit2/</guid>
        
        <category>学习</category>
        
        
        <category>activiti-desigen-pattern</category>
        
      </item>
    
  </channel>
</rss>
