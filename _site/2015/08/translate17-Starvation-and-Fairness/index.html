<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="andihappy" />
    <meta name="viewport" content="width=device-width">
    <title>Concurrence-17-Starvation and Fairness | andihappy</title>
	<!-- Jim disable
	script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?autoload=true&skin=Desert"></script-->
    <link href="/feed/" rel="alternate" title="andihappy" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/highlight.css">
    <link href='/media/webfonts/ss-social.css' rel='stylesheet'>
    <link href='/media/webfonts/ss-standard.css' rel='stylesheet'>

    <script language="JavaScript"><!--
        if (navigator.userAgent.match(/iPhone|iPod|Android|IEMobile/i)) {
            document.write("<link href=\"/media/css/screen-mobil.css\" rel=\"stylesheet\">");
        } else {
            document.write("<link href=\"/media/css/screen.css\" rel=\"stylesheet\">");
        }
        // -->
    </script>

    <!--script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script-->
    <script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.2.min.js"></script>

  </head>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <div class="buttons">
          <a href="/" class="ss-icon" title="Go to homepage">home</a>
          <a href="/categories" class="ss-icon" title="Category" >list</a>
          <a href="/tags" class="ss-icon" title="Tag Cloud" >tags</a>
          <a href="/guestbook" class="ss-icon" title="Guest Book" >talk</a>
          <a href="/about" class="ss-icon" title="About" >user</a>
          <a href="/feed" class="ss-icon" title="Subscribe by RSS" >rss</a>
		 <a href="/demo" class="ss-icon" title="Demo" >heart</a>
        </div>
        <h1>Concurrence-17-Starvation and Fairness</h1>
        </header>
        <hr>
        <article class="content">
        <section class="post">
<h4 id="starvation-and-fairness">Starvation and Fairness</h4>
<p><br />
##### 饥饿和公平
<br /></p>

<p>文章的地址：<a href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html">翻译文章的源地址</a>
<br /></p>

<p>如果一个线程因为其他的线程一直占用的CPU时间而没有被分配cpu时间，这种情况称之为饥饿。因为其他的线程一直的占有
CPU的时间，这个线程就会饿死。这个情况的解决办法：公平，所有的线程保证公平获得执行的机会。</p>

<h5 id="java">java中引起饥饿的原因</h5>

<p>主要有下面三个原因引起饥饿：
1.高优先级的线程吞掉了低优先级的CPU时间    <br />
2.因为一直有其他的线程进入同步款，线程无限期的等待进入synchronized块  <br />
3.其他的线程常被唤醒，这个线程一直等待着</p>

<h5 id="cpu">优先级高的线程吞掉优先级低的CPU时间</h5>

<p>你可以单独的设置每一个线程的优先级。优先级比较高的线程肯定会比优先级低的获得更加多的时间，线程的优先级可以设置为1
到10，具体是怎么解释这10个优先级取决于你的应用运行在的操作系统。对大多数应用来说，优先级最好是固定的。</p>

<h5 id="synchronized">线程在进入synchronized同步块时阻塞</h5>

<p>java的synchronized代码块阻塞，也是线程饥饿的一个原因。java的synchronized代码块不能够保证等待在同步代码外的线程
按照一定的顺序进入代码块内。这就意味着有一种可能：某一个线程一直被阻塞在代码块外面，永远的都在尝试着进入代码块内
因为总有其他的线程能够在它之前进入代码块内。这个问题就称为“饥饿”，一个线程可能会因为一直被其他线程占有着CPU，自己
因为分配不到CPU而被饿死。</p>

<h5 id="section">线程在一个对象上无限期的等待下去</h5>

<p>如果多个线程都调用了一个对象的wait方法，notify方法的调用不能够保证那一个的线程就能够被唤醒。其他的任何线程都在等待
，这个就有一个情况，某一个线程永远的被等待着，因为每次唤醒的都是其他的线程。</p>

<h4 id="java-1">java中公平的实现</h4>

<p>虽然不能够保证100%的公平，但是我们可以提高我们的同步实现机机制来提高线程之间的公平性。
首先，我们先看一段同步代码块的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class Synchronizer{

  public synchronized void doSynchronized(){
    //do a lot of work which takes a long time
  }

}
</code></pre>
</div>

<p>如果多个线程调用doSynchronized()方法，其中的一些线程就会阻塞知道第一个线程得到访问的权限并且执行
结束。如果多个线程都等待着，那么这里就没有任何的保证下次哪一个线程获得访问的权限。</p>

<h4 id="synchronized-1">使用锁而不是synchronized代码块</h4>

<p>为了实现等待线程之间的公平性，我们首先通过一个锁来保证代码块的线程安全，替换掉原来的synchronized
代码块：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class Synchronizer{
  Lock lock = new Lock();

  public void doSynchronized() throws InterruptedException{
    this.lock.lock();
      //critical section, do a lot of work which takes a long time
    this.lock.unlock();
  }

}
</code></pre>
</div>

<p>代码中，doSynchronized方法不再声明为synchronized，替代它的是使用lock.lock() 和
lock.unlock()方法保护着竞争区域。</p>

<p>锁的简单的实现，如下代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class Lock{
  private boolean isLocked      = false;
  private Thread  lockingThread = null;

  public synchronized void lock() throws InterruptedException{
    while(isLocked){
      wait();
    }
    isLocked      = true;
    lockingThread = Thread.currentThread();
  }

  public synchronized void unlock(){
    if(this.lockingThread != Thread.currentThread()){
      throw new IllegalMonitorStateException(
        "Calling thread has not locked this lock");
    }
    isLocked      = false;
    lockingThread = null;
    notify();
  }
}

</code></pre>
</div>

<p>如果你看看上面的同步类，看着这把锁执行，你会发现，如果多个线程同时调用lock()，线程试图访问lock()
方法被阻塞。第二，如果锁被锁定，线程被阻止在lock方法的while循环里wait()方法。以前说过：调用了
wait方法，就释放了Lock实例上的锁，所以其他的线程就能够进入lock方法，这样所有的线程都能够进入
lock方法，调用了wait。</p>

<p>doSynchronized方法中，在lock()和unLock()方法中间的评论：两者之间的代码需要很长一段时间才能够执行
结束。我们首先假设：这段代码执行的时间会比进入lock方法和调用wait方法要长很多，因为锁已经被锁定。
这就意味着，等待锁着锁和进入临界区所花的时间，大多数时间花在在wait()方法的调用上，而不是阻塞在
试图进入lock()方法。</p>

<p>像先前提到的，多个线程等在在synchronized同步代码块之外的，不能够保证哪一个线程能够进入代码块，
现在调用wait()的方法等待的线程也不能够决定在调用了notify()方法后那一个线程被唤醒。所以现在这个
版本的Lock类，与synchronized相比较的话，也不能够保证线程之间的公平。但是我们可以修改Lock类。</p>

<p>现在版本的Lock类，调用它自己的wait()方法，如果每一个线程调用一个分开对象的wait()方法，这样的话
每一个线程都会调用一个对象的wait()方法，Lock类决定那一个对象的notify()方法会被调用，这样就能够
精确的确定哪一个线程会被唤醒。</p>

<h4 id="section-1">一个公平锁</h4>

<p>下面就是在原来Lock上面修改的公平锁，叫做FairLock，对比着先前的Lock类，在实现上面 和synchronized，wait()/notify()
有一点区别。</p>

<p>到达设计一个公平锁，前面几篇已经说明了几个问题：嵌套管程锁死，条件滑丢，信号丢失，这些都会在这个翻译
中涉及到，现在我们先看这个公平锁，每一个线程调用lock都要排队，只有第一个线程能够获得FairLock实例
上面的锁，如果它解锁，其他的线程会一直阻塞直到他们到达队列的顶部。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class FairLock {
    private boolean           isLocked       = false;
    private Thread            lockingThread  = null;
    private List&lt;QueueObject&gt; waitingThreads =
            new ArrayList&lt;QueueObject&gt;();

  public void lock() throws InterruptedException{
    QueueObject queueObject           = new QueueObject();
    boolean     isLockedForThisThread = true;
    synchronized(this){
        waitingThreads.add(queueObject);
    }

    while(isLockedForThisThread){
      synchronized(this){
        isLockedForThisThread =
            isLocked || waitingThreads.get(0) != queueObject;
        if(!isLockedForThisThread){
          isLocked = true;
           waitingThreads.remove(queueObject);
           lockingThread = Thread.currentThread();
           return;
         }
      }
      try{
        queueObject.doWait();
      }catch(InterruptedException e){
        synchronized(this) { waitingThreads.remove(queueObject); }
        throw e;
      }
    }
  }

  public synchronized void unlock(){
    if(this.lockingThread != Thread.currentThread()){
      throw new IllegalMonitorStateException(
        "Calling thread has not locked this lock");
    }
    isLocked      = false;
    lockingThread = null;
    if(waitingThreads.size() &gt; 0){
      waitingThreads.get(0).doNotify();
    }
  }
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>public class QueueObject {

  private boolean isNotified = false;

  public synchronized void doWait() throws InterruptedException {
    while(!isNotified){
        this.wait();
    }
    this.isNotified = false;
  }

  public synchronized void doNotify() {
    this.isNotified = true;
    this.notify();
  }

  public boolean equals(Object o) {
    return this == o;
  }
}
</code></pre>
</div>
<p>首先，lock方法已经不再声明为synchronized，替代的是需要同步的内容放在了synchronized代码块里面。</p>

<p>在FairLock中，当每一个线程在调用lock的时候，创建了一个新的QueueObject实例，并且加入了一个队列。
线程在调用unlock的时候，将会取队列顶部的QueueObject实例，调用上面的doNotify()方法，唤醒等待这个
类上面的线程。这种方式在某一个时刻只有一个线程被唤醒，而不是所有的全部被唤醒，这一部分作为FairLock公平性
的一部分，。</p>

<p>在同一个synchronized代码块里面校验和设置锁的状态，避免条件丢失。</p>

<p>另外QueueObject 是一个真的信号量。dowait方法和doNotify方法把信号保存在QueueObject的内部，这样能够避免信号的丢失
的情况发生，例如：另外一个线程刚刚调用了unLock方法，就是QueueObject.doNotify()方法，这个线程就去调用QueueObject
的doWait方法。 QueueObject.doWait调用在synchronized(this),避免嵌套管程死锁。所以当没有线程在
synchronized(this)代码块的lock方法内另外的线程可以调用unlock方法。</p>

<p>最终，queueObject.doWait()的调用是在一个try-catch里面，如果一个InterruptedException 异常抛出的时候，
我们需要把它移除队列。</p>

<p>性能</p>

<p>如果你比较Lock和fairLock的代码，你会发现在lock和unlock方法中，FairLock总多了一些东西，额外多出的代码会使FairLock执行的时候比Lock慢一点。
这点对你的应用的影响，取决于被公平锁保护的竞争区内代码的执行时间，竞争区内的代码执行时间越长，影响就会越小，当然它也和这段代码执行的频率有关。</p>


</section>



<section class="meta">
  <br/>
  <br/>
<span class="sub_pagination">
  
    <a class="sub_pagination-item newer" href="/2015/08/OS-java-1/">上一篇&nbsp  梳理基础-计算机原理和java <i class="fa fa-chain"></i></a>
  
  
    <a class="sub_pagination-item newer" href="/2015/08/translate16-Deadlock-Prevention/">下一篇 &nbsp Concurrence-16-Deadlock Prevention <i class="fa fa-share"></i></a>
  
  </span>
  <br/>
  <br/>
</section>
<!--<span class="author">
  <a href="http://blog.sevenche.com">andihappy</a> - 程序员，企业管理与互联网结合应用的爱好者，现就职于北京。
</span>
<br /> 
</br>
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="/categories/#翻译 java 并发编程 多线程" title="翻译 java 并发编程 多线程">翻译 java 并发编程 多线程</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="/tags/#翻译 并发编程 多线程" title="翻译 并发编程 多线程">翻译 并发编程 多线程</a>&nbsp;
  
</span>

<span class="time">
  <br/>
  <time datetime="2015-08-19">2015-08-19</time>
</span>
!-->



<section  class="comment">
<!-- baidu JIA -->
<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a title="分享到QQ空间" href="#" class="bds_qzone" data-cmd="qzone"></a><a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a><a title="分享到腾讯微博" href="#" class="bds_tqq" data-cmd="tqq"></a><a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a><a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<!-- end of baidu JIA -->
<!-- Duoshuo Comment BEGIN -->
	<div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"flyBread"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- Duoshuo Comment END -->
</section>


<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://andihappy.github.io//2015/08/translate16-Deadlock-Prevention/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://andihappy.github.io//2015/08/OS-java-1/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})

</script>

<style type="text/css">
/*resize the big pic*/
div.resized_image p {
  margin: 2px;
  margin-top: 0;
  font-size: 8px;
  /* Awesome icon from here: http://www.famfamfam.com/lab/icons/silk/ */
  background: url(http://i242.photobucket.com/albums/ff244/9861_omikron/error.png) no-repeat;
  padding-left: 20px;
  color: #333;
}
</style>
<script type="text/javascript">
//resize the big pic
$(window).load(function() {
  (
    function(maxht, maxwt, minht, minwt) {
      var imgs = document.getElementsByTagName('img');
      // Image resizing function
      var resize_image = function(img, newht, newwt) {
        img.height = newht;
        img.width  = newwt;
        $(img).wrap('<table><tr><td class="tborder"><div class="resized_image"><a href="' + img.src + '" target="_blank"></a></div></td></tr></table>');
        $(img).parent().before('<p>NOTE: This image was resized. To view it full-size, click on the image.</p>');
        //$(img).parent().after('<p style="text-align:right;background:none;margin:0;padding-right:3px">Image resizing script by <a href="http://aetus.net/217/programming/automatically-resize-large-images-with-javascript/">Aetus Designs</a>.</p>');
      };
      
      for (var i = 0; i < imgs.length; i++) {
        // Set a variable for the current image to make the code make more sense.
        var img = imgs[i];
        if (img.height > maxht || img.width > maxwt) {
          // Use Ratios to constraint proportions.
          var old_ratio = img.height / img.width;
          var min_ratio = minht / minwt;
          // If it can scale perfectly.
          if (old_ratio === min_ratio) {
            resize_image(img, minht, minwt);
          } 
          // We need to do some magic now.
          else {
            var newdim = [img.height, img.width];
            // Sort out the height first.
            newdim[0] = minht;
            // The logic behind this is that if ratio = ht / wt, then wt = ht / ratio.
            newdim[1] = newdim[0] / old_ratio;
            // Do we still have to sort out the width?
            if (newdim[1] > maxwt) {
              // Just do what we did with the height
              newdim[1] = minwt;
              newdim[0] = newdim[1] * old_ratio;
            }
            // So yeah, resize the image
            resize_image(img, newdim[0], newdim[1]);
          }
        }
      }
    }
  )(780, 780, 780, 780);
});
</script>
        </article>
      </div>

    <footer>
        <p><small>Free hosted at <a href="https://github.com/flyBread">Github</a> | Copyright 2014 - 2017
		<!-- *** Please Keep bellow link for at least 6 months! Thanks！*** -->
		<a href="http://flybread.github.io/">Template Maintained by flyBread</a>

		| <span class="label label-info">2017-01-12 21:12:06 CST</span></small></p>
    </footer>

    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'Coder-zhailzh@126.com', 'flyBread.github.io');
  ga('send', 'pageview');

</script>
  </body>
</html>
