<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="andihappy" />
    <meta name="viewport" content="width=device-width">
    <title>zookeeper的认知(一) | andihappy</title>
	<!-- Jim disable
	script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?autoload=true&skin=Desert"></script-->
    <link href="/feed/" rel="alternate" title="andihappy" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/highlight.css">
    <link href='/media/webfonts/ss-social.css' rel='stylesheet'>
    <link href='/media/webfonts/ss-standard.css' rel='stylesheet'>

    <script language="JavaScript"><!--
        if (navigator.userAgent.match(/iPhone|iPod|Android|IEMobile/i)) {
            document.write("<link href=\"/media/css/screen-mobil.css\" rel=\"stylesheet\">");
        } else {
            document.write("<link href=\"/media/css/screen.css\" rel=\"stylesheet\">");
        }
        // -->
    </script>

    <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
    <!-- <script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.2.min.js"></script> -->

  </head>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <div class="buttons">
          <a href="/" class="ss-icon" title="Go to homepage">home</a>
          <a href="/categories" class="ss-icon" title="Category" >list</a>
          <!--<a href="/tags" class="ss-icon" title="Tag Cloud" >tags</a>-->
          <a href="/guestbook" class="ss-icon" title="Guest Book" >talk</a>
          <a href="/about" class="ss-icon" title="About" >user</a>
          <a href="/feed" class="ss-icon" title="Subscribe by RSS" >rss</a>
		 <a href="/demo" class="ss-icon" title="Demo" >heart</a>
        </div>
        <h1>zookeeper的认知(一)</h1>
        </header>
        <hr>
        <article class="content">
        <section class="post">
<blockquote>
  <p>1.zookeeper的基本的认识</p>

</blockquote>

<h3 id="zookeeper">1.zookeeper的基本的认识</h3>

<p>ZooKeeper is a distributed, open-source coordination service for distributed applications. It exposes a simple set of primitives that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming.</p>

<p>zookeeper作为一个开源的分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>

<p>Design Goals
ZooKeeper is simple. ZooKeeper allows distributed processes to coordinate with each other through a shared hierarchal namespace which is organized similarly to a standard file system. The name space consists of data registers - called znodes, in ZooKeeper parlance - and these are similar to files and directories. Unlike a typical file system, which is designed for storage, ZooKeeper data is kept in-memory, which means ZooKeeper can achieve high throughput and low latency numbers.</p>

<p>zookeeper允许分布式系统通过操作一个共享的具有层级结构的命名空间，这个空间的组织形式类似标准的文件系统，来相互的协调。这个有数据节点，在Zookeeper中称为znodes，组成的命名空间非常的类似文件和文件夹的概念。与为存储设计的典型文件系统不同，ZooKeeper中的数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟</p>

<p>The ZooKeeper implementation puts a premium on high performance, highly available, strictly ordered access. The performance aspects of ZooKeeper means it can be used in large, distributed systems. The reliability aspects keep it from being a single point of failure. The strict ordering means that sophisticated synchronization primitives can be implemented at the client.</p>

<p>ZooKeeper实现了高性能，高可用性，严格的排序访问。ZooKeeper的实现的这些性能方面保证它可以在大型分布式系统中使用。可靠性防止它成为单点故障。严格排序访问意味着复杂的同步原语可以在客户端实现。</p>

<p>ZooKeeper is replicated（可复制的）. Like the distributed processes it coordinates, ZooKeeper itself is intended to be replicated over a sets of hosts called an ensemble.</p>

<p><img src="http://7xtrwx.com1.z0.glb.clouddn.com/3b3ae8f43c9d1a02a1789b2a4e26a99f.png" alt="zookper的架构" /></p>

<p>The servers that make up the ZooKeeper service must all know about each other. They maintain an in-memory image of state, <strong>along with a transaction logs and snapshots in a persistent store</strong>. As long as a majority of the servers are available, the ZooKeeper service will be available.</p>

<p>组成zk服务的机子能够互相的感知到对方，</p>

<p>Clients connect to a single ZooKeeper server. The client maintains a TCP connection through which it sends requests, gets responses, gets watch events, and sends heart beats. If the TCP connection to the server breaks, the client will connect to a different server.</p>

<p>ZooKeeper is ordered. ZooKeeper stamps each update with a number that reflects the order of all ZooKeeper transactions. Subsequent operations can use the order to implement higher-level abstractions, such as synchronization primitives.</p>

<p>ZooKeeper is fast. It is especially fast in “read-dominant” workloads. ZooKeeper applications run on thousands of machines, and it performs best where reads are more common than writes, at ratios of around 10:1.</p>

<h4 id="section">数据结构和层次结构</h4>
<p>Data model and the hierarchical namespace
The name space provided by ZooKeeper is much like that of a standard file system. A name is a sequence of path elements separated by a slash (/). Every node in ZooKeeper’s name space is identified by a path.</p>

<p><img src="http://7xtrwx.com1.z0.glb.clouddn.com/079c0df3293602c0ff09f604d9dfcd1b.png" alt="zk的数据结构" />
zk中的节点的组织的形式，很像文件的路径。</p>

<h4 id="nodes-and-ephemeral-nodes">Nodes and ephemeral nodes</h4>
<p>Unlike standard file systems, each node in a ZooKeeper namespace can have data associated with it as well as children. It is like having a file-system that allows a file to also be a directory. (ZooKeeper was designed to store coordination data: status information, configuration, location information, etc., so the data stored at each node is usually small, in the byte to kilobyte range.) We use the term znode to make it clear that we are talking about ZooKeeper data nodes.</p>

<p>zk节点本身有对应的节点值，也可以拥有孩子节点。</p>

<p>Znodes maintain a stat structure that includes version numbers for data changes, ACL changes, and timestamps, to allow cache validations and coordinated updates. Each time a znode’s data changes, the version number increases. For instance, whenever a client retrieves data it also receives the version of the data.</p>

<p>zk为维护包括数据变化的版本号，ACL的变化，时间戳等数据组成的一个快照类型的数据结构。</p>

<p>The data stored at each znode in a namespace is read and written atomically. Reads get all the data bytes associated with a znode and a write replaces all the data. Each node has an Access Control List (ACL) that restricts who can do what.</p>

<p>zk中的每一个节点都会有一个访问控制列表。</p>

<p>ZooKeeper also has the notion of ephemeral nodes. These znodes exists as long as the session that created the znode is active. When the session ends the znode is deleted. Ephemeral nodes are useful when you want to implement [tbd].</p>

<p>Conditional updates and watches
ZooKeeper supports the concept of watches. Clients can set a watch on a znode. A watch will be triggered and removed when the znode changes. When a watch is triggered, the client receives a packet saying that the znode has changed. If the connection between the client and one of the Zoo Keeper servers is broken, the client will receive a local notification. These can be used to [tbd].</p>

<p>Guarantees
ZooKeeper is very fast and very simple. Since its goal, though, is to be a basis for the construction of more complicated services, such as synchronization, it provides a set of guarantees. These are:</p>

<p>Sequential Consistency - Updates from a client will be applied in the order that they were sent.
Atomicity - Updates either succeed or fail. No partial results.
Single System Image - A client will see the same view of the service regardless of the server that it connects to.
Reliability - Once an update has been applied, it will persist from that time forward until a client overwrites the update.
Timeliness - The clients view of the system is guaranteed to be up-to-date within a certain time bound.
For more information on these, and how they can be used, see [tbd]</p>

<p>Simple API
One of the design goals of ZooKeeper is provide a very simple programming interface. As a result, it supports only these operations:</p>

<p>create
creates a node at a location in the tree</p>

<p>delete
deletes a node</p>

<p>exists
tests if a node exists at a location</p>

<p>get data
reads the data from a node</p>

<p>set data
writes data to a node</p>

<p>get children
retrieves a list of children of a node</p>

<p>sync
waits for data to be propagated</p>

<p>For a more in-depth discussion on these, and how they can be used to implement higher level operations, please refer to [tbd]</p>

<p>Implementation
ZooKeeper Components shows the high-level components of the ZooKeeper service. With the exception of the request processor, each of the servers that make up the ZooKeeper service replicates its own copy of each of the components.</p>

<p>这里不再具体提zk的选主逻辑，paxos协议什么的，只开始讲一些用法。
kazoo是一个封装了zookeeper操作的python库，其中除了提供底层的zookeeper接口外，还提供了一些更高级别的封装。</p>

<p>zookeeper的基本操作
zookeeper主要操作分以下几种：
创建节点
读节点数据
更新节点数据
删除节点
监控节点变化
其中节点被组织成目录树的形式，每个节点下面都可以有一些子节点。
节点可以是以下四种类型：
PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；
PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；
EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；
EPHEMERAL_SEQUENTIAL：临时自动编号节点。
监控节点变化时，可以监控一个节点的变化，也可以监控一个节点所有子节点的变化。</p>

<p>ZK应用
统一命名服务
在分布式系统中，经常需要给一个资源生成一个唯一的ID，在没有中心管理结点的情况下生成这个ID并不是一件很容易的事儿。zk就提供了这样一个命名服务。
一般是使用create方法，创建一个自动编号的节点。</p>

<p>配置管理
主要用于多个结点共享配置，并且在配置发生更新时，利用zk可以让这些使用了这些配置的结点获得通知，进行重新加载等操作。</p>

<p>集群管理
主要有两个方面：一是集群选主，二是资源定位。
集群选主是当一个集群会启动一主一备两个服务单元时，可以使用zk来选出一个主服务单元。 具体方法就是在一个节点下创建一个自动编号的临时结点，然后watch父节点，如果该临时节点成为父节点下编号最小的节点，则认为其成为了主服务单元。
在kazoo中，提供了 election 相关的封装，使用极其简单。</p>

<p>zk = KazooClient(hosts=’127.0.0.1:2181’)
zk.start(10)</p>

<p>election = zk.Election(“/electionpath”, “my-identifier”)</p>

<h1 id="blocks-until-the-election-is-won-then-calls">blocks until the election is won, then calls</h1>
<p># my_leader_function()
election.run(my_leader_function)
在实际使用时有时候会遇到一些工作单元watch集群的master结点，当主从切换时，工作单元可能会需要重新连接到新的主节点以使工作能够继续。在kazoo中，暂没发现有方法能够直接使孩子watch Election的状态，暂未试验是否可以直接使用watch接口直接watch electionpath。不过即使不能通过watch electionpath解决，也可以在master切换之后，通过直接去修改另外一个固定位置的结点而工作单元都watch那个结点来解决。
资源定位主要是用于分布式系统中一些服务节点位置或者状态发生变化时，通知一些相关的需要知道的服务节点发生了这些变化，以便于其能够做出一定的响应。比如，一个rpc_server发生了故障迁移，这时就需要client重新能够发现并向新的地址、端口发起请求。</p>

<p>共享锁
实现起来和集群选主基本一致，都是创建一个自动编号的临时结点，然后watch父结点，判断自己是否是最小编号节点。
在kazoo中提供了 lock 相关封装：</p>

<p>import os
import sys
import time
from kazoo.client import KazooClient
zk = KazooClient(hosts=’127.0.0.1:2181’)
zk.start(10)
lock = zk.Lock(“/lockpath”, “my-identifier”)
with lock:
    print “got lock”
    time.sleep(10)
快速的运行两遍这个程序，会发现第二次运行的程序会等到第一次运行结束之后才会输出“got lock”.</p>

<p>队列管理
…</p>

<p>一些基本用法
关于Watch:
前面讲集群资源定位时提到了watch，zk原生的watch都是通过get/get_children/exists等查询接口提供的，用户在查询的时候可以再设置一个watch函数，当有关心的事件触发时，watch函数会被调用。
例如，get方法中设置的watch函数会在数据发生更新或者删除时被触发。exists在节点的存活性发生变化时触发，而get_children则在子节点的存活性发生变化时触发。
另外，当watch函数触发后，用户需要重新重新设置watch函数，不然随后的事件再次发生时，将不会被触发。
仔细思考上述接口会发现，当一次watch事件触发之后，到再次设置watch函数之间，如果发生了watch的事件，这个事件是不会被触发的。
虽然表面上这个接口会导致部分watch的事件丢失，但实际上由于设置watch和get/get_children/exists是同一个原子性的操作，故丢失的事件不会影响zookeeper上的数据与client端得到的数据的最终一致性。
使用kazoo的DataWatch可以简化watch的使用，但有时候可能还是需要去猜测其watch的实现，并不如想象中那么好用。
个人认为，好多时候，我们其实并不真正的需要watch，轮询可能会使代码更为清晰，更少出错</p>

</section>



<section class="meta">
  <br/>
  <br/>
<span class="sub_pagination">
  
    <a class="sub_pagination-item newer" href="/2017/01/01/">上一篇&nbsp  鸡血激励站 <i class="fa fa-chain"></i></a>
  
  
    <a class="sub_pagination-item newer" href="/2016/11/1/">下一篇 &nbsp redis集群的应用 <i class="fa fa-share"></i></a>
  
  </span>
  <br/>
  <br/>
</section>
<!--<span class="author">
  <a href="http://blog.sevenche.com">andihappy</a> - 程序员，企业管理与互联网结合应用的爱好者，现就职于北京。
</span>
<br /> 
</br>
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="/categories/#Zookeeper" title="Zookeeper">Zookeeper</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="/tags/#Zookeeper" title="Zookeeper">Zookeeper</a>&nbsp;
  
</span>

<span class="time">
  <br/>
  <time datetime="2016-12-02">2016-12-02</time>
</span>
!-->



<section  class="comment">
<!-- baidu JIA -->
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//https-andihappy-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://andihappy.github.io//2016/11/1/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://andihappy.github.io//2017/01/01/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})

</script>

<style type="text/css">
/*resize the big pic*/
div.resized_image p {
  margin: 2px;
  margin-top: 0;
  font-size: 8px;
  /* Awesome icon from here: http://www.famfamfam.com/lab/icons/silk/ */
  background: url(http://i242.photobucket.com/albums/ff244/9861_omikron/error.png) no-repeat;
  padding-left: 20px;
  color: #333;
}
</style>
<script type="text/javascript">
//resize the big pic
$(window).load(function() {
  (
    function(maxht, maxwt, minht, minwt) {
      var imgs = document.getElementsByTagName('img');
      // Image resizing function
      var resize_image = function(img, newht, newwt) {
        img.height = newht;
        img.width  = newwt;
        $(img).wrap('<table><tr><td class="tborder"><div class="resized_image"><a href="' + img.src + '" target="_blank"></a></div></td></tr></table>');
        $(img).parent().before('<p>NOTE: This image was resized. To view it full-size, click on the image.</p>');
        //$(img).parent().after('<p style="text-align:right;background:none;margin:0;padding-right:3px">Image resizing script by <a href="http://aetus.net/217/programming/automatically-resize-large-images-with-javascript/">Aetus Designs</a>.</p>');
      };
      
      for (var i = 0; i < imgs.length; i++) {
        // Set a variable for the current image to make the code make more sense.
        var img = imgs[i];
        if (img.height > maxht || img.width > maxwt) {
          // Use Ratios to constraint proportions.
          var old_ratio = img.height / img.width;
          var min_ratio = minht / minwt;
          // If it can scale perfectly.
          if (old_ratio === min_ratio) {
            resize_image(img, minht, minwt);
          } 
          // We need to do some magic now.
          else {
            var newdim = [img.height, img.width];
            // Sort out the height first.
            newdim[0] = minht;
            // The logic behind this is that if ratio = ht / wt, then wt = ht / ratio.
            newdim[1] = newdim[0] / old_ratio;
            // Do we still have to sort out the width?
            if (newdim[1] > maxwt) {
              // Just do what we did with the height
              newdim[1] = minwt;
              newdim[0] = newdim[1] * old_ratio;
            }
            // So yeah, resize the image
            resize_image(img, newdim[0], newdim[1]);
          }
        }
      }
    }
  )(780, 780, 780, 780);
});
</script>
        </article>
      </div>

    <footer>
        <p><small>Free hosted at <a href="https://github.com/andihappy">Github</a> | Copyright 2014 - 2017
		<!-- *** Please Keep bellow link for at least 6 months! Thanks！*** -->
		<a href="https://andihappy.github.io/">Template Maintained by flyBread</a>

		| <span class="label label-info">2017-01-15 17:19:00 CST</span></small></p>
    </footer>

    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'Coder-zhailzh@126.com', 'flyBread.github.io');
  ga('send', 'pageview');

</script>
  </body>
</html>
