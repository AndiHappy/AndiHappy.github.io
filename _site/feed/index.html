<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>andihappy</title>
    <link href="http://andihappy.github.io//feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2017-01-12T21:38:52+08:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>鸡血激励站</title>
      <link href="http://andihappy.github.io//2017/01/01/"/>
      <pubDate>2017-01-12T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2017/01/01</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>1,只要你每天持续工作十五个小时，不消一周，你就能用肉眼观察到困难离去的背影</p>
</blockquote>

<blockquote>
  <p>2,你只有多学一样本事才可能少说一句求人的话。</p>
</blockquote>

<blockquote>
  <p>3,我本在一个相似的问题回答过，是一句摘抄，回答是：新闻有条微博说7成网友赞成数学退出高考，下边一片叫好声。我有个朋友淡淡回了句：“数学就是用来把这7成人筛出去的。”这句话我永远都记得，所有被千夫所指的困难，都是为了淘汰掉懦夫，仅此而已。
在我看来，这句话影响了我接下来的努力和成果，考公成功，起码目前像是往更好的方向走去。人年轻的时候一定要打拼，将来的你一定会感谢现在拼命的你，我想起了一句话，也就是这个问题的回答：
“命是弱者的借口，运是强者的谦辞。”</p>
</blockquote>

<p>2013年，乌鲁木齐的一家西餐厅搞了一个活动。</p>

<p>简单地说，就是在每周一的中午12点过后，西餐厅的公众号发出来消息，你在收到消息的第一时间回过去『一元秒杀』四个字。</p>

<p>前十名发出去的用户可以获得一套300元的套餐。</p>

<p>我知道这个活动的时候，乌鲁木齐参与的人还不多，于是，那次活动，我中了。</p>

<p>话说这种餐厅档次对于在上海工作的我来说，经常会去吃，张江的传奇广场有很多类似的店，消费跟鹿港之类的一个级别。</p>

<p>但这种东西在50后的父母眼中，即使他们舍得下饭馆，也不会吃西餐的。原因大家都懂。</p>

<p>那天打了电话给女朋友，告诉她嘱咐家里，今晚请老爸老妈西餐。</p>

<p>老妈当然不肯，家里回过来电话跟我说”你跟月月（我女朋友）去吃就好，要把姑娘照顾好。”</p>

<p>我说：”是我中奖，300块钱的东西，我们俩人吃不完的，咱四个一起去，一顿饭是1块钱。”</p>

<p>然后父母就兴高采烈的一起去了。</p>

<p>嗯，一桌价值300块钱的饭。加上大众点评给好评送鸡柳，发朋友圈送咖啡。反正一大桌子菜，即使是4个人还算富裕。</p>

<p>老妈那一晚吃了一大块牛排，一大碗意面，若干小吃的东西。确实很撑很撑。</p>

<p>吃完饭，一家人红光满面的坐着聊天。</p>

<p>大家都很饱了，老爸点了一根烟，几个人休息，我准备去结账，这时候餐厅上了最后一道菜：一个价值68的冰激凌。</p>

<p>嗯，就是那种意大利冰激凌，很大很大的。放在一个杯子里。</p>

<p>大家都吃不下了，我看了一眼说，那就别吃了，然后去吧台，准备结账走人。</p>

<p>我结账回来的时候，看见我老妈一个人吃掉了那个本来应该几个人吃的巨大的冰激凌。她有些心疼的说：”你们怎么都不吃啊，这样太浪费了。”</p>

<p>我过去抢过杯子，我说妈；你这样会吃坏肚子的。</p>

<p>你们无法理会当看见自己老妈抱着那么大一个冰激凌吃。</p>

<p>不是因为爱吃，也不是因为好吃，只是因为觉得我们不吃了太浪费。</p>

<p>她举着那个杯子，那个有点贪到了小便宜的幸福表情，与那高档的西餐厅昏暗柔和的灯光很违和的反差在一起，我的心疼和心酸。</p>

<p>2.
我来告诉你，什么叫贫贱夫妻百事哀。</p>

<p>大学毕业后，你爱上了一个姑娘。这姑娘冰雪聪明，活泼善良，笑起来的时候就像一朵盛开的水仙花，跟个小天使一般在你的心头盘旋。</p>

<p>在你心里是刘亦菲一样的存在，符合你对于结婚的所有期望，你追她，恨不得把自己的心掏出来给她。</p>

<p>终于，那一夜姑娘一脸娇羞的跟你说；我们先处着看看。</p>

<p>你高兴坏了。</p>

<p>姑娘做普通的工作，有一个闺蜜，老公爆有钱，名车就不说了，姑娘驴牌的包包每周一换，各种节日各种派，连清明节都可以收到花，出去吃饭开红酒永远要最贵的。他俩同一个科室，每天吃一起住一起，你能感受到那种姑娘的落寞吗？</p>

<p>嗯，你喜欢的姑娘，手机坏了。你带她去步行街逛，你们进了apple
store，试了下6s，拍照确实鲜艳有趣。你也看出来姑娘很喜欢。可是后来你俩出来，最终走进旁边的小米专卖店。</p>

<p>嗯，我知道你想说真正爱你的人不在乎这个，她也不怪你，可是说真的，都是20郎当岁的小姑娘，哪个姑娘没有点小小的虚荣心？</p>

<p>你到底有没有在你的青春年华，尽心尽力的爱过一个姑娘。</p>

<p>3.
你虽然穷，但姑娘很善良，你对她好，她很感动，两个人在一起了。半年之后，去见姑娘的父母。</p>

<p>姑娘千叮咛万嘱咐，于是你提前洗澡刮胡子做面膜熨西装打领带皮鞋擦的锃亮。一脸紧张的按响了他们家的门铃。</p>

<p>女朋友家很懂礼数，准丈母娘在厨房里忙活了一下午，做了几个菜，一边吃一边聊，你在席间跟女朋友对视，她一脸欣喜的赞许你的眼神，你有点得意洋洋，以为大功告成。</p>

<p>突然，丈母娘半开玩笑半认真的说：你们俩的事情，本来我是不同意的。隔壁那个老王的儿子，公务员，对我家姑娘可好了，但是你对我家姑娘好，她也很爱你，我们都是看在心里的，我们不是不通情理的人，也没有什么别的要求，必须要买房子，哪怕你付个首付，你们俩一起按揭的也可以。房子写你俩名字，其他的，我和她爸爸不反对，家电装修，我和她爸爸想办法。</p>

<p>你是愿意写名字的，即使只写她一个人得名字也好，可是，你掏不起钱。</p>

<p>你说：阿姨，我们现在努力，我一定可以的。请你相信。</p>

<p>丈母娘脸色大变，将你送出门。</p>

<p>之后这姑娘两周电话不接微信不回，两周后你约她出来，在楼下的街心花园，你望着她，觉得这两周过得时间超过两年。她一脸冰霜，任凭你恨不得不要七尺男儿的脸面，跪下来求他，她只是说对不起。哭着跑开。</p>

<p>两个月后，你接到她的微信，”我下月结婚。关于过去的点点记忆，我都记得，谢谢你。”</p>

<p>你祝福她，删了她，从此你夜夜买醉，你愤愤不平的说，这个社会就是这么不公平。</p>

<p>4.
好吧，上面这个故事残忍了点。</p>

<p>丈母娘答应了你，你俩欢天喜地，两人借钱，买房，按揭，结婚。一切从简。姑娘很懂事，她不要钻戒不要名表，房子简装修，家电慢慢买，日子过得也算不错。一年后，小生命降临，幸福甜蜜。</p>

<p>别急，故事没完。</p>

<p>突然有一天，电视台播放：三鹿发生三聚氰胺事件，质监局检查了全国奶粉，全军覆没。</p>

<p>一夜间，所有的爸爸妈妈开始代购进口奶粉。</p>

<p>老婆跟你商量，再穷不能穷孩子，咱俩省吃俭用，孩子一定要吃好。</p>

<p>嗯，于是你们继续节约，孩子喝进口奶粉，用进口尿不湿。</p>

<p>上了幼儿园。</p>

<p>你的女儿很聪明，在幼儿园画画获了奖。</p>

<p>幼儿园选10个小朋友，去日本跟日本小朋友交换，老师找到你，你孩子真的好棒，是我们学校的一个好榜样，这也是孩子开拓眼界的机会。</p>

<p>嗯，去趟日本吧，十天，6700块钱，可以有一个家长陪同。</p>

<p>很多家长都想去，可是孩子成绩不够。</p>

<p>你孩子好争气啊你知道吗？可是你TMD掏不起钱。</p>

<p>5.
我们不聊爱情，我们聊聊亲情。</p>

<p>总有一天，我们在这个世界上最爱的母亲老去，进了医院，得了癌症。</p>

<p>是的，这个病，目前无解。横竖都是死。</p>

<p>医生说已经晚期了不能手术，医生建议化疗。</p>

<p>肺癌的治疗方法中有很多种，化疗药物中有一种叫”贝伐珠单抗”进口药物，2w+一针，不医保，副作用小，不掉头发，化疗后不呕吐，病人精神。</p>

<p>普通国产化疗药，一针一千多，可以走医保，吃了呕吐，头发掉光。病人被折磨的生不如死。</p>

<p>嗯，你是善良的人，你只是穷。</p>

<p>半年后病情进展，化疗没用了，于是医生又给你两套方案。</p>

<p>没钱的人保守治疗吃中药，疼到死。</p>

<p>有钱的人吃国外的靶向药物治疗，易瑞沙和特罗凯，一天一片，每天1000，不医保。全部自费。</p>

<p>效果真的有，吃了以后，病人躺在床上能跟你聊天，也不会再昏迷。</p>

<p>呵呵，这是你最亲最亲的人，你怎么选。</p>

<p>你不努力，用什么资格选？</p>

<p>6.
很多人都说，早出晚归是为了未来，为了明天，balabala。</p>

<p>我现在觉得，活着是为了过好当下。</p>

<p>钱在这个社会真的不是万能的东西。</p>

<p>比钱重要的东西多了。</p>

<p>可是我们为什么起早贪黑呢？</p>

<p>我们奋斗就是为了，我们的父母有一天，买一件自己喜欢的大衣的时候不要抠自己。</p>

<p>万一有天遇到癌症这样不能挽回的病，死的能够舒服一点。</p>

<p>我们奋斗，也并不是姑娘不能跟我们分手。</p>

<p>但姑娘跟我们分手，可以因为我们性格不合，价值观不一样，可以因为各种各样的原因。</p>

<p>但不是因为我缺钱！</p>

<p>看了太多相爱但因为钱而分开的例子。</p>

<p>但愿这样的悲剧，不要在我自己身上发生。</p>

<p>7.
为了那个每天给你做饭两鬓斑白的老人。</p>

<p>为了那个抱怨着把你的脏衣服扔进洗衣机的姑娘。</p>

<p>为了女儿喝完牛奶离开家前亲你一口说爸爸再见。</p>

<p>这家里的一切，就是你奋斗的理由。</p>

<p>狗屁的承诺，狗屁的我爱你啊，等以后我有钱了就给你XXX，你这话骗得了姑娘骗不了你自己。</p>

<p>多少爱情就这样没有了以后。</p>

<p>珍惜当下啊。认真的去爱每一个人。</p>

<p>我们早出晚归，要的就是你出去玩的时候，别人吃59的自助餐，你可以买199的贵宾票。</p>

<p>要的就是女朋友在跟你说老公这个手机拍照好漂亮的时候，你也能笑着说服务员刷卡。而不是牵着她的手离开。</p>

<p>你看着那些在姑娘面前刷卡的人，生活可能其实一点都没有你容易。他们只是知道为自己所爱的人付出，其实是一种幸福感觉。</p>

<p>其实想想，就觉得一点都不苦。</p>

<p>8.
生活是公平的。</p>

<p>你选择了清闲，就肯定是有一个人替你担负了你的重担。</p>

<p>有些事情，你做了，不一定能成功。</p>

<p>但你不做，就一定会是失败的。</p>

<p>而你早出晚归，就是为了你女儿你妻子你的父母可以睡到自然醒。</p>

<p>生活向来是一场颠沛流离的旅行。</p>

<p>众生皆苦，万相本无。</p>

<p>这一路实在苦短，越是憧憬，越要风雨兼程。</p>

<p>对得起那些跟你选择一条船，陪你旅行的人。</p>

<p>最后，女神朱莉的纹身：
敢想不敢为者，终困身牢笼。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>zookeeper的认知(一)</title>
      <link href="http://andihappy.github.io//2016/12/1/"/>
      <pubDate>2016-12-02T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/12/1</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>1.zookeeper的基本的认识</p>

</blockquote>

<h3 id="zookeeper">1.zookeeper的基本的认识</h3>

<p>ZooKeeper is a distributed, open-source coordination service for distributed applications. It exposes a simple set of primitives that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming.</p>

<p>zookeeper作为一个开源的分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>

<p>Design Goals
ZooKeeper is simple. ZooKeeper allows distributed processes to coordinate with each other through a shared hierarchal namespace which is organized similarly to a standard file system. The name space consists of data registers - called znodes, in ZooKeeper parlance - and these are similar to files and directories. Unlike a typical file system, which is designed for storage, ZooKeeper data is kept in-memory, which means ZooKeeper can achieve high throughput and low latency numbers.</p>

<p>zookeeper允许分布式系统通过操作一个共享的具有层级结构的命名空间，这个空间的组织形式类似标准的文件系统，来相互的协调。这个有数据节点，在Zookeeper中称为znodes，组成的命名空间非常的类似文件和文件夹的概念。与为存储设计的典型文件系统不同，ZooKeeper中的数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟</p>

<p>The ZooKeeper implementation puts a premium on high performance, highly available, strictly ordered access. The performance aspects of ZooKeeper means it can be used in large, distributed systems. The reliability aspects keep it from being a single point of failure. The strict ordering means that sophisticated synchronization primitives can be implemented at the client.</p>

<p>ZooKeeper实现了高性能，高可用性，严格的排序访问。ZooKeeper的实现的这些性能方面保证它可以在大型分布式系统中使用。可靠性防止它成为单点故障。严格排序访问意味着复杂的同步原语可以在客户端实现。</p>

<p>ZooKeeper is replicated（可复制的）. Like the distributed processes it coordinates, ZooKeeper itself is intended to be replicated over a sets of hosts called an ensemble.</p>

<p><img src="http://7xtrwx.com1.z0.glb.clouddn.com/3b3ae8f43c9d1a02a1789b2a4e26a99f.png" alt="zookper的架构" /></p>

<p>The servers that make up the ZooKeeper service must all know about each other. They maintain an in-memory image of state, <strong>along with a transaction logs and snapshots in a persistent store</strong>. As long as a majority of the servers are available, the ZooKeeper service will be available.</p>

<p>组成zk服务的机子能够互相的感知到对方，</p>

<p>Clients connect to a single ZooKeeper server. The client maintains a TCP connection through which it sends requests, gets responses, gets watch events, and sends heart beats. If the TCP connection to the server breaks, the client will connect to a different server.</p>

<p>ZooKeeper is ordered. ZooKeeper stamps each update with a number that reflects the order of all ZooKeeper transactions. Subsequent operations can use the order to implement higher-level abstractions, such as synchronization primitives.</p>

<p>ZooKeeper is fast. It is especially fast in “read-dominant” workloads. ZooKeeper applications run on thousands of machines, and it performs best where reads are more common than writes, at ratios of around 10:1.</p>

<h4 id="section">数据结构和层次结构</h4>
<p>Data model and the hierarchical namespace
The name space provided by ZooKeeper is much like that of a standard file system. A name is a sequence of path elements separated by a slash (/). Every node in ZooKeeper’s name space is identified by a path.</p>

<p><img src="http://7xtrwx.com1.z0.glb.clouddn.com/079c0df3293602c0ff09f604d9dfcd1b.png" alt="zk的数据结构" />
zk中的节点的组织的形式，很像文件的路径。</p>

<h4 id="nodes-and-ephemeral-nodes">Nodes and ephemeral nodes</h4>
<p>Unlike standard file systems, each node in a ZooKeeper namespace can have data associated with it as well as children. It is like having a file-system that allows a file to also be a directory. (ZooKeeper was designed to store coordination data: status information, configuration, location information, etc., so the data stored at each node is usually small, in the byte to kilobyte range.) We use the term znode to make it clear that we are talking about ZooKeeper data nodes.</p>

<p>zk节点本身有对应的节点值，也可以拥有孩子节点。</p>

<p>Znodes maintain a stat structure that includes version numbers for data changes, ACL changes, and timestamps, to allow cache validations and coordinated updates. Each time a znode’s data changes, the version number increases. For instance, whenever a client retrieves data it also receives the version of the data.</p>

<p>zk为维护包括数据变化的版本号，ACL的变化，时间戳等数据组成的一个快照类型的数据结构。</p>

<p>The data stored at each znode in a namespace is read and written atomically. Reads get all the data bytes associated with a znode and a write replaces all the data. Each node has an Access Control List (ACL) that restricts who can do what.</p>

<p>zk中的每一个节点都会有一个访问控制列表。</p>

<p>ZooKeeper also has the notion of ephemeral nodes. These znodes exists as long as the session that created the znode is active. When the session ends the znode is deleted. Ephemeral nodes are useful when you want to implement [tbd].</p>

<p>Conditional updates and watches
ZooKeeper supports the concept of watches. Clients can set a watch on a znode. A watch will be triggered and removed when the znode changes. When a watch is triggered, the client receives a packet saying that the znode has changed. If the connection between the client and one of the Zoo Keeper servers is broken, the client will receive a local notification. These can be used to [tbd].</p>

<p>Guarantees
ZooKeeper is very fast and very simple. Since its goal, though, is to be a basis for the construction of more complicated services, such as synchronization, it provides a set of guarantees. These are:</p>

<p>Sequential Consistency - Updates from a client will be applied in the order that they were sent.
Atomicity - Updates either succeed or fail. No partial results.
Single System Image - A client will see the same view of the service regardless of the server that it connects to.
Reliability - Once an update has been applied, it will persist from that time forward until a client overwrites the update.
Timeliness - The clients view of the system is guaranteed to be up-to-date within a certain time bound.
For more information on these, and how they can be used, see [tbd]</p>

<p>Simple API
One of the design goals of ZooKeeper is provide a very simple programming interface. As a result, it supports only these operations:</p>

<p>create
creates a node at a location in the tree</p>

<p>delete
deletes a node</p>

<p>exists
tests if a node exists at a location</p>

<p>get data
reads the data from a node</p>

<p>set data
writes data to a node</p>

<p>get children
retrieves a list of children of a node</p>

<p>sync
waits for data to be propagated</p>

<p>For a more in-depth discussion on these, and how they can be used to implement higher level operations, please refer to [tbd]</p>

<p>Implementation
ZooKeeper Components shows the high-level components of the ZooKeeper service. With the exception of the request processor, each of the servers that make up the ZooKeeper service replicates its own copy of each of the components.</p>

<p>这里不再具体提zk的选主逻辑，paxos协议什么的，只开始讲一些用法。
kazoo是一个封装了zookeeper操作的python库，其中除了提供底层的zookeeper接口外，还提供了一些更高级别的封装。</p>

<p>zookeeper的基本操作
zookeeper主要操作分以下几种：
创建节点
读节点数据
更新节点数据
删除节点
监控节点变化
其中节点被组织成目录树的形式，每个节点下面都可以有一些子节点。
节点可以是以下四种类型：
PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；
PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；
EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；
EPHEMERAL_SEQUENTIAL：临时自动编号节点。
监控节点变化时，可以监控一个节点的变化，也可以监控一个节点所有子节点的变化。</p>

<p>ZK应用
统一命名服务
在分布式系统中，经常需要给一个资源生成一个唯一的ID，在没有中心管理结点的情况下生成这个ID并不是一件很容易的事儿。zk就提供了这样一个命名服务。
一般是使用create方法，创建一个自动编号的节点。</p>

<p>配置管理
主要用于多个结点共享配置，并且在配置发生更新时，利用zk可以让这些使用了这些配置的结点获得通知，进行重新加载等操作。</p>

<p>集群管理
主要有两个方面：一是集群选主，二是资源定位。
集群选主是当一个集群会启动一主一备两个服务单元时，可以使用zk来选出一个主服务单元。 具体方法就是在一个节点下创建一个自动编号的临时结点，然后watch父节点，如果该临时节点成为父节点下编号最小的节点，则认为其成为了主服务单元。
在kazoo中，提供了 election 相关的封装，使用极其简单。</p>

<p>zk = KazooClient(hosts=’127.0.0.1:2181’)
zk.start(10)</p>

<p>election = zk.Election(“/electionpath”, “my-identifier”)</p>

<h1 id="blocks-until-the-election-is-won-then-calls">blocks until the election is won, then calls</h1>
<p># my_leader_function()
election.run(my_leader_function)
在实际使用时有时候会遇到一些工作单元watch集群的master结点，当主从切换时，工作单元可能会需要重新连接到新的主节点以使工作能够继续。在kazoo中，暂没发现有方法能够直接使孩子watch Election的状态，暂未试验是否可以直接使用watch接口直接watch electionpath。不过即使不能通过watch electionpath解决，也可以在master切换之后，通过直接去修改另外一个固定位置的结点而工作单元都watch那个结点来解决。
资源定位主要是用于分布式系统中一些服务节点位置或者状态发生变化时，通知一些相关的需要知道的服务节点发生了这些变化，以便于其能够做出一定的响应。比如，一个rpc_server发生了故障迁移，这时就需要client重新能够发现并向新的地址、端口发起请求。</p>

<p>共享锁
实现起来和集群选主基本一致，都是创建一个自动编号的临时结点，然后watch父结点，判断自己是否是最小编号节点。
在kazoo中提供了 lock 相关封装：</p>

<p>import os
import sys
import time
from kazoo.client import KazooClient
zk = KazooClient(hosts=’127.0.0.1:2181’)
zk.start(10)
lock = zk.Lock(“/lockpath”, “my-identifier”)
with lock:
    print “got lock”
    time.sleep(10)
快速的运行两遍这个程序，会发现第二次运行的程序会等到第一次运行结束之后才会输出“got lock”.</p>

<p>队列管理
…</p>

<p>一些基本用法
关于Watch:
前面讲集群资源定位时提到了watch，zk原生的watch都是通过get/get_children/exists等查询接口提供的，用户在查询的时候可以再设置一个watch函数，当有关心的事件触发时，watch函数会被调用。
例如，get方法中设置的watch函数会在数据发生更新或者删除时被触发。exists在节点的存活性发生变化时触发，而get_children则在子节点的存活性发生变化时触发。
另外，当watch函数触发后，用户需要重新重新设置watch函数，不然随后的事件再次发生时，将不会被触发。
仔细思考上述接口会发现，当一次watch事件触发之后，到再次设置watch函数之间，如果发生了watch的事件，这个事件是不会被触发的。
虽然表面上这个接口会导致部分watch的事件丢失，但实际上由于设置watch和get/get_children/exists是同一个原子性的操作，故丢失的事件不会影响zookeeper上的数据与client端得到的数据的最终一致性。
使用kazoo的DataWatch可以简化watch的使用，但有时候可能还是需要去猜测其watch的实现，并不如想象中那么好用。
个人认为，好多时候，我们其实并不真正的需要watch，轮询可能会使代码更为清晰，更少出错</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis集群的应用</title>
      <link href="http://andihappy.github.io//2016/11/1/"/>
      <pubDate>2016-11-30T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/11/1</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>1, Redis Sharding集群原理，使用的条件，优劣点以及对应的解决方案   <br />
2, Redis官方集群方案 Redis Cluster介绍<br />
3,中间件的方式实现Redis集群 <br />
4,选择</p>
</blockquote>

<h2 id="redis-">redis 集群的解决的方案和原理分析</h2>

<h3 id="redis-sharding">1, Redis Sharding集群</h3>

<p>Redis Sharding采用客户端Sharding方式，服务端Redis还是一个个相对独立的Redis实例节点，没有做任何变动。理解就是客户端的连接的特定的服务器，但是在增加节点或者删除节点的时候，有一定的兼容的算法，使得原来打在某一个redis实例，还打在这个实例上面。</p>

<p>主要的思想就是根据一定的算法，例如 哈希算法，对Redis的key值进行散列，然后将key值散列到<strong>特定</strong>Redis实例上面。以后的设置，获取等关于该key值的操作，都会打到这个特定的redis实例上面进行操作。</p>

<p>值得庆幸的是，java redis的客户端驱动jedis，已经支持 Redis Sharding 功能。即是ShardedJedis以及结合缓存池ShardedJedisPool。</p>

<p>Jedis的Redis Sharding实现具有如下特点：</p>

<blockquote>
  <p>1.采用一致性哈希算法(consistent hashing)，将key和节点name同时hashing，然后进行映射匹配，采用的算法是MURMUR_HASH。采用一致性哈希而不是采用简单类似哈希求模映射的主要原因是当增加或减少节点时，不会产生由于重新匹配造成的rehashing。<strong>一致性哈希只影响相邻节点key分配，影响量小。</strong><br /> 即是：ShardedJedis 在操作的时候，都会调用的getShard方法，来获得key对应的redis实例：</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>  <span class="kd">public</span> <span class="n">R</span> <span class="nf">getShard</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">resources</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getShardInfo</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="n">S</span> <span class="n">getShardInfo</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getShardInfo</span><span class="o">(</span><span class="n">SafeEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">getKeyTag</span><span class="o">(</span><span class="n">key</span><span class="o">)));</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">getKeyTag</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 默认的情况下，tagPattern是NULL</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tagPattern</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tagPattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">encode</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="n">Protocol</span><span class="o">.</span><span class="na">CHARSET</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="n">S</span> <span class="n">getShardInfo</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// 最关键的treeMap的数据结构</span>
    <span class="n">SortedMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">tailMap</span><span class="o">(</span><span class="n">algo</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">firstKey</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">tail</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">firstKey</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="c1">//nodes 是ShardedJedisPool 初始化的时候，hash Redis的实例的配置信息后组成的TreeMap，声明是：   </span>

  <span class="kd">private</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="o">;</span><span class="c1">//S extends ShardInfo&lt;R&gt;</span>
</code></pre>
</div>

<blockquote>
  <p>2.为了避免一致性哈希只影响相邻节点造成节点分配压力，ShardedJedis会对每个Redis节点根据名字(没有，Jedis会赋予缺省名字)会虚拟化出160个虚拟节点进行散列。根据权重weight，也可虚拟化出160倍数的虚拟节点。用虚拟节点做映射匹配，可以在增加或减少Redis节点时，key在各Redis节点移动再分配更均匀，而不是只有相邻节点受影响。</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">shards</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">shards</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="n">S</span> <span class="n">shardInfo</span> <span class="o">=</span> <span class="n">shards</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">shardInfo</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">160</span> <span class="o">*</span> <span class="n">shardInfo</span><span class="o">.</span><span class="na">getWeight</span><span class="o">();</span> <span class="n">n</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">nodes</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">algo</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="s">"SHARD-"</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">"-NODE-"</span> <span class="o">+</span> <span class="n">n</span><span class="o">),</span> <span class="n">shardInfo</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="k">else</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">160</span> <span class="o">*</span> <span class="n">shardInfo</span><span class="o">.</span><span class="na">getWeight</span><span class="o">();</span> <span class="n">n</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">nodes</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">algo</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">shardInfo</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"*"</span> <span class="o">+</span> <span class="n">shardInfo</span><span class="o">.</span><span class="na">getWeight</span><span class="o">()</span> <span class="o">+</span> <span class="n">n</span><span class="o">),</span>
              <span class="n">shardInfo</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="n">resources</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">shardInfo</span><span class="o">,</span> <span class="n">shardInfo</span><span class="o">.</span><span class="na">createResource</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre>
</div>

<blockquote>
  <p>3.ShardedJedis支持keyTagPattern模式，即抽取key的一部分keyTag做sharding，这样通过合理命名key，可以将一组相关联的key放入同一个Redis节点，这在避免跨节点访问相关数据时很重要。（默认的情况下为NULL）</p>
</blockquote>

<p>KeyTag这个可以在初始化ShardedJedisPool 设置。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">ShardedJedisPool</span><span class="p">(</span><span class="kd">final</span> <span class="n">GenericObjectPoolConfig</span> <span class="n">poolConfig</span><span class="o">,</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">JedisShardInfo</span><span class="o">&gt;</span> <span class="n">shards</span><span class="o">,</span> <span class="n">Pattern</span> <span class="n">keyTagPattern</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">poolConfig</span><span class="o">,</span> <span class="n">shards</span><span class="o">,</span> <span class="n">Hashing</span><span class="o">.</span><span class="na">MURMUR_HASH</span><span class="o">,</span> <span class="n">keyTagPattern</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>当然，Redis Sharding这种轻量灵活方式必然在集群其它能力方面做出妥协，但是针对每一种不好的地方，我们又都准备了不同的解决方案。</p>

<blockquote>
  <p>1 扩容，当想要增加Redis节点时，尽管采用一致性哈希，毕竟还是会有key匹配不到而丢失，这时需要键值迁移</p>
</blockquote>

<p>这就要求：应用层面允许Redis中数据丢失或从后端数据库重新加载数据。但有些时候，击穿缓存层，直接访问数据库层，会对系统访问造成很大压力。</p>

<blockquote>
  <p>2 轻量级客户端sharding，处理Redis键值迁移比较的麻烦。</p>
</blockquote>

<p>Redis作者给出了一个比较讨巧的办法–presharding，即预先根据系统规模尽量部署好多个Redis实例，这些实例占用系统资源很小，一台物理机可部署多个，让他们都参与sharding，当需要扩容时，选中一个实例作为主节点，新加入的Redis节点作为从节点进行数据复制。数据同步后，修改sharding配置，让指向原实例的Shard指向新机器上扩容后的Redis节点，同时调整新Redis节点为主节点，原实例可不再使用。</p>

<blockquote>
  <p>3 应从redis宕机的风险</p>
</blockquote>

<p>为不影响Redis性能，尽量不开启AOF和RDB文件保存功能，可采用Redis主备模式，主Redis宕机，数据不会丢失，因为备Redis留有备份。这样，架构模式变成一个Redis节点切片包含一个主Redis和一个备Redis。在主Redis宕机时，备Redis接管过来，上升为主Redis，继续提供服务。主备共同组成一个Redis节点，通过自动故障转移，保证了节点的高可用性。</p>

<p>可以利用主从模式实现读写分离，主负责写，从负责只读，同时一主挂多个从。在Sentinel监控下，还可以保障节点故障的自动监测。</p>

<h3 id="redis-redis-cluster">2, Redis官方集群方案 Redis Cluster</h3>

<p>Redis Cluster是一种服务器Sharding技术，3.0版本开始正式提供。</p>

<p>Redis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。</p>

<p>Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。
这个和我们搭建的集群的日志相吻合：</p>

<p><img src="http://7xtrwx.com1.z0.glb.clouddn.com/800a0cabd49d4149355b5384e12e0714.png" alt="Redis集群" /></p>

<p>当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。</p>

<p>为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。</p>

<p>Redis Cluster的新节点识别能力、故障判断及故障转移能力是通过集群中的每个node都在和其它nodes进行通信，这被称为<strong>集群总线(cluster bus)</strong>。它们使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。</p>

<p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。</p>

<h3 id="redis">3.利用代理中间件实现大规模Redis集群</h3>

<p>上面分别介绍了多Redis服务器集群的两种方式，它们是基于客户端sharding的Redis Sharding和基于服务端sharding的Redis Cluster。</p>

<p>客户端sharding技术其优势在于服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。其不足之处在于：</p>

<blockquote>
  <p>由于sharding处理放到客户端，规模进步扩大时给运维带来挑战。
服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。
连接不能共享，当应用规模增大时，资源浪费制约优化。</p>
</blockquote>

<p>服务端sharding的Redis Cluster其优势在于服务端Redis集群拓扑结构变化时，客户端不需要感知，客户端像使用单Redis服务器一样使用Redis集群，运维管理也比较方便。</p>

<p>不过Redis Cluster正式版推出时间不长，系统稳定性、性能等都需要时间检验，尤其在大规模使用场合。</p>

<p>能不能结合二者优势？即能使服务端各实例彼此独立，支持线性可伸缩，同时sharding又能集中处理，方便统一管理: Redis代理中间件twemproxy就是这样一种利用中间件做sharding的技术。</p>

<p>twemproxy处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后(如sharding)，再转发给后端真正的Redis服务器。也就是说，客户端不直接访问Redis服务器，而是通过twemproxy代理中间件间接访问。</p>

<p>twemproxy中间件的内部处理是无状态的，它本身可以很轻松地集群，这样可避免单点压力或故障。</p>

<p>twemproxy又叫nutcracker，起源于twitter系统中redis/memcached集群开发实践，运行效果良好，后代码奉献给开源社区。其轻量高效，采用C语言开发，工程网址是：GitHub - twitter/twemproxy: A fast, light-weight proxy for memcached and redis</p>

<p>twemproxy后端不仅支持redis，同时也支持memcached，这是twitter系统具体环境造成的。</p>

<p>由于使用了中间件，twemproxy可以通过共享与后端系统的连接，降低客户端直接连接后端服务器的连接数量。同时，它也提供sharding功能，支持后端服务器集群水平扩展。统一运维管理也带来了方便。</p>

<p>当然，也是由于使用了中间件代理，相比客户端直连服务器方式，性能上会有所损耗，实测结果大约降低了20%左右。</p>

<h3 id="section">那么，上面几种方案如何选择？</h3>

<p>显然在客户端做分片是自定义能力最高的，优势在于，在不需要客户端服务端协作，以及没有中间层的条件下，每个请求的 roundtrip 时间是相对更小的，<strong>搭配良好的客户端分片策略</strong>，可以让整个集群获得很好的扩展性。当然劣势也很明显，用户需要自己对付 Redis 节点宕机的情况，需要采用更复杂的策略来做 replica，以及需要保证每个客户端看到的集群“视图”是一致的。</p>

<p>中间件的方案对客户端实现的要求是最低的，客户端只要支持基本的 Redis 通信协议即可，至于扩容、多副本、主从切换等机制客户端都不必操心，因此这种方案也很适合用来做“缓存服务”。</p>

<p>官方推出的协作方案也完整地支持了分片和多副本，相对于各种 proxy，这种方案假设了客户端实现是可以与服务端“协作”的，事实上主流语言的 SDK 都已经支持了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>杂记</title>
      <link href="http://andihappy.github.io//2016/10/3/"/>
      <pubDate>2016-10-25T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/10/3</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>记录自己的一些的问题：</p>
</blockquote>

<blockquote>
  <ol>
    <li>git冲突的编写</li>
    <li>自己应该做什么？</li>
  </ol>
</blockquote>

<h1 id="git">git冲突后</h1>

<p>当两个改动发生在同一个文件的同一些行上，我们就要看看发生冲突的文件的内容了。Git 会非常友好地把文件中那些有问题的区域在 “«««&lt; HEAD” 和 “»»»&gt; [other/branch/name]” 之间标记出来</p>

<p><img src="http://7xtrwx.com1.z0.glb.clouddn.com/e3b73828d5fc3bdc8e6608b362536a48.png" alt="git冲突" /></p>

<p>第一个标记后的内容源于当前分支。在尖括号之后，Git 会告诉我们这些改动是从哪里（哪个分支）来的。然后有冲突的改动会被 “=======” 分割起来。</p>

<h1 id="mac-osx-">MAC OSX 的开发</h1>

<p>1，做出一个比较像样子的zk的配置工具，把</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link href="http://andihappy.github.io//2016/10/2/"/>
      <pubDate>2016-10-24T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/10/2</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>回溯算法的描述</p>
</blockquote>

<h1 id="section">回溯算法</h1>
<p>Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons each partial candidate c (“backtracks”) as soon as it determines that c cannot possibly be completed to a valid solution.[1][2]
针对一般的计算问题，特别是满足一定约束条件的问题，回溯算法是一个比较常见的解决方式，即是逐步的构建针对解决方案的候选方案，一旦确定候选方案不满足约束条件，不是一个解决方案时候立即的放弃。</p>

<p>The classic textbook example of the use of backtracking is the eight queens puzzle, that asks for all arrangements of eight chess queens on a standard chessboard so that no queen attacks any other. In the common backtracking approach, the partial candidates are arrangements of k queens in the first k rows of the board, all in different rows and columns. Any partial solution that contains two mutually attacking queens can be abandoned.
经典的回溯算法的案例就是八皇后问题，八皇后问题是在一个棋盘上面放置八个不能够互相攻击其他皇后的皇后，在经典的回溯算法中，候选的方案是K个皇后，棋盘的K行，包括皇后的位置处于所有的行和所有的列，任何一个两个皇后能够互相攻击的方案直接的舍弃。</p>

<p>Backtracking can be applied only for problems which admit the concept of a “partial candidate solution” and a relatively quick test of whether it can possibly be completed to a valid solution. It is useless, for example, for locating a given value in an unordered table. When it is applicable, however, backtracking is often much faster than brute force enumeration of all complete candidates, since it can eliminate a large number of candidates with a single test.
回溯算法适合拥有部分候选方案的问题，并且问题能够在相对比较短的时间内验证候选方案。对于无需表中确定一个确定值的位置这样的，回溯算法是不适合的。然而，相比较暴力破解的算法，回溯算法因为能够在一次的测试中放弃大量的候选的方案，所以还是比较快的。</p>

<p>Backtracking is an important tool for solving constraint satisfaction problems, such as crosswords, verbal arithmetic, Sudoku, and many other puzzles. It is often the most convenient (if not the most efficient[citation needed]) technique for parsing, for the knapsack problem and other combinatorial optimization problems. It is also the basis of the so-called logic programming languages such as Icon, Planner and Prolog.</p>

<p>对于满足约束条件的问题，例如填字游戏，语言运算，数独等类似的猜谜的问题，回溯是一个比较重要的工具。另外对于背包问题，组合优化，语法分析也是一个比较方便的工具。另外还是一些逻辑编程语言Icon, Planner and Prolog的基础</p>

<p>Backtracking depends on user-given “black box procedures” that define the problem to be solved, the nature of the partial candidates, and how they are extended into complete candidates. It is therefore a metaheuristic rather than a specific algorithm – although, unlike many other meta-heuristics, it is guaranteed to find all solutions to a finite problem in a bounded amount of time.
回溯取决于用户给定的“黑箱程序”，其定义了要解决的问题，部分候选的性质以及如何将其扩展为完整候选。因此，它是元启发式而不是特定的算法 - 尽管与许多其他元启发式算法不同，它保证在有限时间内找到有限问题的所有解。</p>

<p>Description of the method[]</p>

<p>The backtracking algorithm enumerates a set of partial candidates that, in principle, could be completed in various ways to give all the possible solutions to the given problem. The completion is done incrementally, by a sequence of candidate extension steps.
回溯算法枚举一组部分候选，原则上可以以各种方式给出给定问题的所有可能的解决方案。然后通过选定的步骤逐步地解决。</p>

<p>Conceptually, the partial candidates are represented as the nodes of a tree structure, the potential search tree. Each partial candidate is the parent of the candidates that differ from it by a single extension step; the leaves of the tree are the partial candidates that cannot be extended any further.
在概念上，部分候选方案被表示为树结构的节点，即潜在搜索树。每个部分候选是通过单个扩展步骤与其不同的候选的父代;树的叶是不能进一步扩展的部分候选方案。</p>

<p>The backtracking algorithm traverses this search tree recursively, from the root down, in depth-first order. At each node c, the algorithm checks whether c can be completed to a valid solution. If it cannot, the whole sub-tree rooted at c is skipped (pruned). Otherwise, the algorithm (1) checks whether c itself is a valid solution, and if so reports it to the user; and (2) recursively enumerates all sub-trees of c. The two tests and the children of each node are defined by user-given procedures.
回溯算法从根向下以深度优先顺序递归地遍历该搜索树。在每个节点c，算法检查c是否可以达到有效解条件。如果不能，则跳过（修剪）以c为根的整个子树。否则，算法（1）检查c本身是否是有效解，并且如果是，则将其报告给用户;和（2）递归地枚举c的所有子树。节点和每个节点的子节点的测试都是由用户给定的程序来校验。</p>

<p>Therefore, the actual search tree that is traversed by the algorithm is only a part of the potential tree. The total cost of the algorithm is the number of nodes of the actual tree times the cost of obtaining and processing each node. This fact should be considered when choosing the potential search tree and implementing the pruning test.</p>

<p>因此，回溯遍历的是潜在搜索树的一部分，但是总体的算法的花费是树的全部的节点乘以每一个节点的检查时间。这一点应该在实现算法的时候加以考虑。</p>

<p>Pseudocode</p>

<p>In order to apply backtracking to a specific class of problems, one must provide the data P for the particular instance of the problem that is to be solved, and six procedural parameters, root, reject, accept, first, next, and output. These procedures should take the instance data P as a parameter and should do the following:</p>

<ul>
  <li>[ ] root(P): return the partial candidate at the root of the search tree.</li>
  <li>[ ] reject(P,c): return true only if the partial candidate c is not worth completing.</li>
  <li>[ ] accept(P,c): return true if c is a solution of P, and false otherwise.</li>
  <li>[ ] first(P,c): generate the first extension of candidate c.</li>
  <li>[ ] next(P,s): generate the next alternative extension of a candidate, after the extension s.</li>
  <li>[ ] output(P,c): use the solution c of P, as appropriate to the application.</li>
</ul>

<p>The backtracking algorithm reduces the problem to the call bt(root(P)), where bt is the following recursive procedure:</p>

<p>procedure bt(c)
  if reject(P,c) then return
  if accept(P,c) then output(P,c)
  s ← first(P,c)
  while s ≠ Λ do
    bt(s)
    s ← next(P,s)</p>

<p>Usage considerations</p>

<p>The reject procedure should be a boolean-valued function that returns true only if it is certain that no possible extension of c is a valid solution for P. If the procedure cannot reach a definite conclusion, it should return false. An incorrect true result may cause the bt procedure to miss some valid solutions. The procedure may assume that reject(P,t) returned false for every ancestor t of c in the search tree.
reject是一个返回boolean值的方法，只有当c不可能是p的一个解的时候，才会返回true。如果这个方法不能够确定结论，就返回false。如果方法在不正确的情况，返回了true，就可能会错过某些正确的解。这个方法reject（p,t）搜索树t的根节点时候，可以假设返回false。</p>

<p>On the other hand, the efficiency of the backtracking algorithm depends on reject returning true for candidates that are as close to the root as possible. If reject always returns false, the algorithm will still find all solutions, but it will be equivalent to a brute-force search.
另外一方面，回溯算法的效率和reject返回true的时候，节点离根点的远近成比例。如果reject总是返回false，那么此时的回溯就相当于暴力算法。
The accept procedure should return true if c is a complete and valid solution for the problem instance P, and false otherwise. It may assume that the partial candidate c and all its ancestors in the tree have passed the reject test.
如果c是问题实例P的完整有效解，则accept过程应返回true，否则返回false。它可以假设树中的部分候选c及其所有祖先通过了拒绝测试
Note that the general pseudo-code above does not assume that the valid solutions are always leaves of the potential search tree. In other words, it admits the possibility that a valid solution for P can be further extended to yield other valid solutions.
注意，上面的一般伪代码不假设有效解决方案总是潜在搜索树的叶。换句话说，它承认P的有效解可以进一步扩展以产生其他有效解的可能性。</p>

<p>The first and next procedures are used by the backtracking algorithm to enumerate the children of a node c of the tree, that is, the candidates that differ from c by a single extension step. The call first(P,c) should yield the first child of c, in some order; and the call next(P,s) should return the next sibling of node s, in that order. Both functions should return a distinctive “null” candidate, denoted here by ‘Λ’, if the requested child does not exist.</p>

<p>回溯算法使用first 和 next方法 来遍历树的节点c的所有的子节点，即使候选方案通过c进一步的扩展。first(P,c) 应该是c的第一个孩子，按照某种的顺序，next(P,s)应该是s的兄弟节点，两个函数都有返回 null 的情况，这个使用’Λ’ 代表子节点不存在的情况。</p>

<p>Together, the root, first, and next functions define the set of partial candidates and the potential search tree. They should be chosen so that every solution of P occurs somewhere in the tree, and no partial candidate occurs more than once. Moreover, they should admit an efficient and effective reject predicate.</p>

<p>root first next 这些方法合起来标识潜在搜索树的候选方案的集合，这个集合中包含了树种全部的候选方案，并且候选方案没有重复。另外这些候选方案可以被 reject 方法处理。</p>

<p>Early stopping variants</p>

<p>The pseudo-code above will call output for all candidates that are a solution to the given instance P. The algorithm is easily modified to stop after finding the first solution, or a specified number of solutions; or after testing a specified number of partial candidates, or after spending a given amount of CPU time.</p>

<p>伪代码中是输出全部的解决的方案，如果修改为找到一个解决方案就返回，或者找个几个解决方案就返回，亦或是校验了特定数量的备选方案或者过了特定的时间 就返回，也不是什么难事。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>梳理一些的基础性的知识</title>
      <link href="http://andihappy.github.io//2016/10/01/"/>
      <pubDate>2016-10-23T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/10/01</guid>
      <content:encoded><![CDATA[<blockquote>
  <ol>
    <li>tomcat的体系结构</li>
    <li>自己对tomcat感兴趣的地方  <br />
  2.1 tomcat的请求接入的过程    <br />
  2.2 servet的生命周期的加载    <br />
  2.3 tomcat是怎么部署的，具体是怎么处理的。多个应用之间是怎么相互隔离的？tomcat的classloader机制是怎样的？    <br />
 2.4 关闭服务的时候，应该先暂停/关闭什么，后关闭什么？    <br />
 2.5 tomcat的扩展机制是通过什么方式提供给开发者的？   <br />
 2.6 BIO/NIO/APR 三种connector实现上的优劣是什么？    <br />
 2.7 jsp文件是怎么编译和执行的？</li>
    <li>tomcat中设计到的设计模式</li>
  </ol>
</blockquote>

<h4 id="tomcat-">1. tomcat 的体系结构</h4>

<p>首先就是tomcat的体系架构，在这个在很多的博客中都有提到，但是看他们的总没有自己看源码，看书中理解的透彻。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>自我的剖析</title>
      <link href="http://andihappy.github.io//2016/10/7/"/>
      <pubDate>2016-10-08T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/10/7</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>构建企业服务的过程中，我们采用的技术的分析，外加复盘的想法，理解自己项目中采用的技术，提高自己对架构的理解和对技术的眼界，首页我们要说的是tomcat</p>
</blockquote>

<p>####企业服务架构复盘
#####1. 目的</p>

<p>我们的工程是一个典型的springMVC提供的企业应用开发服务，在不泄密的前提下，分析一下这些工程的使用的技术和应用的场景，也就是复盘一下，提高自己对技术的眼界。</p>

<h5 id="section">2.具体的应用的技术</h5>

<p>2.1 tomcat</p>

<p>服务运行的环境是tomcat，但是关于tomcat的运用的方面是一个tomcat服务，对应一个服务。</p>

<blockquote>
  <p>当然这个是针对分离服务的框架，把企业的服务按照逻辑的划分，例如打卡，审批，财务等等的大块的逻辑，分成了不同的服务，然后按照技术人员严重的逻辑的划分，按照比较大的粒度分装成服务，我们现在说的服务，指的就是这个服务。        <br />
这种方案的划分的好处：一,服务拆分了出来之后，能够互相的不影响。对代码的跟新，不同模块版本的发布，资源的分配(例如企业服务中的请假服务压力就不会很大，一般人员不会每天都请假，针对这种情况的服务我们可以分配少一点的CPU，内存等资源)等有很大的好处。但是也有一定不好的地方，例如工程的管理当面，运维的管理。还是体现出现了那句话：       <br />
<strong>粒度小便于控制但是不便于管理。</strong></p>
</blockquote>

<p>这个地方必须的说一个tomcat，web应用开发的学习者第一次接受的web的容器必然是tomcat，这个可以说是最常见的，也是应用比较广泛的servlet容器。但是真正的理解和深入的了解并不是很多。自己的项目在使用tomcat的时候，自己是否应该好好的学习一下，最起码自己项目中用到的部分应该清楚理解。  <br />
首先是此篇说明tomcat的依据是：how tomcat works。</p>

<p>这本书于2016年10月23日看完，对tomcat的体系有了进一步的了解，找时间写一个总结。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>算法，基础类</title>
      <link href="http://andihappy.github.io//2016/09/30/"/>
      <pubDate>2016-09-22T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/09/30</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>基本的算法的描述，起到一个目录的作用，然后我们看看自己还有什么样的算法没有实现，没有说明白，把一个个的算法的名称，变为一个个的链接地址。</p>
</blockquote>

<p>算法描述：</p>

<blockquote>
  <p>1.排序算法</p>

</blockquote>

<p>  <a href="/2016/09/16"> 冒泡算法 </a>      <a href="/2016/09/17"> 插入排序</a> </p>

<p><a href="/2016/09/18"> 选择排序 </a>      <a href="/2016/09/19"> 堆排序 </a></p>

<p><a href="/2016/09/20"> 归并排序 </a>     <a href="/2016/09/21"> 快速排序 </a></p>

<p><a href="/2016/09/22"> 希尔排序 </a>     <a href="/2016/09/23"> 桶排序 </a> </p>

<p><a href="/2016/09/24"> 计数排序 </a>     <a href="/2016/09/24"> 基数排序 </a> </p>

<blockquote>
  <p>2.栈和队列</p>
</blockquote>

<p> <a href="/2016/09/25"> 栈     </a>   <a href="/2016/09/26"> 队列 </a> </p>

<blockquote>
  <p>3.树的结构</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>队列算法描述+代码实现</title>
      <link href="http://andihappy.github.io//2016/09/26/"/>
      <pubDate>2016-09-22T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/09/26</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>队列算法描述+代码实现</p>
</blockquote>

<p>队列的接口</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
    <span class="c1">// 入队列，如果空间不够则抛出异常</span>
    <span class="kt">boolean</span> <span class="n">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">);</span>

    <span class="c1">// 和add的逻辑很相似</span>
    <span class="kt">boolean</span> <span class="n">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">);</span>

    <span class="c1">//出队列，没有元素的时候抛异常</span>
    <span class="n">E</span> <span class="n">remove</span><span class="o">();</span>

    <span class="c1">//出队列，没有元素的时候为null</span>
    <span class="n">E</span> <span class="n">poll</span><span class="o">();</span>

    <span class="c1">//取队头，队列为空时抛异常</span>
    <span class="n">E</span> <span class="n">element</span><span class="o">();</span>

    <span class="c1">//取队头，队列为空的时候为空</span>
    <span class="n">E</span> <span class="n">peek</span><span class="o">();</span>
</code></pre>
</div>

<p>具体的实现的逻辑就是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * @author zhailz
 *
 * 时间：2016年9月26日 ### 下午3:51:35
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>

	<span class="cm">/**
	 * 队列对外提供的方法，说简单也挺简单的，只有两个：出队列和入队列
	 * 就队列的实现可以分为两类：数组和链表。
	 * 就队列的支持来说也可以分支两类：线程安全的，和线程不安全的
	 * */</span>

	<span class="kd">transient</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span> <span class="c1">// non-private to simplify nested class access</span>
	<span class="kd">transient</span> <span class="kt">int</span> <span class="n">head</span><span class="o">;</span>
	<span class="kd">transient</span> <span class="kt">int</span> <span class="n">tail</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>

	<span class="kd">public</span> <span class="n">MyQueue</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">MyQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">numElements</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">allocateElements</span><span class="o">(</span><span class="n">numElements</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="n">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
		<span class="n">elements</span><span class="o">[</span><span class="n">tail</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
		<span class="cm">/**
		 * tail = (tail + 1) 尾巴上面增加1
		 * 先下的值对数组的长度取余 与 head的值进行比较，确定队列时候已满
		 * tail &amp; (elements.length - 1) == head
		 *
		 * */</span>
		<span class="k">if</span> <span class="o">((</span><span class="n">tail</span> <span class="o">=</span> <span class="o">(</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">elements</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span>
			<span class="n">doubleCapacity</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">E</span> <span class="n">remove</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pollFirst</span><span class="o">();</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">NoSuchElementException</span><span class="o">();</span>
		<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">E</span> <span class="n">poll</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pollFirst</span><span class="o">();</span>
		<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">E</span> <span class="n">pollFirst</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
		<span class="n">E</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">elements</span><span class="o">[</span><span class="n">h</span><span class="o">];</span>
		<span class="c1">// Element is null if deque empty</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="n">elements</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// Must null out slot</span>
		<span class="c1">//出队列的时候的，对头的增长</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">elements</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">E</span> <span class="n">element</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">getFirst</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">E</span> <span class="n">getFirst</span><span class="o">()</span> <span class="o">{</span>
		<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
		<span class="n">E</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">elements</span><span class="o">[</span><span class="n">head</span><span class="o">];</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">NoSuchElementException</span><span class="o">();</span>
		<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="n">E</span> <span class="n">peek</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">// elements[head] is null if deque empty</span>
		<span class="k">return</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">elements</span><span class="o">[</span><span class="n">head</span><span class="o">];</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="n">doubleCapacity</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">assert</span> <span class="n">head</span> <span class="o">==</span> <span class="n">tail</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// number of elements to the right of p</span>
		<span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">newCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">"Sorry, deque too big"</span><span class="o">);</span>
		<span class="n">Object</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">newCapacity</span><span class="o">];</span>
		<span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
		<span class="n">elements</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//分配元素很有趣，为什么这么分配呢？</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="n">allocateElements</span><span class="o">(</span><span class="kt">int</span> <span class="n">numElements</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MIN_INITIAL_CAPACITY</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">numElements</span> <span class="o">&gt;=</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">numElements</span><span class="o">;</span>
			<span class="n">initialCapacity</span> <span class="o">|=</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
			<span class="n">initialCapacity</span> <span class="o">|=</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">);</span>
			<span class="n">initialCapacity</span> <span class="o">|=</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">);</span>
			<span class="n">initialCapacity</span> <span class="o">|=</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">);</span>
			<span class="n">initialCapacity</span> <span class="o">|=</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
			<span class="n">initialCapacity</span><span class="o">++;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// Too many elements, must back off</span>
				<span class="n">initialCapacity</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span><span class="c1">// Good luck allocating 2 ^ 30 elements</span>
		<span class="o">}</span>
		<span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">initialCapacity</span><span class="o">];</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>栈算法描述+代码实现</title>
      <link href="http://andihappy.github.io//2016/09/25/"/>
      <pubDate>2016-09-21T00:00:00+08:00</pubDate>
      <author>andihappy</author>
      <guid>http://andihappy.github.io//2016/09/25</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>栈算法描述+代码实现</p>
</blockquote>

<p>栈对外提供的方法，比较的简单，也不多。出栈，入栈，取栈顶元素，新建栈。  <br />
    1. pop   <br />
    2. push   <br />
    3. peek  <br />
    4. search（Java的JDK中提供了这个方法）</p>

<p>具体的实现的代码是：</p>

<pre><code class="language-Java">/**
 * @author zhailz
 *
 * 时间：2016年9月26日 ### 上午8:41:22
 *
 * 栈的逻辑
 *
 */
public class MyStack&lt;E&gt; {

	protected Object[] elementData;
	protected int elementCount;
	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
	protected int capacityIncrement;
	protected transient int modCount = 0;

	public MyStack(int initialCapacity, int capacityIncrement) {
		if (initialCapacity &lt; 0)
			throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
		this.elementData = new Object[initialCapacity];
		this.capacityIncrement = capacityIncrement;
	}

	public MyStack(int initialCapacity) {
		this(initialCapacity, 0);
	}

	public MyStack() {
		this(10);
	}

	/**
	 * 增加元素
	 */
	public E push(E item) {
		addElement(item);
		return item;
	}

	public synchronized E pop() {
		E obj;
		int len = size();
		obj = peek();
		removeElementAt(len - 1);
		return obj;
	}

	public synchronized void removeElementAt(int index) {
		modCount++;
		if (index &gt;= elementCount) {
			throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount);
		} else if (index &lt; 0) {
			throw new ArrayIndexOutOfBoundsException(index);
		}
		int j = elementCount - index - 1;
		//数组的复制，这种复制的方法免除了循环的复制的方法
		if (j &gt; 0) {
			// index + 1 ：复制开始的位置
			// index ：复制到的位置开始
			// j 复制的长度
			System.arraycopy(elementData, index + 1, elementData, index, j);
		}
		elementCount--;
		elementData[elementCount] = null; /* to let gc do its work */
	}

	public synchronized int size() {
		return elementCount;
	}

	public synchronized E peek() {
		int len = size();

		if (len == 0)
			throw new EmptyStackException();
		return elementAt(len - 1);
	}

	private synchronized E elementAt(int index) {
		if (index &gt;= elementCount) {
			throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount);
		}

		return elementData(index);
	}

	@SuppressWarnings("unchecked")
	private E elementData(int index) {
		return (E) elementData[index];
	}

	public synchronized void addElement(E obj) {
		modCount++;
		ensureCapacityHelper(elementCount + 1);
		elementData[elementCount++] = obj;
	}

	// 保证容量
	private void ensureCapacityHelper(int minCapacity) {
		if (minCapacity - elementData.length &gt; 0)
			grow(minCapacity);
	}

	private void grow(int minCapacity) {
		// overflow-conscious code
		int oldCapacity = elementData.length;
		//如果设置了增长的元素，每次的增长就按照设置的增长，没有的话，直接*2的增长
		int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);
		if (newCapacity - minCapacity &lt; 0)
			newCapacity = minCapacity;
		//超大的栈的时候，怎么处理
		if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
			newCapacity = hugeCapacity(minCapacity);
		elementData = Arrays.copyOf(elementData, newCapacity);
	}

	private static int hugeCapacity(int minCapacity) {
		if (minCapacity &lt; 0) // overflow
			throw new OutOfMemoryError();
		return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
	}

	public static void main(String[] args) {
		int[] a1 = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
		int[] a2 = new int[5];
		System.arraycopy(a1, 6, a2, 2, 2);
		System.out.println(Arrays.toString(a2));
	}

}
</code></pre>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
