---
layout: post
title: "JDK8的新特性2"
subtitle: "更新JDK知识-Stream"
author: "zhailzh"  
header-img: "img/post-bg-2015.jpg"  
catalog: true
tags: JDK  
---

JDK8的新特性：Stream  

第 1 部分: java.util.stream 库简介  
第 2 部分: 使用流执行聚合  
第 3 部分: Streams 的幕后原理  
第 4 部分: 从并发到并行  
第 5 部分: 并行流性能  

<!--more-->
示例代码：

~~~
List<String> myList =
    Arrays.asList("a1", "a2", "b1", "c2", "c1");

myList
    .stream()
    .filter(s -> s.startsWith("c"))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);
// C1
// C2
~~~  
Stream和其它集合类的区别在于：
> 其它集合类主要关注与有限数量的数据的**访问和有效管理**(增删改)，而Stream并没有提供访问和管理元素的方式，而是通过声明数据源的方式，利用可计算的操作在数据源上执行，当然BaseStream.iterator() 和 BaseStream.spliterator()操作提供了遍历元素的方法。
> 
> 集合关注的是有限元素的访问和管理，Stream关注的是数据源形成的操作

~~~
Arrays.asList("a1", "a2", "a3")
    .stream()
    .findFirst()
    .ifPresent(System.out::println);  // a1

long sum = ints.stream().mapToInt(Integer::intValue).sum();;


Stream.of("a1", "a2", "a3")
    .map(s -> s.substring(1))
    .mapToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println);  // 3

Stream.of(1.0, 2.0, 3.0)
        .mapToInt(Double::intValue)
        .mapToObj(i -> "a" + i)
        .forEach(System.out::println);

    // a1
    // a2
    // a3

Stream.of("d2", "a2", "b1", "b3", "c")
        .filter(s -> {
            System.out.println("filter: " + s);
            return true;
        });
~~~
